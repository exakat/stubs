<?php
/**
  * Generated by Exakat 2.1.6 (Build 1091)
  * On 2020-08-24T06:17:34+00:00
  * See https://www.exakat.io/
  */

namespace  {
}

namespace Slim {
    /**
     * A routable, middleware-aware object
     *
     * @package Slim
     * @since   3.0.0
     */
    abstract class Routable {
    use \slim\callableresolverawaretrait;

        /**
         * Route callable
         *
         * @var callable
         */
        protected $callable;
        /**
         * Container
         *
         * @var ContainerInterface
         */
        protected $container;
        /**
         * Route middleware
         *
         * @var callable[]
         */
        protected $middleware;
        /**
         * Route pattern
         *
         * @var string
         */
        protected $pattern;

        /**
         * Get the middleware registered for the group
         *
         * @return callable[]
         */
        public function getMiddleware() {}
        /**
         * Get the route pattern
         *
         * @return string
         */
        public function getPattern() {}
        public function setContainer(ContainerInterface $container) {}
        public function add($callable) {}
        public function setPattern($newPattern) {}
    }

    /**
     * Slim's default DI container is Pimple.
     *
     * Slim\App expects a container that implements Psr\Container\ContainerInterface
     * with these service keys configured and ready for use:
     *
     *  - settings: an array or instance of \ArrayAccess
     *  - environment: an instance of \Slim\Interfaces\Http\EnvironmentInterface
     *  - request: an instance of \Psr\Http\Message\ServerRequestInterface
     *  - response: an instance of \Psr\Http\Message\ResponseInterface
     *  - router: an instance of \Slim\Interfaces\RouterInterface
     *  - foundHandler: an instance of \Slim\Interfaces\InvocationStrategyInterface
     *  - errorHandler: a callable with the signature: function($request, $response, $exception)
     *  - notFoundHandler: a callable with the signature: function($request, $response)
     *  - notAllowedHandler: a callable with the signature: function($request, $response, $allowedHttpMethods)
     *  - callableResolver: an instance of \Slim\Interfaces\CallableResolverInterface
     *
     * @property-read array settings
     * @property-read \Slim\Interfaces\Http\EnvironmentInterface environment
     * @property-read \Psr\Http\Message\ServerRequestInterface request
     * @property-read \Psr\Http\Message\ResponseInterface response
     * @property-read \Slim\Interfaces\RouterInterface router
     * @property-read \Slim\Interfaces\InvocationStrategyInterface foundHandler
     * @property-read callable errorHandler
     * @property-read callable notFoundHandler
     * @property-read callable notAllowedHandler
     * @property-read \Slim\Interfaces\CallableResolverInterface callableResolver
     */
    class Container extends \pimple\container implements \interop\container\containerinterface {
        /**
         * Default settings
         *
         * @var array
         */
        private $defaultSettings;

        public function __construct(array $values = [ ]) {}
        private function registerDefaultServices($userSettings) {}
        public function get($id) {}
        private function exceptionThrownByContainer(\InvalidArgumentException $exception) {}
        public function has($id) {}
        public function __get($name) {}
        public function __isset($name) {}
    }

    /**
     * App
     *
     * This is the primary class with which you instantiate,
     * configure, and run a Slim Framework application.
     * The \Slim\App class also accepts Slim Framework middleware.
     *
     * @property-read callable $errorHandler
     * @property-read callable $phpErrorHandler
     * @property-read callable $notFoundHandler function($request, $response)
     * @property-read callable $notAllowedHandler function($request, $response, $allowedHttpMethods)
     */
    class App {
    use \slim\middlewareawaretrait;

        const VERSION = '3.11.0';

        /**
         * Container
         *
         * @var ContainerInterface
         */
        private $container;

        public function __construct($container = [ ]) {}
        /**
         * Enable access to the DI container by consumers of $app
         *
         * @return ContainerInterface
         */
        public function getContainer() {}
        public function add($callable) {}
        public function __call($method, $args) {}
        public function get($pattern, $callable) {}
        public function post($pattern, $callable) {}
        public function put($pattern, $callable) {}
        public function patch($pattern, $callable) {}
        public function delete($pattern, $callable) {}
        public function options($pattern, $callable) {}
        public function any($pattern, $callable) {}
        public function map(array $methods, $pattern, $callable) {}
        public function redirect($from, $to, $status = 302) {}
/** @var RouteGroup $group */
        public function group(/** @var RouteGroup $group */
$pattern, /** @var RouteGroup $group */
$callable) {}
        public function run($silent = false) {}
        protected function processInvalidMethod(ServerRequestInterface $request, ResponseInterface $response) {}
        public function process(ServerRequestInterface $request, ResponseInterface $response) {}
        public function respond(ResponseInterface $response) {}
/** @var callable $notFoundHandler */
        public function __invoke(/** @var callable $notFoundHandler */
ServerRequestInterface $request, /** @var callable $notFoundHandler */
ResponseInterface $response) {}
        public function subRequest($method, $path, $query = '', array $headers = [ ], array $cookies = [ ], $bodyContent = '', ResponseInterface $response = null) {}
        protected function dispatchRouterAndPrepareRoute(ServerRequestInterface $request, RouterInterface $router) {}
        protected function finalize(ResponseInterface $response) {}
        protected function isEmptyResponse(ResponseInterface $response) {}
        protected function handleException(Exception $e, ServerRequestInterface $request, ResponseInterface $response) {}
        protected function handlePhpError(Throwable $e, ServerRequestInterface $request, ResponseInterface $response) {}
    }

    class DeferredCallable {
    use \slim\callableresolverawaretrait;

        private $callable;
        /** @var  ContainerInterface */
        private $container;

        public function __construct($callable, ContainerInterface $container = null) {}
        public function __invoke() {}
    }

    /**
     * A collector for Routable objects with a common middleware stack
     *
     * @package Slim
     */
    class RouteGroup extends \slim\routable implements \slim\interfaces\routegroupinterface {
        public function __construct($pattern, $callable) {}
        public function __invoke(App $app = null) {}
    }

    /**
     * Route
     */
    class Route extends \slim\routable implements \slim\interfaces\routeinterface {
    use \slim\middlewareawaretrait;

        /**
         * HTTP methods supported by this route
         *
         * @var string[]
         */
        protected $methods;
        /**
         * Route identifier
         *
         * @var string
         */
        protected $identifier;
        /**
         * Route name
         *
         * @var null|string
         */
        protected $name;
        /**
         * Parent route groups
         *
         * @var RouteGroup[]
         */
        protected $groups;
        private $finalized;
        /**
         * Output buffering mode
         *
         * One of: false, 'prepend' or 'append'
         *
         * @var boolean|string
         */
        protected $outputBuffering;
        /**
         * Route parameters
         *
         * @var array
         */
        protected $arguments;
        /**
         * Route arguments parameters
         *
         * @var null|array
         */
        protected $savedArguments;
        /**
         * The callable payload
         *
         * @var callable
         */
        protected $callable;

        public function __construct($methods, $pattern, $callable, $groups = [ ], $identifier = 0) {}
        /**
         * Finalize the route in preparation for dispatching
         */
        public function finalize() {}
        /**
         * Get route callable
         *
         * @return callable
         */
        public function getCallable() {}
        public function setCallable($callable) {}
        /**
         * Get route methods
         *
         * @return string[]
         */
        public function getMethods() {}
        /**
         * Get parent route groups
         *
         * @return RouteGroup[]
         */
        public function getGroups() {}
        /**
         * Get route name
         *
         * @return null|string
         */
        public function getName() {}
        /**
         * Get route identifier
         *
         * @return string
         */
        public function getIdentifier() {}
        /**
         * Get output buffering mode
         *
         * @return boolean|string
         */
        public function getOutputBuffering() {}
        public function setOutputBuffering($mode) {}
        public function setName($name) {}
        public function setArgument($name, $value, $includeInSavedArguments = true) {}
        public function setArguments(array $arguments, $includeInSavedArguments = true) {}
        /**
         * Retrieve route arguments
         *
         * @return array
         */
        public function getArguments() {}
        public function getArgument($name, $default = null) {}
        public function prepare(ServerRequestInterface $request, array $arguments) {}
        public function run(ServerRequestInterface $request, ResponseInterface $response) {}
/** @var InvocationStrategyInterface $handler */
        public function __invoke(/** @var InvocationStrategyInterface $handler */
ServerRequestInterface $request, /** @var InvocationStrategyInterface $handler */
ResponseInterface $response) {}
    }

    /**
     * Router
     *
     * This class organizes Slim application route objects. It is responsible
     * for registering route objects, assigning names to route objects,
     * finding routes that match the current HTTP request, and creating
     * URLs for a named route.
     */
    class Router implements \slim\interfaces\routerinterface {
        /**
         * Container Interface
         *
         * @var ContainerInterface
         */
        protected $container;
        /**
         * Parser
         *
         * @var \FastRoute\RouteParser
         */
        protected $routeParser;
        /**
         * Base path used in pathFor()
         *
         * @var string
         */
        protected $basePath;
        /**
         * Path to fast route cache file. Set to false to disable route caching
         *
         * @var string|False
         */
        protected $cacheFile;
        /**
         * Routes
         *
         * @var Route[]
         */
        protected $routes;
        /**
         * Route counter incrementer
         * @var int
         */
        protected $routeCounter;
        /**
         * Route groups
         *
         * @var RouteGroup[]
         */
        protected $routeGroups;
        /**
         * @var \FastRoute\Dispatcher
         */
        protected $dispatcher;

        public function __construct(RouteParser $parser = null) {}
        public function setBasePath($basePath) {}
        public function setCacheFile($cacheFile) {}
        public function setContainer(ContainerInterface $container) {}
        public function map($methods, $pattern, $handler) {}
        public function dispatch(ServerRequestInterface $request) {}
        protected function createRoute($methods, $pattern, $callable) {}
        /**
         * @return \FastRoute\Dispatcher
         */
        protected function createDispatcher() {}
        public function setDispatcher(Dispatcher $dispatcher) {}
        /**
         * Get route objects
         *
         * @return Route[]
         */
        public function getRoutes() {}
        public function getNamedRoute($name) {}
        public function removeNamedRoute($name) {}
        /**
         * Process route groups
         *
         * @return string A group pattern to prefix routes with
         */
        protected function processGroups() {}
        public function pushGroup($pattern, $callable) {}
        /**
         * Removes the last route group from the array
         *
         * @return RouteGroup|bool The RouteGroup if successful, else False
         */
        public function popGroup() {}
        public function lookupRoute($identifier) {}
        public function relativePathFor($name, array $data = [ ], array $queryParams = [ ]) {}
        public function pathFor($name, array $data = [ ], array $queryParams = [ ]) {}
        public function urlFor($name, array $data = [ ], array $queryParams = [ ]) {}
    }

    /**
     * Collection
     *
     * This class provides a common interface used by many other
     * classes in a Slim application that manage "collections"
     * of data that must be inspected and/or manipulated
     */
    class Collection implements \slim\interfaces\collectioninterface {
        /**
         * The source data
         *
         * @var array
         */
        protected $data;

        public function __construct(array $items = [ ]) {}
        public function set($key, $value) {}
        public function get($key, $default = null) {}
        public function replace(array $items) {}
        /**
         * Get all items in collection
         *
         * @return array The collection's source data
         */
        public function all() {}
        /**
         * Get collection keys
         *
         * @return array The collection's source data keys
         */
        public function keys() {}
        public function has($key) {}
        public function remove($key) {}
        /**
         * Remove all items from collection
         */
        public function clear() {}
        public function offsetExists($key) {}
        public function offsetGet($key) {}
        public function offsetSet($key, $value) {}
        public function offsetUnset($key) {}
        /**
         * Get number of items in collection
         *
         * @return int
         */
        public function count() {}
        /**
         * Get collection iterator
         *
         * @return \ArrayIterator
         */
        public function getIterator() {}
    }

    /**
     * Slim's default Service Provider.
     */
    class DefaultServicesProvider {
        public function register($container) {}
    }

    /**
     * This class resolves a string of the format 'class:method' into a closure
     * that can be dispatched.
     */
    final class CallableResolver implements \slim\interfaces\callableresolverinterface {
        const CALLABLE_PATTERN = '!^([^\:]+)\:([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)$!';

        /**
         * @var ContainerInterface
         */
        private $container;

        public function __construct(ContainerInterface $container) {}
        public function resolve($toResolve) {}
        protected function resolveCallable($class, $method = '__invoke') {}
        protected function assertCallable($callable) {}
    }


    /**
     * Middleware
     *
     * This is an internal class that enables concentric middleware layers. This
     * class is an implementation detail and is used only inside of the Slim
     * application; it is not visible to—and should not be used by—end users.
     */
    trait MiddlewareAwareTrait {
        /**
         * Tip of the middleware call stack
         *
         * @var callable
         */
        protected $tip;
        /**
         * Middleware stack lock
         *
         * @var bool
         */
        protected $middlewareLock;
        protected function addMiddleware(callable $callable) {}
        protected function seedMiddlewareStack(callable $kernel = null) {}
/** @var callable $start */
        public function callMiddlewareStack(/** @var callable $start */
ServerRequestInterface $request, /** @var callable $start */
ResponseInterface $response) {}
    }

    /**
     * ResolveCallable
     *
     * This is an internal class that enables resolution of 'class:method' strings
     * into a closure. This class is an implementation detail and is used only inside
     * of the Slim application.
     *
     * @property ContainerInterface $container
     */
    trait CallableResolverAwareTrait {
/** @var CallableResolverInterface $resolver */
        protected function resolveCallable(/** @var CallableResolverInterface $resolver */
$callable) {}
    }

}

namespace Slim\Http {
    /**
     * Headers
     *
     * This class represents a collection of HTTP headers
     * that is used in both the HTTP request and response objects.
     * It also enables header name case-insensitivity when
     * getting or setting a header value.
     *
     * Each HTTP header can have multiple values. This class
     * stores values into an array for each header name. When
     * you request a header value, you receive an array of values
     * for that header.
     */
    class Headers extends \slim\collection implements \slim\interfaces\http\headersinterface {
        /**
         * Special HTTP headers that do not have the "HTTP_" prefix
         *
         * @var array
         */
        static protected $special;

        public static function createFromEnvironment(Environment $environment) {}
        public static function determineAuthorization(Environment $environment) {}
        /**
         * Return array of HTTP header names and values.
         * This method returns the _original_ header name
         * as specified by the end user.
         *
         * @return array
         */
        public function all() {}
        public function set($key, $value) {}
        public function get($key, $default = null) {}
        public function getOriginalKey($key, $default = null) {}
        public function add($key, $value) {}
        public function has($key) {}
        public function remove($key) {}
        public function normalizeKey($key) {}
    }

    /**
     * Cookie helper
     */
    class Cookies implements \slim\interfaces\http\cookiesinterface {
        /**
         * Cookies from HTTP request
         *
         * @var array
         */
        protected $requestCookies;
        /**
         * Cookies for HTTP response
         *
         * @var array
         */
        protected $responseCookies;
        /**
         * Default cookie properties
         *
         * @var array
         */
        protected $defaults;

        public function __construct(array $cookies = [ ]) {}
        public function setDefaults(array $settings) {}
        public function get($name, $default = null) {}
        public function set($name, $value) {}
        /**
         * Convert to `Set-Cookie` headers
         *
         * @return string[]
         */
        public function toHeaders() {}
        protected function toHeader($name, array $properties) {}
        public static function parseHeader($header) {}
    }

    /**
     * Response
     *
     * This class represents an HTTP response. It manages
     * the response status, headers, and body
     * according to the PSR-7 standard.
     *
     * @link https://github.com/php-fig/http-message/blob/master/src/MessageInterface.php
     * @link https://github.com/php-fig/http-message/blob/master/src/ResponseInterface.php
     */
    class Response extends \slim\http\message implements \psr\http\message\responseinterface {
        const EOL = "\r\n";

        /**
         * Status code
         *
         * @var int
         */
        protected $status;
        /**
         * Reason phrase
         *
         * @var string
         */
        protected $reasonPhrase;
        /**
         * Status codes and reason phrases
         *
         * @var array
         */
        static protected $messages;

        public function __construct($status = StatusCode::HTTP_OK, HeadersInterface $headers = null, StreamInterface $body = null) {}
        /**
         * This method is applied to the cloned object
         * after PHP performs an initial shallow-copy. This
         * method completes a deep-copy by creating new objects
         * for the cloned object's internal reference pointers.
         */
        public function __clone() {}
        /**
         * Gets the response status code.
         *
         * The status code is a 3-digit integer result code of the server's attempt
         * to understand and satisfy the request.
         *
         * @return int Status code.
         */
        public function getStatusCode() {}
        public function withStatus($code, $reasonPhrase = '') {}
        protected function filterStatus($status) {}
        /**
         * Gets the response reason phrase associated with the status code.
         *
         * Because a reason phrase is not a required element in a response
         * status line, the reason phrase value MAY be null. Implementations MAY
         * choose to return the default RFC 7231 recommended reason phrase (or those
         * listed in the IANA HTTP Status Code Registry) for the response's
         * status code.
         *
         * @link http://tools.ietf.org/html/rfc7231#section-6
         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
         * @return string Reason phrase; must return an empty string if none present.
         */
        public function getReasonPhrase() {}
        public function withHeader($name, $value) {}
        public function write($data) {}
        public function withRedirect($url, $status = null) {}
        public function withJson($data, $status = null, $encodingOptions = 0) {}
        /**
         * Is this response empty?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isEmpty() {}
        /**
         * Is this response informational?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isInformational() {}
        /**
         * Is this response OK?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isOk() {}
        /**
         * Is this response successful?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isSuccessful() {}
        /**
         * Is this response a redirect?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isRedirect() {}
        /**
         * Is this response a redirection?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isRedirection() {}
        /**
         * Is this response forbidden?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         * @api
         */
        public function isForbidden() {}
        /**
         * Is this response not Found?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isNotFound() {}
        /**
         * Is this response a client error?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isClientError() {}
        /**
         * Is this response a server error?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isServerError() {}
        /**
         * Convert response to string.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return string
         */
        public function __toString() {}
    }

    /**
     * Body
     *
     * This class represents an HTTP message body and encapsulates a
     * streamable resource according to the PSR-7 standard.
     *
     * @link https://github.com/php-fig/http-message/blob/master/src/StreamInterface.php
     */
    class Body extends \slim\http\stream {}

    /**
     * Represents a data stream as defined in PSR-7.
     *
     * @link https://github.com/php-fig/http-message/blob/master/src/StreamInterface.php
     */
    class Stream implements \psr\http\message\streaminterface {
        const FSTAT_MODE_S_IFIFO = 10000;

        /**
         * Resource modes
         *
         * @var  array
         * @link http://php.net/manual/function.fopen.php
         */
        static protected $modes;
        /**
         * The underlying stream resource
         *
         * @var resource
         */
        protected $stream;
        /**
         * Stream metadata
         *
         * @var array
         */
        protected $meta;
        /**
         * Is this stream readable?
         *
         * @var bool
         */
        protected $readable;
        /**
         * Is this stream writable?
         *
         * @var bool
         */
        protected $writable;
        /**
         * Is this stream seekable?
         *
         * @var bool
         */
        protected $seekable;
        /**
         * The size of the stream if known
         *
         * @var null|int
         */
        protected $size;
        /**
         * Is this stream a pipe?
         *
         * @var bool
         */
        protected $isPipe;

        public function __construct($stream) {}
        public function getMetadata($key = null) {}
        /**
         * Is a resource attached to this stream?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        protected function isAttached() {}
        protected function attach($newStream) {}
        /**
         * Separates any underlying resources from the stream.
         *
         * After the stream has been detached, the stream is in an unusable state.
         *
         * @return resource|null Underlying PHP stream, if any
         */
        public function detach() {}
        /**
         * Reads all data from the stream into a string, from the beginning to end.
         *
         * This method MUST attempt to seek to the beginning of the stream before
         * reading data and read the stream until the end is reached.
         *
         * Warning: This could attempt to load a large amount of data into memory.
         *
         * This method MUST NOT raise an exception in order to conform with PHP's
         * string casting operations.
         *
         * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring
         * @return string
         */
        public function __toString() {}
        /**
         * Closes the stream and any underlying resources.
         */
        public function close() {}
        /**
         * Get the size of the stream if known.
         *
         * @return int|null Returns the size in bytes if known, or null if unknown.
         */
        public function getSize() {}
        /**
         * Returns the current position of the file read/write pointer
         *
         * @return int Position of the file pointer
         *
         * @throws RuntimeException on error.
         */
        public function tell() {}
        /**
         * Returns true if the stream is at the end of the stream.
         *
         * @return bool
         */
        public function eof() {}
        /**
         * Returns whether or not the stream is readable.
         *
         * @return bool
         */
        public function isReadable() {}
        /**
         * Returns whether or not the stream is writable.
         *
         * @return bool
         */
        public function isWritable() {}
        /**
         * Returns whether or not the stream is seekable.
         *
         * @return bool
         */
        public function isSeekable() {}
        public function seek($offset, $whence = SEEK_SET) {}
        /**
         * Seek to the beginning of the stream.
         *
         * If the stream is not seekable, this method will raise an exception;
         * otherwise, it will perform a seek(0).
         *
         * @see seek()
         *
         * @link http://www.php.net/manual/en/function.fseek.php
         *
         * @throws RuntimeException on failure.
         */
        public function rewind() {}
        public function read($length) {}
        public function write($string) {}
        /**
         * Returns the remaining contents in a string
         *
         * @return string
         *
         * @throws RuntimeException if unable to read or an error occurs while
         *     reading.
         */
        public function getContents() {}
        /**
         * Returns whether or not the stream is a pipe.
         *
         * @return bool
         */
        public function isPipe() {}
    }

    /**
     * Request
     *
     * This class represents an HTTP request. It manages
     * the request method, URI, headers, cookies, and body
     * according to the PSR-7 standard.
     *
     * @link https://github.com/php-fig/http-message/blob/master/src/MessageInterface.php
     * @link https://github.com/php-fig/http-message/blob/master/src/RequestInterface.php
     * @link https://github.com/php-fig/http-message/blob/master/src/ServerRequestInterface.php
     */
    class Request extends \slim\http\message implements \psr\http\message\serverrequestinterface {
        /**
         * The request method
         *
         * @var string
         */
        protected $method;
        /**
         * The original request method (ignoring override)
         *
         * @var string
         */
        protected $originalMethod;
        /**
         * The request URI object
         *
         * @var \Psr\Http\Message\UriInterface
         */
        protected $uri;
        /**
         * The request URI target (path + query string)
         *
         * @var string
         */
        protected $requestTarget;
        /**
         * The request query string params
         *
         * @var array
         */
        protected $queryParams;
        /**
         * The request cookies
         *
         * @var array
         */
        protected $cookies;
        /**
         * The server environment variables at the time the request was created.
         *
         * @var array
         */
        protected $serverParams;
        /**
         * The request attributes (route segment names and values)
         *
         * @var \Slim\Collection
         */
        protected $attributes;
        /**
         * The request body parsed (if possible) into a PHP array or object
         *
         * @var null|array|object
         */
        protected $bodyParsed;
        /**
         * List of request body parsers (e.g., url-encoded, JSON, XML, multipart)
         *
         * @var callable[]
         */
        protected $bodyParsers;
        /**
         * List of uploaded files
         *
         * @var UploadedFileInterface[]
         */
        protected $uploadedFiles;
        /**
         * Valid request methods
         *
         * @var string[]
         * @deprecated
         */
        protected $validMethods;

        public static function createFromEnvironment(Environment $environment) {}
        public function __construct($method, UriInterface $uri, HeadersInterface $headers, array $cookies, array $serverParams, StreamInterface $body, array $uploadedFiles = [ ]) {}
        /**
         * This method is applied to the cloned object
         * after PHP performs an initial shallow-copy. This
         * method completes a deep-copy by creating new objects
         * for the cloned object's internal reference pointers.
         */
        public function __clone() {}
        /**
         * Retrieves the HTTP method of the request.
         *
         * @return string Returns the request method.
         */
        public function getMethod() {}
        /**
         * Get the original HTTP method (ignore override).
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return string
         */
        public function getOriginalMethod() {}
        public function withMethod($method) {}
        protected function filterMethod($method) {}
        public function isMethod($method) {}
        /**
         * Is this a GET request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isGet() {}
        /**
         * Is this a POST request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isPost() {}
        /**
         * Is this a PUT request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isPut() {}
        /**
         * Is this a PATCH request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isPatch() {}
        /**
         * Is this a DELETE request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isDelete() {}
        /**
         * Is this a HEAD request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isHead() {}
        /**
         * Is this a OPTIONS request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isOptions() {}
        /**
         * Is this an XHR request?
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return bool
         */
        public function isXhr() {}
        /**
         * Retrieves the message's request target.
         *
         * Retrieves the message's request-target either as it will appear (for
         * clients), as it appeared at request (for servers), or as it was
         * specified for the instance (see withRequestTarget()).
         *
         * In most cases, this will be the origin-form of the composed URI,
         * unless a value was provided to the concrete implementation (see
         * withRequestTarget() below).
         *
         * If no URI is available, and no request-target has been specifically
         * provided, this method MUST return the string "/".
         *
         * @return string
         */
        public function getRequestTarget() {}
        public function withRequestTarget($requestTarget) {}
        /**
         * Retrieves the URI instance.
         *
         * This method MUST return a UriInterface instance.
         *
         * @link http://tools.ietf.org/html/rfc3986#section-4.3
         * @return UriInterface Returns a UriInterface instance
         *     representing the URI of the request.
         */
        public function getUri() {}
        public function withUri(UriInterface $uri, $preserveHost = false) {}
        /**
         * Get request content type.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return string|null The request content type, if known
         */
        public function getContentType() {}
        /**
         * Get request media type, if known.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return string|null The request media type, minus content-type params
         */
        public function getMediaType() {}
        /**
         * Get request media type params, if known.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return array
         */
        public function getMediaTypeParams() {}
        /**
         * Get request content character set, if known.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return string|null
         */
        public function getContentCharset() {}
        /**
         * Get request content length, if known.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return int|null
         */
        public function getContentLength() {}
        /**
         * Retrieve cookies.
         *
         * Retrieves cookies sent by the client to the server.
         *
         * The data MUST be compatible with the structure of the $_COOKIE
         * superglobal.
         *
         * @return array
         */
        public function getCookieParams() {}
        public function getCookieParam($key, $default = null) {}
        public function withCookieParams(array $cookies) {}
        /**
         * Retrieve query string arguments.
         *
         * Retrieves the deserialized query string arguments, if any.
         *
         * Note: the query params might not be in sync with the URI or server
         * params. If you need to ensure you are only getting the original
         * values, you may need to parse the query string from `getUri()->getQuery()`
         * or from the `QUERY_STRING` server param.
         *
         * @return array
         */
        public function getQueryParams() {}
        public function withQueryParams(array $query) {}
        /**
         * Retrieve normalized file upload data.
         *
         * This method returns upload metadata in a normalized tree, with each leaf
         * an instance of Psr\Http\Message\UploadedFileInterface.
         *
         * These values MAY be prepared from $_FILES or the message body during
         * instantiation, or MAY be injected via withUploadedFiles().
         *
         * @return array An array tree of UploadedFileInterface instances; an empty
         *     array MUST be returned if no data is present.
         */
        public function getUploadedFiles() {}
        public function withUploadedFiles(array $uploadedFiles) {}
        /**
         * Retrieve server parameters.
         *
         * Retrieves data related to the incoming request environment,
         * typically derived from PHP's $_SERVER superglobal. The data IS NOT
         * REQUIRED to originate from $_SERVER.
         *
         * @return array
         */
        public function getServerParams() {}
        public function getServerParam($key, $default = null) {}
        /**
         * Retrieve attributes derived from the request.
         *
         * The request "attributes" may be used to allow injection of any
         * parameters derived from the request: e.g., the results of path
         * match operations; the results of decrypting cookies; the results of
         * deserializing non-form-encoded message bodies; etc. Attributes
         * will be application and request specific, and CAN be mutable.
         *
         * @return array Attributes derived from the request.
         */
        public function getAttributes() {}
        public function getAttribute($name, $default = null) {}
        public function withAttribute($name, $value) {}
        public function withAttributes(array $attributes) {}
        public function withoutAttribute($name) {}
        /**
         * Retrieve any parameters provided in the request body.
         *
         * If the request Content-Type is either application/x-www-form-urlencoded
         * or multipart/form-data, and the request method is POST, this method MUST
         * return the contents of $_POST.
         *
         * Otherwise, this method may return any results of deserializing
         * the request body content; as parsing returns structured content, the
         * potential types MUST be arrays or objects only. A null value indicates
         * the absence of body content.
         *
         * @return null|array|object The deserialized body parameters, if any.
         *     These will typically be an array or object.
         * @throws RuntimeException if the request body media type parser returns an invalid value
         */
        public function getParsedBody() {}
        public function withParsedBody($data) {}
        /**
         * Force Body to be parsed again.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * @return $this
         */
        public function reparseBody() {}
        public function registerMediaTypeParser($mediaType, callable $callable) {}
        public function getParam($key, $default = null) {}
        public function getParsedBodyParam($key, $default = null) {}
        public function getQueryParam($key, $default = null) {}
        public function getParams(array $only = null) {}
    }

    /**
     * Provides a PSR-7 implementation of a reusable raw request body
     */
    class RequestBody extends \slim\http\body {
        /**
         * Create a new RequestBody.
         */
        public function __construct() {}
    }

    /**
     * Value object representing a URI.
     *
     * This interface is meant to represent URIs according to RFC 3986 and to
     * provide methods for most common operations. Additional functionality for
     * working with URIs can be provided on top of the interface or externally.
     * Its primary use is for HTTP requests, but may also be used in other
     * contexts.
     *
     * Instances of this interface are considered immutable; all methods that
     * might change state MUST be implemented such that they retain the internal
     * state of the current instance and return an instance that contains the
     * changed state.
     *
     * Typically the Host header will be also be present in the request message.
     * For server-side requests, the scheme will typically be discoverable in the
     * server parameters.
     *
     * @link http://tools.ietf.org/html/rfc3986 (the URI specification)
     */
    class Uri implements \psr\http\message\uriinterface {
        /**
         * Uri scheme (without "://" suffix)
         *
         * @var string
         */
        protected $scheme;
        /**
         * Uri user
         *
         * @var string
         */
        protected $user;
        /**
         * Uri password
         *
         * @var string
         */
        protected $password;
        /**
         * Uri host
         *
         * @var string
         */
        protected $host;
        /**
         * Uri port number
         *
         * @var null|int
         */
        protected $port;
        /**
         * Uri base path
         *
         * @var string
         */
        protected $basePath;
        /**
         * Uri path
         *
         * @var string
         */
        protected $path;
        /**
         * Uri query string (without "?" prefix)
         *
         * @var string
         */
        protected $query;
        /**
         * Uri fragment string (without "#" prefix)
         *
         * @var string
         */
        protected $fragment;

        public function __construct($scheme, $host, $port = null, $path = '/', $query = '', $fragment = '', $user = '', $password = '') {}
        public static function createFromString($uri) {}
        public static function createFromEnvironment(Environment $env) {}
        /**
         * Retrieve the scheme component of the URI.
         *
         * If no scheme is present, this method MUST return an empty string.
         *
         * The value returned MUST be normalized to lowercase, per RFC 3986
         * Section 3.1.
         *
         * The trailing ":" character is not part of the scheme and MUST NOT be
         * added.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-3.1
         * @return string The URI scheme.
         */
        public function getScheme() {}
        public function withScheme($scheme) {}
        protected function filterScheme($scheme) {}
        /**
         * Retrieve the authority component of the URI.
         *
         * If no authority information is present, this method MUST return an empty
         * string.
         *
         * The authority syntax of the URI is:
         *
         * <pre>
         * [user-info@]host[:port]
         * </pre>
         *
         * If the port component is not set or is the standard port for the current
         * scheme, it SHOULD NOT be included.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-3.2
         * @return string The URI authority, in "[user-info@]host[:port]" format.
         */
        public function getAuthority() {}
        /**
         * Retrieve the user information component of the URI.
         *
         * If no user information is present, this method MUST return an empty
         * string.
         *
         * If a user is present in the URI, this will return that value;
         * additionally, if the password is also present, it will be appended to the
         * user value, with a colon (":") separating the values.
         *
         * The trailing "@" character is not part of the user information and MUST
         * NOT be added.
         *
         * @return string The URI user information, in "username[:password]" format.
         */
        public function getUserInfo() {}
        public function withUserInfo($user, $password = null) {}
        protected function filterUserInfo($query) {}
        /**
         * Retrieve the host component of the URI.
         *
         * If no host is present, this method MUST return an empty string.
         *
         * The value returned MUST be normalized to lowercase, per RFC 3986
         * Section 3.2.2.
         *
         * @see http://tools.ietf.org/html/rfc3986#section-3.2.2
         * @return string The URI host.
         */
        public function getHost() {}
        public function withHost($host) {}
        /**
         * Retrieve the port component of the URI.
         *
         * If a port is present, and it is non-standard for the current scheme,
         * this method MUST return it as an integer. If the port is the standard port
         * used with the current scheme, this method SHOULD return null.
         *
         * If no port is present, and no scheme is present, this method MUST return
         * a null value.
         *
         * If no port is present, but a scheme is present, this method MAY return
         * the standard port for that scheme, but SHOULD return null.
         *
         * @return null|int The URI port.
         */
        public function getPort() {}
        public function withPort($port) {}
        /**
         * Does this Uri use a standard port?
         *
         * @return bool
         */
        protected function hasStandardPort() {}
        protected function filterPort($port) {}
        /**
         * Retrieve the path component of the URI.
         *
         * The path can either be empty or absolute (starting with a slash) or
         * rootless (not starting with a slash). Implementations MUST support all
         * three syntaxes.
         *
         * Normally, the empty path "" and absolute path "/" are considered equal as
         * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically
         * do this normalization because in contexts with a trimmed base path, e.g.
         * the front controller, this difference becomes significant. It's the task
         * of the user to handle both "" and "/".
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.3.
         *
         * As an example, if the value should include a slash ("/") not intended as
         * delimiter between path segments, that value MUST be passed in encoded
         * form (e.g., "%2F") to the instance.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.3
         * @return string The URI path.
         */
        public function getPath() {}
        public function withPath($path) {}
        /**
         * Retrieve the base path segment of the URI.
         *
         * Note: This method is not part of the PSR-7 standard.
         *
         * This method MUST return a string; if no path is present it MUST return
         * an empty string.
         *
         * @return string The base path segment of the URI.
         */
        public function getBasePath() {}
        public function withBasePath($basePath) {}
        protected function filterPath($path) {}
        /**
         * Retrieve the query string of the URI.
         *
         * If no query string is present, this method MUST return an empty string.
         *
         * The leading "?" character is not part of the query and MUST NOT be
         * added.
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.4.
         *
         * As an example, if a value in a key/value pair of the query string should
         * include an ampersand ("&") not intended as a delimiter between values,
         * that value MUST be passed in encoded form (e.g., "%26") to the instance.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.4
         * @return string The URI query string.
         */
        public function getQuery() {}
        public function withQuery($query) {}
        protected function filterQuery($query) {}
        /**
         * Retrieve the fragment component of the URI.
         *
         * If no fragment is present, this method MUST return an empty string.
         *
         * The leading "#" character is not part of the fragment and MUST NOT be
         * added.
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.5.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.5
         * @return string The URI fragment.
         */
        public function getFragment() {}
        public function withFragment($fragment) {}
        /**
         * Return the string representation as a URI reference.
         *
         * Depending on which components of the URI are present, the resulting
         * string is either a full URI or relative reference according to RFC 3986,
         * Section 4.1. The method concatenates the various components of the URI,
         * using the appropriate delimiters:
         *
         * - If a scheme is present, it MUST be suffixed by ":".
         * - If an authority is present, it MUST be prefixed by "//".
         * - The path can be concatenated without delimiters. But there are two
         *   cases where the path has to be adjusted to make the URI reference
         *   valid as PHP does not allow to throw an exception in __toString():
         *     - If the path is rootless and an authority is present, the path MUST
         *       be prefixed by "/".
         *     - If the path is starting with more than one "/" and no authority is
         *       present, the starting slashes MUST be reduced to one.
         * - If a query is present, it MUST be prefixed by "?".
         * - If a fragment is present, it MUST be prefixed by "#".
         *
         * @see http://tools.ietf.org/html/rfc3986#section-4.1
         * @return string
         */
        public function __toString() {}
        /**
         * Return the fully qualified base URL.
         *
         * Note that this method never includes a trailing /
         *
         * This method is not part of PSR-7.
         *
         * @return string
         */
        public function getBaseUrl() {}
    }

    /**
     * Represents Uploaded Files.
     *
     * It manages and normalizes uploaded files according to the PSR-7 standard.
     *
     * @link https://github.com/php-fig/http-message/blob/master/src/UploadedFileInterface.php
     * @link https://github.com/php-fig/http-message/blob/master/src/StreamInterface.php
     */
    class UploadedFile implements \psr\http\message\uploadedfileinterface {
        /**
         * The client-provided full path to the file
         *
         * @note this is public to maintain BC with 3.1.0 and earlier.
         *
         * @var string
         */
        public $file;
        /**
         * The client-provided file name.
         *
         * @var string
         */
        protected $name;
        /**
         * The client-provided media type of the file.
         *
         * @var string
         */
        protected $type;
        /**
         * The size of the file in bytes.
         *
         * @var int
         */
        protected $size;
        /**
         * A valid PHP UPLOAD_ERR_xxx code for the file upload.
         *
         * @var int
         */
        protected $error;
        /**
         * Indicates if the upload is from a SAPI environment.
         *
         * @var bool
         */
        protected $sapi;
        /**
         * An optional StreamInterface wrapping the file resource.
         *
         * @var StreamInterface
         */
        protected $stream;
        /**
         * Indicates if the uploaded file has already been moved.
         *
         * @var bool
         */
        protected $moved;

        public static function createFromEnvironment(Environment $env) {}
        private static function parseUploadedFiles(array $uploadedFiles) {}
        public function __construct($file, $name = null, $type = null, $size = null, $error = UPLOAD_ERR_OK, $sapi = false) {}
        /**
         * Retrieve a stream representing the uploaded file.
         *
         * This method MUST return a StreamInterface instance, representing the
         * uploaded file. The purpose of this method is to allow utilizing native PHP
         * stream functionality to manipulate the file upload, such as
         * stream_copy_to_stream() (though the result will need to be decorated in a
         * native PHP stream wrapper to work with such functions).
         *
         * If the moveTo() method has been called previously, this method MUST raise
         * an exception.
         *
         * @return StreamInterface Stream representation of the uploaded file.
         * @throws \RuntimeException in cases when no stream is available or can be
         *     created.
         */
        public function getStream() {}
        public function moveTo($targetPath) {}
        /**
         * Retrieve the error associated with the uploaded file.
         *
         * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.
         *
         * If the file was uploaded successfully, this method MUST return
         * UPLOAD_ERR_OK.
         *
         * Implementations SHOULD return the value stored in the "error" key of
         * the file in the $_FILES array.
         *
         * @see http://php.net/manual/en/features.file-upload.errors.php
         *
         * @return int One of PHP's UPLOAD_ERR_XXX constants.
         */
        public function getError() {}
        /**
         * Retrieve the filename sent by the client.
         *
         * Do not trust the value returned by this method. A client could send
         * a malicious filename with the intention to corrupt or hack your
         * application.
         *
         * Implementations SHOULD return the value stored in the "name" key of
         * the file in the $_FILES array.
         *
         * @return string|null The filename sent by the client or null if none
         *     was provided.
         */
        public function getClientFilename() {}
        /**
         * Retrieve the media type sent by the client.
         *
         * Do not trust the value returned by this method. A client could send
         * a malicious media type with the intention to corrupt or hack your
         * application.
         *
         * Implementations SHOULD return the value stored in the "type" key of
         * the file in the $_FILES array.
         *
         * @return string|null The media type sent by the client or null if none
         *     was provided.
         */
        public function getClientMediaType() {}
        /**
         * Retrieve the file size.
         *
         * Implementations SHOULD return the value stored in the "size" key of
         * the file in the $_FILES array if available, as PHP calculates this based
         * on the actual size transmitted.
         *
         * @return int|null The file size in bytes or null if unknown.
         */
        public function getSize() {}
    }

    class StatusCode {
        const HTTP_IM_A_TEAPOT = 418;
        const HTTP_EXPECTATION_FAILED = 417;
        const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
        const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;
        const HTTP_REQUEST_URI_TOO_LONG = 414;
        const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;
        const HTTP_PRECONDITION_FAILED = 412;
        const HTTP_LENGTH_REQUIRED = 411;
        const HTTP_GONE = 410;
        const HTTP_CONFLICT = 409;
        const HTTP_REQUEST_TIMEOUT = 408;
        const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;
        const HTTP_NOT_ACCEPTABLE = 406;
        const HTTP_METHOD_NOT_ALLOWED = 405;
        const HTTP_NOT_FOUND = 404;
        const HTTP_FORBIDDEN = 403;
        const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;
        const HTTP_TOO_MANY_REQUESTS = 429;
        const HTTP_PRECONDITION_REQUIRED = 428;
        const HTTP_UPGRADE_REQUIRED = 426;
        const HTTP_FAILED_DEPENDENCY = 424;
        const HTTP_LOCKED = 423;
        const HTTP_UNPROCESSABLE_ENTITY = 422;
        const HTTP_MISDIRECTED_REQUEST = 421;
        const HTTP_GATEWAY_TIMEOUT = 504;
        const HTTP_SERVICE_UNAVAILABLE = 503;
        const HTTP_BAD_GATEWAY = 502;
        const HTTP_NOT_IMPLEMENTED = 501;
        const HTTP_INTERNAL_SERVER_ERROR = 500;
        const HTTP_CLIENT_CLOSED_REQUEST = 499;
        const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS = 451;
        const HTTP_CONNECTION_CLOSED_WITHOUT_RESPONSE = 444;
        const HTTP_NETWORK_CONNECTION_TIMEOUT_ERROR = 599;
        const HTTP_NOT_EXTENDED = 510;
        const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;
        const HTTP_INSUFFICIENT_STORAGE = 507;
        const HTTP_LOOP_DETECTED = 508;
        const HTTP_VERSION_NOT_SUPPORTED = 505;
        const HTTP_VARIANT_ALSO_NEGOTIATES = 506;
        const HTTP_CONTINUE = 100;
        const HTTP_OK = 200;
        const HTTP_CREATED = 201;
        const HTTP_SWITCHING_PROTOCOLS = 101;
        const HTTP_PROCESSING = 102;
        const HTTP_NO_CONTENT = 204;
        const HTTP_RESET_CONTENT = 205;
        const HTTP_ACCEPTED = 202;
        const HTTP_NONAUTHORITATIVE_INFORMATION = 203;
        const HTTP_MULTI_STATUS = 207;
        const HTTP_PARTIAL_CONTENT = 206;
        const HTTP_IM_USED = 226;
        const HTTP_ALREADY_REPORTED = 208;
        const HTTP_MOVED_PERMANENTLY = 301;
        const HTTP_MULTIPLE_CHOICES = 300;
        const HTTP_SEE_OTHER = 303;
        const HTTP_FOUND = 302;
        const HTTP_USE_PROXY = 305;
        const HTTP_NOT_MODIFIED = 304;
        const HTTP_TEMPORARY_REDIRECT = 307;
        const HTTP_UNUSED = 306;
        const HTTP_BAD_REQUEST = 400;
        const HTTP_PERMANENT_REDIRECT = 308;
        const HTTP_PAYMENT_REQUIRED = 402;
        const HTTP_UNAUTHORIZED = 401;

    }

    /**
     * Abstract message (base class for Request and Response)
     *
     * This class represents a general HTTP message. It provides common properties and methods for
     * the HTTP request and response, as defined in the PSR-7 MessageInterface.
     *
     * @link https://github.com/php-fig/http-message/blob/master/src/MessageInterface.php
     * @see Slim\Http\Request
     * @see Slim\Http\Response
     */
    abstract class Message implements \psr\http\message\messageinterface {
        /**
         * Protocol version
         *
         * @var string
         */
        protected $protocolVersion;
        /**
         * A map of valid protocol versions
         *
         * @var array
         */
        static protected $validProtocolVersions;
        /**
         * Headers
         *
         * @var \Slim\Interfaces\Http\HeadersInterface
         */
        protected $headers;
        /**
         * Body object
         *
         * @var \Psr\Http\Message\StreamInterface
         */
        protected $body;

        public function __set($name, $value) {}
        /**
         * Retrieves the HTTP protocol version as a string.
         *
         * The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
         *
         * @return string HTTP protocol version.
         */
        public function getProtocolVersion() {}
        public function withProtocolVersion($version) {}
        /**
         * Retrieves all message header values.
         *
         * The keys represent the header name as it will be sent over the wire, and
         * each value is an array of strings associated with the header.
         *
         *     // Represent the headers as a string
         *     foreach ($message->getHeaders() as $name => $values) {
         *         echo $name . ": " . implode(", ", $values);
         *     }
         *
         *     // Emit headers iteratively:
         *     foreach ($message->getHeaders() as $name => $values) {
         *         foreach ($values as $value) {
         *             header(sprintf('%s: %s', $name, $value), false);
         *         }
         *     }
         *
         * While header names are not case-sensitive, getHeaders() will preserve the
         * exact case in which headers were originally specified.
         *
         * @return array Returns an associative array of the message's headers. Each
         *     key MUST be a header name, and each value MUST be an array of strings
         *     for that header.
         */
        public function getHeaders() {}
        public function hasHeader($name) {}
        public function getHeader($name) {}
        public function getHeaderLine($name) {}
        public function withHeader($name, $value) {}
        public function withAddedHeader($name, $value) {}
        public function withoutHeader($name) {}
        /**
         * Gets the body of the message.
         *
         * @return StreamInterface Returns the body as a stream.
         */
        public function getBody() {}
        public function withBody(StreamInterface $body) {}
    }

    /**
     * Environment
     *
     * This class decouples the Slim application from the global PHP environment.
     * This is particularly useful for unit testing, but it also lets us create
     * custom sub-requests.
     */
    class Environment extends \slim\collection implements \slim\interfaces\http\environmentinterface {
        public static function mock(array $userData = [ ]) {}
    }

}

namespace Slim\Exception {
    /**
     * Not Found Exception
     */
    class ContainerValueNotFoundException extends \runtimeexception implements \interop\container\exception\notfoundexception {}

    /**
     * Container Exception
     */
    class ContainerException extends \invalidargumentexception implements \interop\container\exception\containerexception {}

    class NotFoundException extends \slim\exception\slimexception {}

    class InvalidMethodException extends \invalidargumentexception {
        protected $request;

        public function __construct(ServerRequestInterface $request, $method) {}
        public function getRequest() {}
    }

    class MethodNotAllowedException extends \slim\exception\slimexception {
        /**
         * HTTP methods allowed
         *
         * @var string[]
         */
        protected $allowedMethods;

        public function __construct(ServerRequestInterface $request, ResponseInterface $response, array $allowedMethods) {}
        /**
         * Get allowed methods
         *
         * @return string[]
         */
        public function getAllowedMethods() {}
    }

    /**
     * Stop Exception
     *
     * This Exception is thrown when the Slim application needs to abort
     * processing and return control flow to the outer PHP script.
     */
    class SlimException extends \exception {
        /**
         * A request object
         *
         * @var ServerRequestInterface
         */
        protected $request;
        /**
         * A response object to send to the HTTP client
         *
         * @var ResponseInterface
         */
        protected $response;

        public function __construct(ServerRequestInterface $request, ResponseInterface $response) {}
        /**
         * Get request
         *
         * @return ServerRequestInterface
         */
        public function getRequest() {}
        /**
         * Get response
         *
         * @return ResponseInterface
         */
        public function getResponse() {}
    }

}

namespace Slim\Handlers {
    /**
     * Default Slim application not allowed handler
     *
     * It outputs a simple message in either JSON, XML or HTML based on the
     * Accept header.
     */
    class NotAllowed extends \slim\handlers\abstracthandler {
        public function __invoke(ServerRequestInterface $request, ResponseInterface $response, array $methods) {}
        protected function renderPlainOptionsMessage($methods) {}
        protected function renderJsonNotAllowedMessage($methods) {}
        protected function renderXmlNotAllowedMessage($methods) {}
        protected function renderHtmlNotAllowedMessage($methods) {}
    }

    /**
     * Abstract Slim application handler
     */
    abstract class AbstractHandler {
        /**
         * Known handled content types
         *
         * @var array
         */
        protected $knownContentTypes;

        protected function determineContentType(ServerRequestInterface $request) {}
    }

    /**
     * Default Slim application error handler
     *
     * It outputs the error message and diagnostic information in either JSON, XML,
     * or HTML based on the Accept header.
     */
    class Error extends \slim\handlers\abstracterror {
        public function __invoke(ServerRequestInterface $request, ResponseInterface $response, \Exception $exception) {}
        protected function renderHtmlErrorMessage(\Exception $exception) {}
        protected function renderHtmlException(\Exception $exception) {}
        protected function renderHtmlExceptionOrError($exception) {}
        protected function renderJsonErrorMessage(\Exception $exception) {}
        protected function renderXmlErrorMessage(\Exception $exception) {}
        private function createCdataSection($content) {}
    }

    /**
     * Default Slim application error handler for PHP 7+ Throwables
     *
     * It outputs the error message and diagnostic information in either JSON, XML,
     * or HTML based on the Accept header.
     */
    class PhpError extends \slim\handlers\abstracterror {
        public function __invoke(ServerRequestInterface $request, ResponseInterface $response, \Throwable $error) {}
        protected function renderHtmlErrorMessage(\Throwable $error) {}
        protected function renderHtmlError(\Throwable $error) {}
        protected function renderJsonErrorMessage(\Throwable $error) {}
        protected function renderXmlErrorMessage(\Throwable $error) {}
        private function createCdataSection($content) {}
    }

    /**
     * Abstract Slim application error handler
     */
    abstract class AbstractError extends \slim\handlers\abstracthandler {
        /**
         * @var bool
         */
        protected $displayErrorDetails;

        public function __construct($displayErrorDetails = false) {}
        protected function writeToErrorLog($throwable) {}
        protected function renderThrowableAsText($throwable) {}
        protected function logError($message) {}
    }

    /**
     * Default Slim application not found handler.
     *
     * It outputs a simple message in either JSON, XML or HTML based on the
     * Accept header.
     */
    class NotFound extends \slim\handlers\abstracthandler {
        public function __invoke(ServerRequestInterface $request, ResponseInterface $response) {}
        /**
         * Render plain not found message
         *
         * @return ResponseInterface
         */
        protected function renderPlainNotFoundOutput() {}
        /**
         * Return a response for application/json content not found
         *
         * @return ResponseInterface
         */
        protected function renderJsonNotFoundOutput() {}
        /**
         * Return a response for xml content not found
         *
         * @return ResponseInterface
         */
        protected function renderXmlNotFoundOutput() {}
        protected function renderHtmlNotFoundOutput(ServerRequestInterface $request) {}
    }

}

namespace Slim\Handlers\Strategies {
    /**
     * Default route callback strategy with route parameters as an array of arguments.
     */
    class RequestResponse implements \slim\interfaces\invocationstrategyinterface {
        public function __invoke(callable $callable, ServerRequestInterface $request, ResponseInterface $response, array $routeArguments) {}
    }

    /**
     * Route callback strategy with route parameters as individual arguments.
     */
    class RequestResponseArgs implements \slim\interfaces\invocationstrategyinterface {
        public function __invoke(callable $callable, ServerRequestInterface $request, ResponseInterface $response, array $routeArguments) {}
    }

}

namespace Slim\Interfaces {
    /**
     * Defines a contract for invoking a route callable.
     */
    interface InvocationStrategyInterface {
        function __invoke(callable $callable, ServerRequestInterface $request, ResponseInterface $response, array $routeArguments) ;
    }

    /**
     * RouteGroup Interface
     *
     * @package Slim
     * @since   3.0.0
     */
    interface RouteGroupInterface {
        /**
         * Get route pattern
         *
         * @return string
         */
        function getPattern() ;
        function add($callable) ;
        function __invoke(App $app) ;
    }

    /**
     * Router Interface
     *
     * @package Slim
     * @since   3.0.0
     */
    interface RouterInterface {
    const DISPATCH_STATUS = 0;
    const ALLOWED_METHODS = 1;
        function map($methods, $pattern, $handler) ;
        function dispatch(ServerRequestInterface $request) ;
        function pushGroup($pattern, $callable) ;
        /**
         * Removes the last route group from the array
         *
         * @return bool True if successful, else False
         */
        function popGroup() ;
        function getNamedRoute($name) ;
        function lookupRoute($identifier) ;
        function relativePathFor($name, array $data = [ ], array $queryParams = [ ]) ;
        function pathFor($name, array $data = [ ], array $queryParams = [ ]) ;
    }

    /**
     * Route Interface
     *
     * @package Slim
     * @since   3.0.0
     */
    interface RouteInterface {
        function getArgument($name, $default = null) ;
        /**
         * Get route arguments
         *
         * @return string[]
         */
        function getArguments() ;
        /**
         * Get route name
         *
         * @return null|string
         */
        function getName() ;
        /**
         * Get route pattern
         *
         * @return string
         */
        function getPattern() ;
        function setArgument($name, $value) ;
        function setArguments(array $arguments) ;
        function setOutputBuffering($mode) ;
        function setName($name) ;
        function add($callable) ;
        function prepare(ServerRequestInterface $request, array $arguments) ;
        function run(ServerRequestInterface $request, ResponseInterface $response) ;
        function __invoke(ServerRequestInterface $request, ResponseInterface $response) ;
    }

    /**
     * Resolves a callable.
     *
     * @package Slim
     * @since 3.0.0
     */
    interface CallableResolverInterface {
        function resolve($toResolve) ;
    }

    /**
     * Collection Interface
     *
     * @package Slim
     * @since   3.0.0
     */
    interface CollectionInterface extends \arrayaccess {
        function set($key, $value) ;
        function get($key, $default = null) ;
        function replace(array $items) ;
        function all() ;
        function has($key) ;
        function remove($key) ;
        function clear() ;
    }

}

namespace Slim\Interfaces\Http {
    /**
     * Environment Interface
     *
     * @package Slim
     * @since   3.0.0
     */
    interface EnvironmentInterface {
        static function mock(array $settings = [ ]) ;
    }

    /**
     * Headers Interface
     *
     * @package Slim
     * @since   3.0.0
     */
    interface HeadersInterface extends \slim\interfaces\collectioninterface {
        function add($key, $value) ;
        function normalizeKey($key) ;
    }

    /**
     * Cookies Interface
     *
     * @package Slim
     * @since   3.0.0
     */
    interface CookiesInterface {
        function get($name, $default = null) ;
        function set($name, $value) ;
        function toHeaders() ;
        static function parseHeader($header) ;
    }

}

?>
