<?php
/**
  * Generated by Exakat 2.1.6 (Build 1091)
  * On 2020-08-26T05:53:32+00:00
  * See https://www.exakat.io/
  */

namespace  {
    function twig_html_classes($args) : string {}
    function twig_raw_filter($string) {}
    function twig_escape_filter(Environment $env, $string, $strategy = 'html', $charset = null, $autoescape = false) {}
    function twig_escape_filter_is_safe(Node $filterArgs) {}
    function twig_template_from_string(Environment $env, $template, string $name = null) : TemplateWrapper {}
    function twig_cycle($values, $position) {}
    function twig_random(Environment $env, $values = null, $max = null) {}
    function twig_date_format_filter(Environment $env, $date, $format = null, $timezone = null) {}
    function twig_date_modify_filter(Environment $env, $date, $modifier) {}
    function twig_date_converter(Environment $env, $date = null, $timezone = null) {}
    function twig_replace_filter($str, $from) {}
    function twig_round($value, $precision = 0, $method = 'common') {}
    function twig_number_format_filter(Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null) {}
    function twig_urlencode_filter($url) {}
    function twig_array_merge($arr1, $arr2) {}
    function twig_slice(Environment $env, $item, $start, $length = null, $preserveKeys = false) {}
    function twig_first(Environment $env, $item) {}
    function twig_last(Environment $env, $item) {}
    function twig_join_filter($value, $glue = '', $and = null) {}
    function twig_split_filter(Environment $env, $value, $delimiter, $limit = null) {}
    function _twig_default_filter($value, $default = '') {}
    function twig_get_array_keys_filter($array) {}
    function twig_reverse_filter(Environment $env, $item, $preserveKeys = false) {}
    function twig_sort_filter($array, $arrow = null) {}
    function twig_in_filter($value, $compare) {}
    function twig_compare($a, $b) {}
    function twig_trim_filter($string, $characterMask = null, $side = 'both') {}
    function twig_spaceless($content) {}
    function twig_convert_encoding($string, $to, $from) {}
    function twig_length_filter(Environment $env, $thing) {}
    function twig_upper_filter(Environment $env, $string) {}
    function twig_lower_filter(Environment $env, $string) {}
    function twig_title_string_filter(Environment $env, $string) {}
    function twig_capitalize_string_filter(Environment $env, $string) {}
    function twig_call_macro(Template $template, string $method, array $args, int $lineno, array $context, Source $source) {}
    function twig_ensure_traversable($seq) {}
    function twig_to_array($seq, $preserveKeys = true) {}
    function twig_test_empty($value) {}
    function twig_test_iterable($value) {}
    function twig_include(Environment $env, $context, $template, $variables = [ ], $withContext = true, $ignoreMissing = false, $sandboxed = false) {}
    function twig_source(Environment $env, $name, $ignoreMissing = false) {}
    function twig_constant($constant, $object = null) {}
    function twig_constant_is_defined($constant, $object = null) {}
    function twig_array_batch($items, $size, $fill = null, $preserveKeys = true) {}
    function twig_get_attribute(Environment $env, Source $source, $object, $item, array $arguments = [ ], $type = 'any', $isDefinedTest = false, $ignoreStrictCheck = false, $sandboxed = false, int $lineno = -1) {}
    function twig_array_column($array, $name, $index = null) : array {}
    function twig_array_filter(Environment $env, $array, $arrow) {}
    function twig_array_map(Environment $env, $array, $arrow) {}
    function twig_array_reduce(Environment $env, $array, $arrow, $initial = null) {}
    function twig_var_dump(Environment $env, $context, $vars) {}
}

namespace Twig\Extra\TwigExtraBundle {
    class TwigExtraBundle extends \symfony\component\httpkernel\bundle\bundle {
        public function build(ContainerBuilder $container) {}
    }

    final class MissingExtensionSuggestor {
        public function suggestFilter(string $name) : bool {}
        public function suggestFunction(string $name) : bool {}
    }

    final class Extensions {
        private const EXTENSIONS = ['html' => ['name' => 'html', 'class' => HtmlExtension::class, 'class_name' => 'HtmlExtension', 'package' => 'twig/html-extra', 'filters' => ['data_uri'], 'functions' => ['html_classes'],  ], 'markdown' => ['name' => 'markdown', 'class' => MarkdownExtension::class, 'class_name' => 'MarkdownExtension', 'package' => 'twig/markdown-extra', 'filters' => ['html_to_markdown', 'markdown_to_html'], 'functions' => [ ],  ], 'intl' => ['name' => 'intl', 'class' => IntlExtension::class, 'class_name' => 'IntlExtension', 'package' => 'twig/intl-extra', 'filters' => ['country_name', 'currency_name', 'currency_symbol', 'language_name', 'locale_name', 'timezone_name', 'format_currency', 'format_number', 'format_decimal_number', 'format_currency_number', 'format_percent_number', 'format_scientific_number', 'format_spellout_number', 'format_ordinal_number', 'format_duration_number', 'format_date', 'format_datetime', 'format_time',  ], 'functions' => ['country_timezones'],  ], 'cssinliner' => ['name' => 'cssinliner', 'class' => CssInlinerExtension::class, 'class_name' => 'CssInlinerExtension', 'package' => 'twig/cssinliner-extra', 'filters' => ['inline_css'], 'functions' => [ ],  ], 'inky' => ['name' => 'inky', 'class' => InkyExtension::class, 'class_name' => 'InkyExtension', 'package' => 'twig/inky-extra', 'filters' => ['inky_to_html'], 'functions' => [ ],  ], 'string' => ['name' => 'string', 'class' => StringExtension::class, 'class_name' => 'StringExtension', 'package' => 'twig/string-extra', 'filters' => ['u'], 'functions' => [ ],  ],  ];

        public static function getClasses() : array {}
        public static function getFilter(string $name) : array {}
        public static function getFunction(string $name) : array {}
    }

}

namespace Twig\Extra\TwigExtraBundle\DependencyInjection {
    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class TwigExtraExtension extends \symfony\component\httpkernel\dependencyinjection\extension {
        public function load(array $configs, ContainerBuilder $container) {}
    }

    class Configuration implements \symfony\component\config\definition\configurationinterface {
        public function getConfigTreeBuilder() {}
    }

}

namespace Twig\Extra\TwigExtraBundle\DependencyInjection\Compiler {
    class MissingExtensionSuggestorPass implements \symfony\component\dependencyinjection\compiler\compilerpassinterface {
        public function process(ContainerBuilder $container) {}
    }

}

namespace Twig\Extra\Markdown\Tests {
    class FunctionalTest extends \phpunit\framework\testcase {
        public function testMarkdown(string $template, string $expected) : void {}
        public function getMarkdownTests() {}
    }

    class IntegrationTest extends \twig\test\integrationtestcase {
        public function getExtensions() {}
        public function getFixturesDir() {}
    }

}

namespace Twig\Extra\Markdown {
    function twig_html_to_markdown(string $body, array $options = [ ]) : string {}

    class DefaultMarkdown implements \twig\extra\markdown\markdowninterface {
        private $converter;

        public function __construct() {}
        public function convert(string $body) : string {}
    }

    class LeagueMarkdown implements \twig\extra\markdown\markdowninterface {
        private $converter;

        public function __construct(CommonMarkConverter $converter = null) {}
        public function convert(string $body) : string {}
    }

    class MarkdownRuntime {
        private $converter;

        public function __construct(MarkdownInterface $converter) {}
        public function convert(string $body) : string {}
    }

    final class MarkdownExtension extends \twig\extension\abstractextension {
        public function getFilters() {}
    }

    class MichelfMarkdown implements \twig\extra\markdown\markdowninterface {
        private $converter;

        public function __construct(MarkdownExtra $converter = null) {}
        public function convert(string $body) : string {}
    }

    class ErusevMarkdown implements \twig\extra\markdown\markdowninterface {
        private $converter;

        public function __construct(Parsedown $converter = null) {}
        public function convert(string $body) : string {}
    }


    interface MarkdownInterface {
        function convert(string $body) : string ;
    }

}

namespace Twig\Extra\String\Tests {
    class IntegrationTest extends \twig\test\integrationtestcase {
        public function getExtensions() {}
        public function getFixturesDir() {}
    }

}

namespace Twig\Extra\String {
    final class StringExtension extends \twig\extension\abstractextension {
        public function getFilters() {}
        public function createUnicodeString(?string $text) : UnicodeString {}
    }

}

namespace Twig\Extra\Intl\Tests {
    class IntlExtensionTest extends \phpunit\framework\testcase {
        public function testFormatterProto() {}
    }

    class IntegrationTest extends \twig\test\integrationtestcase {
        public function getExtensions() {}
        public function getFixturesDir() {}
    }

}

namespace Twig\Extra\Intl {
    final class IntlExtension extends \twig\extension\abstractextension {
        private const NUMBER_STYLES = ['decimal' => \NumberFormatter::DECIMAL, 'currency' => \NumberFormatter::CURRENCY, 'percent' => \NumberFormatter::PERCENT, 'scientific' => \NumberFormatter::SCIENTIFIC, 'spellout' => \NumberFormatter::SPELLOUT, 'ordinal' => \NumberFormatter::ORDINAL, 'duration' => \NumberFormatter::DURATION,  ];
        private const NUMBER_TYPES = ['default' => \NumberFormatter::TYPE_DEFAULT, 'int32' => \NumberFormatter::TYPE_INT32, 'int64' => \NumberFormatter::TYPE_INT64, 'double' => \NumberFormatter::TYPE_DOUBLE, 'currency' => \NumberFormatter::TYPE_CURRENCY,  ];
        private const DATE_FORMATS = ['none' => \IntlDateFormatter::NONE, 'short' => \IntlDateFormatter::SHORT, 'medium' => \IntlDateFormatter::MEDIUM, 'long' => \IntlDateFormatter::LONG, 'full' => \IntlDateFormatter::FULL,  ];
        private const NUMBER_ROUNDING_ATTRIBUTES = ['ceiling' => \NumberFormatter::ROUND_CEILING, 'floor' => \NumberFormatter::ROUND_FLOOR, 'down' => \NumberFormatter::ROUND_DOWN, 'up' => \NumberFormatter::ROUND_UP, 'halfeven' => \NumberFormatter::ROUND_HALFEVEN, 'halfdown' => \NumberFormatter::ROUND_HALFDOWN, 'halfup' => \NumberFormatter::ROUND_HALFUP,  ];
        private const NUMBER_ATTRIBUTES = ['grouping_used' => \NumberFormatter::GROUPING_USED, 'decimal_always_shown' => \NumberFormatter::DECIMAL_ALWAYS_SHOWN, 'max_integer_digit' => \NumberFormatter::MAX_INTEGER_DIGITS, 'min_integer_digit' => \NumberFormatter::MIN_INTEGER_DIGITS, 'integer_digit' => \NumberFormatter::INTEGER_DIGITS, 'max_fraction_digit' => \NumberFormatter::MAX_FRACTION_DIGITS, 'min_fraction_digit' => \NumberFormatter::MIN_FRACTION_DIGITS, 'fraction_digit' => \NumberFormatter::FRACTION_DIGITS, 'multiplier' => \NumberFormatter::MULTIPLIER, 'grouping_size' => \NumberFormatter::GROUPING_SIZE, 'rounding_mode' => \NumberFormatter::ROUNDING_MODE, 'rounding_increment' => \NumberFormatter::ROUNDING_INCREMENT, 'format_width' => \NumberFormatter::FORMAT_WIDTH, 'padding_position' => \NumberFormatter::PADDING_POSITION, 'secondary_grouping_size' => \NumberFormatter::SECONDARY_GROUPING_SIZE, 'significant_digits_used' => \NumberFormatter::SIGNIFICANT_DIGITS_USED, 'min_significant_digits_used' => \NumberFormatter::MIN_SIGNIFICANT_DIGITS, 'max_significant_digits_used' => \NumberFormatter::MAX_SIGNIFICANT_DIGITS, 'lenient_parse' => \NumberFormatter::LENIENT_PARSE,  ];
        private const NUMBER_TEXT_ATTRIBUTES = ['positive_prefix' => \NumberFormatter::POSITIVE_PREFIX, 'positive_suffix' => \NumberFormatter::POSITIVE_SUFFIX, 'negative_prefix' => \NumberFormatter::NEGATIVE_PREFIX, 'negative_suffix' => \NumberFormatter::NEGATIVE_SUFFIX, 'padding_character' => \NumberFormatter::PADDING_CHARACTER, 'currency_mode' => \NumberFormatter::CURRENCY_CODE, 'default_ruleset' => \NumberFormatter::DEFAULT_RULESET, 'public_rulesets' => \NumberFormatter::PUBLIC_RULESETS,  ];
        private const NUMBER_PADDING_ATTRIBUTES = ['before_prefix' => \NumberFormatter::PAD_BEFORE_PREFIX, 'after_prefix' => \NumberFormatter::PAD_AFTER_PREFIX, 'before_suffix' => \NumberFormatter::PAD_BEFORE_SUFFIX, 'after_suffix' => \NumberFormatter::PAD_AFTER_SUFFIX,  ];
        private const NUMBER_SYMBOLS = ['decimal_separator' => \NumberFormatter::DECIMAL_SEPARATOR_SYMBOL, 'grouping_separator' => \NumberFormatter::GROUPING_SEPARATOR_SYMBOL, 'pattern_separator' => \NumberFormatter::PATTERN_SEPARATOR_SYMBOL, 'percent' => \NumberFormatter::PERCENT_SYMBOL, 'zero_digit' => \NumberFormatter::ZERO_DIGIT_SYMBOL, 'digit' => \NumberFormatter::DIGIT_SYMBOL, 'minus_sign' => \NumberFormatter::MINUS_SIGN_SYMBOL, 'plus_sign' => \NumberFormatter::PLUS_SIGN_SYMBOL, 'currency' => \NumberFormatter::CURRENCY_SYMBOL, 'intl_currency' => \NumberFormatter::INTL_CURRENCY_SYMBOL, 'monetary_separator' => \NumberFormatter::MONETARY_SEPARATOR_SYMBOL, 'exponential' => \NumberFormatter::EXPONENTIAL_SYMBOL, 'permill' => \NumberFormatter::PERMILL_SYMBOL, 'pad_escape' => \NumberFormatter::PAD_ESCAPE_SYMBOL, 'infinity' => \NumberFormatter::INFINITY_SYMBOL, 'nan' => \NumberFormatter::NAN_SYMBOL, 'significant_digit' => \NumberFormatter::SIGNIFICANT_DIGIT_SYMBOL, 'monetary_grouping_separator' => \NumberFormatter::MONETARY_GROUPING_SEPARATOR_SYMBOL,  ];

        private $dateFormatters;
        private $numberFormatters;
        private $dateFormatterPrototype;
        private $numberFormatterPrototype;

        public function __construct(\IntlDateFormatter $dateFormatterPrototype = null, \NumberFormatter $numberFormatterPrototype = null) {}
        public function getFilters() {}
        public function getFunctions() {}
        public function getCountryName(?string $country, string $locale = null) : string {}
        public function getCurrencyName(?string $currency, string $locale = null) : string {}
        public function getCurrencySymbol(?string $currency, string $locale = null) : string {}
        public function getLanguageName(?string $language, string $locale = null) : string {}
        public function getLocaleName(?string $data, string $locale = null) : string {}
        public function getTimezoneName(?string $timezone, string $locale = null) : string {}
        public function getCountryTimezones(string $country) : array {}
        public function formatCurrency($amount, string $currency, array $attrs = [ ], string $locale = null) : string {}
        public function formatNumber($number, array $attrs = [ ], string $style = 'decimal', string $type = 'default', string $locale = null) : string {}
        public function formatNumberStyle(string $style, $number, array $attrs = [ ], string $type = 'default', string $locale = null) : string {}
        public function formatDateTime(Environment $env, $date, ?string $dateFormat = 'medium', ?string $timeFormat = 'medium', string $pattern = '', $timezone = null, string $calendar = 'gregorian', string $locale = null) : string {}
        public function formatDate(Environment $env, $date, ?string $dateFormat = 'medium', string $pattern = '', $timezone = null, string $calendar = 'gregorian', string $locale = null) : string {}
        public function formatTime(Environment $env, $date, ?string $timeFormat = 'medium', string $pattern = '', $timezone = null, string $calendar = 'gregorian', string $locale = null) : string {}
        private function createDateFormatter(?string $locale, ?string $dateFormat, ?string $timeFormat, string $pattern, \DateTimeZone $timezone, string $calendar) : \IntlDateFormatter {}
        private function createNumberFormatter(?string $locale, string $style, array $attrs = [ ]) : \NumberFormatter {}
    }

}

namespace Twig\Extra\Html\Tests {
    class IntegrationTest extends \twig\test\integrationtestcase {
        public function getExtensions() {}
        public function getFixturesDir() {}
    }

}

namespace Twig\Extra\Html {
    final class HtmlExtension extends \twig\extension\abstractextension {
        private $mimeTypes;

        public function __construct(MimeTypes $mimeTypes = null) {}
        public function getFilters() : array {}
        public function getFunctions() : array {}
        public function dataUri(string $data, string $mime = null, array $parameters = [ ]) : string {}
    }

}

namespace Twig\Extra\Inky\Tests {
    class IntegrationTest extends \twig\test\integrationtestcase {
        public function getExtensions() {}
        public function getFixturesDir() {}
    }

}

namespace Twig\Extra\Inky {
    function twig_inky(string $body) : string {}

    class InkyExtension extends \twig\extension\abstractextension {
        public function getFilters() {}
    }

}

namespace Twig\Extra\CssInliner\Tests {
    class IntegrationTest extends \twig\test\integrationtestcase {
        public function getExtensions() {}
        public function getFixturesDir() {}
    }

}

namespace Twig\Extra\CssInliner {
    function twig_inline_css(string $body, string $css) : string {}

    class CssInlinerExtension extends \twig\extension\abstractextension {
        public function getFilters() {}
    }

}

namespace Twig {
    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class Token {
        const NAME_TYPE = 5;
        const NUMBER_TYPE = 6;
        const STRING_TYPE = 7;
        const OPERATOR_TYPE = 8;
        const BLOCK_START_TYPE = 1;
        const VAR_START_TYPE = 2;
        const BLOCK_END_TYPE = 3;
        const VAR_END_TYPE = 4;
        const EOF_TYPE = -1;
        const TEXT_TYPE = 0;
        const INTERPOLATION_START_TYPE = 10;
        const PUNCTUATION_TYPE = 9;
        const ARROW_TYPE = 12;
        const INTERPOLATION_END_TYPE = 11;

        private $value;
        private $type;
        private $lineno;

        public function __construct(int $type, $value, int $lineno) {}
        public function __toString() {}
        public function test($type, $values = null) : bool {}
        public function getLine() : int {}
        public function getType() : int {}
        public function getValue() {}
        public static function typeToString(int $type, bool $short = false) : string {}
        public static function typeToEnglish(int $type) : string {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Parser {
        private $stack;
        private $stream;
        private $parent;
        private $handlers;
        private $visitors;
        private $expressionParser;
        private $blocks;
        private $blockStack;
        private $macros;
        private $env;
        private $importedSymbols;
        private $traits;
        private $embeddedTemplates;
        private $varNameSalt;

        public function __construct(Environment $env) {}
        public function getVarName() : string {}
        public function parse(TokenStream $stream, $test = null, bool $dropNeedle = false) : ModuleNode {}
        public function subparse($test, bool $dropNeedle = false) : Node {}
        public function getBlockStack() : array {}
        public function peekBlockStack() {}
        public function popBlockStack() : void {}
        public function pushBlockStack($name) : void {}
        public function hasBlock(string $name) : bool {}
        public function getBlock(string $name) : Node {}
        public function setBlock(string $name, BlockNode $value) : void {}
        public function hasMacro(string $name) : bool {}
        public function setMacro(string $name, MacroNode $node) : void {}
        public function addTrait($trait) : void {}
        public function hasTraits() : bool {}
        public function embedTemplate(ModuleNode $template) {}
        public function addImportedSymbol(string $type, string $alias, string $name = null, AbstractExpression $node = null) : void {}
        public function getImportedSymbol(string $type, string $alias) {}
        public function isMainScope() : bool {}
        public function pushLocalScope() : void {}
        public function popLocalScope() : void {}
        public function getExpressionParser() : ExpressionParser {}
        public function getParent() : ?Node {}
        public function setParent(?Node $parent) : void {}
        public function getStream() : TokenStream {}
        public function getCurrentToken() : Token {}
        private function filterBodyNodes(Node $node, bool $nested = false) : ?Node {}
    }

    /**
     * Parses expressions.
     *
     * This parser implements a "Precedence climbing" algorithm.
     *
     * @see https://www.engr.mun.ca/~theo/Misc/exp_parsing.htm
     * @see https://en.wikipedia.org/wiki/Operator-precedence_parser
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @internal
     */
    class ExpressionParser {
        const OPERATOR_RIGHT = 2;
        const OPERATOR_LEFT = 1;

        private $parser;
        private $env;
        private $unaryOperators;
        private $binaryOperators;

        public function __construct(Parser $parser, Environment $env) {}
        public function parseExpression($precedence = 0, $allowArrow = false) {}
        /**
         * @return ArrowFunctionExpression|null
         */
        private function parseArrow() {}
        private function getPrimary() : AbstractExpression {}
        private function parseConditionalExpression($expr) : AbstractExpression {}
        private function isUnary(Token $token) : bool {}
        private function isBinary(Token $token) : bool {}
        public function parsePrimaryExpression() {}
        public function parseStringExpression() {}
        public function parseArrayExpression() {}
        public function parseHashExpression() {}
        public function parsePostfixExpression($node) {}
        public function getFunctionNode($name, $line) {}
        public function parseSubscriptExpression($node) {}
        public function parseFilterExpression($node) {}
        public function parseFilterExpressionRaw($node, $tag = null) {}
        public function parseArguments($namedArguments = false, $definition = false, $allowArrow = false) {}
        public function parseAssignmentExpression() {}
        public function parseMultitargetExpression() {}
        private function parseNotTestExpression(Node $node) : NotUnary {}
        private function parseTestExpression(Node $node) : TestExpression {}
        private function getTest(int $line) : array {}
        private function getTestNodeClass(TwigTest $test) : string {}
        private function getFunctionNodeClass(string $name, int $line) : string {}
        private function getFilterNodeClass(string $name, int $line) : string {}
        private function checkConstantExpression(Node $node) : bool {}
    }

    /**
     * Marks a content as safe.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Markup implements \countable, \jsonserializable {
        private $content;
        private $charset;

        public function __construct($content, $charset) {}
        public function __toString() {}
        public function count() {}
        public function jsonSerialize() {}
    }

    /**
     * Exposes a template to userland.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class TemplateWrapper {
        private $env;
        private $template;

        public function __construct(Environment $env, Template $template) {}
        public function render(array $context = [ ]) : string {}
        public function display(array $context = [ ]) {}
        public function hasBlock(string $name, array $context = [ ]) : bool {}
        public function getBlockNames(array $context = [ ]) : array {}
        public function renderBlock(string $name, array $context = [ ]) : string {}
        public function displayBlock(string $name, array $context = [ ]) {}
        public function getSourceContext() : Source {}
        public function getTemplateName() : string {}
        /**
         * @internal
         *
         * @return Template
         */
        public function unwrap() {}
    }

    /**
     * Represents a template test.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @see https://twig.symfony.com/doc/templates.html#test-operator
     */
    final class TwigTest {
        private $name;
        private $callable;
        private $options;
        private $arguments;

        public function __construct(string $name, $callable = null, array $options = [ ]) {}
        public function getName() : string {}
        /**
         * Returns the callable to execute for this test.
         *
         * @return callable|null
         */
        public function getCallable() {}
        public function getNodeClass() : string {}
        public function setArguments(array $arguments) : void {}
        public function getArguments() : array {}
        public function isVariadic() : bool {}
        public function isDeprecated() : bool {}
        public function getDeprecatedVersion() : string {}
        public function getAlternative() : ?string {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Lexer {
        const STATE_VAR = 2;
        const STATE_BLOCK = 1;
        const STATE_DATA = 0;
        const REGEX_DQ_STRING_PART = '/[^#"\\\\]*(?:(?:\\\\.|#(?!\{))[^#"\\\\]*)*/As';
        const PUNCTUATION = '()[]{}?:.,|';
        const REGEX_STRING = '/"([^#"\\\\]*(?:\\\\.[^#"\\\\]*)*)"|\'([^\'\\\\]*(?:\\\\.[^\'\\\\]*)*)\'/As';
        const REGEX_DQ_STRING_DELIM = '/"/A';
        const REGEX_NAME = '/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/A';
        const REGEX_NUMBER = '/[0-9]+(?:\.[0-9]+)?([Ee][\+\-][0-9]+)?/A';
        const STATE_STRING = 3;
        const STATE_INTERPOLATION = 4;

        private $tokens;
        private $code;
        private $cursor;
        private $lineno;
        private $end;
        private $state;
        private $states;
        private $brackets;
        private $env;
        private $source;
        private $options;
        private $regexes;
        private $position;
        private $positions;
        private $currentVarBlockLine;

        public function __construct(Environment $env, array $options = [ ]) {}
        public function tokenize(Source $source) : TokenStream {}
        private function lexData() : void {}
        private function lexBlock() : void {}
        private function lexVar() : void {}
        private function lexExpression() : void {}
        private function lexRawData() : void {}
        private function lexComment() : void {}
        private function lexString() : void {}
        private function lexInterpolation() : void {}
        private function pushToken($type, $value = '') : void {}
        private function moveCursor($text) : void {}
        private function getOperatorRegex() : string {}
        private function pushState($state) : void {}
        private function popState() : void {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @internal
     */
    final class ExtensionSet {
        private $extensions;
        private $initialized;
        private $runtimeInitialized;
        private $staging;
        private $parsers;
        private $visitors;
        private $filters;
        private $tests;
        private $functions;
        private $unaryOperators;
        private $binaryOperators;
        private $globals;
        private $functionCallbacks;
        private $filterCallbacks;
        private $lastModified;

        public function __construct() {}
        public function initRuntime() {}
        public function hasExtension(string $class) : bool {}
        public function getExtension(string $class) : ExtensionInterface {}
        public function setExtensions(array $extensions) : void {}
        /**
         * @return ExtensionInterface[]
         */
        public function getExtensions() : array {}
        public function getSignature() : string {}
        public function isInitialized() : bool {}
        public function getLastModified() : int {}
        public function addExtension(ExtensionInterface $extension) : void {}
        public function addFunction(TwigFunction $function) : void {}
        /**
         * @return TwigFunction[]
         */
        public function getFunctions() : array {}
        public function getFunction(string $name) : ?TwigFunction {}
        public function registerUndefinedFunctionCallback(callable $callable) : void {}
        public function addFilter(TwigFilter $filter) : void {}
        /**
         * @return TwigFilter[]
         */
        public function getFilters() : array {}
        public function getFilter(string $name) : ?TwigFilter {}
        public function registerUndefinedFilterCallback(callable $callable) : void {}
        public function addNodeVisitor(NodeVisitorInterface $visitor) : void {}
        /**
         * @return NodeVisitorInterface[]
         */
        public function getNodeVisitors() : array {}
        public function addTokenParser(TokenParserInterface $parser) : void {}
        /**
         * @return TokenParserInterface[]
         */
        public function getTokenParsers() : array {}
        public function getGlobals() : array {}
        public function addTest(TwigTest $test) : void {}
        /**
         * @return TwigTest[]
         */
        public function getTests() : array {}
        public function getTest(string $name) : ?TwigTest {}
        public function getUnaryOperators() : array {}
        public function getBinaryOperators() : array {}
        private function initExtensions() : void {}
        private function initExtension(ExtensionInterface $extension) : void {}
    }

    /**
     * Default autoescaping strategy based on file names.
     *
     * This strategy sets the HTML as the default autoescaping strategy,
     * but changes it based on the template name.
     *
     * Note that there is no runtime performance impact as the
     * default autoescaping strategy is set at compilation time.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class FileExtensionEscapingStrategy {
        public static function guess(string $name) {}
    }

    /**
     * Holds information about a non-compiled Twig template.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class Source {
        private $code;
        private $name;
        private $path;

        public function __construct(string $code, string $name, string $path = '') {}
        public function getCode() : string {}
        public function getName() : string {}
        public function getPath() : string {}
    }

    /**
     * Default base class for compiled templates.
     *
     * This class is an implementation detail of how template compilation currently
     * works, which might change. It should never be used directly. Use $twig->load()
     * instead, which returns an instance of \Twig\TemplateWrapper.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @internal
     */
    abstract class Template {
        const ANY_CALL = 'any';
        const METHOD_CALL = 'method';
        const ARRAY_CALL = 'array';

        protected $parent;
        protected $parents;
        protected $env;
        protected $blocks;
        protected $traits;
        protected $extensions;
        protected $sandbox;

        public function __construct(Environment $env) {}
        /**
         * Returns the template name.
         *
         * @return string The template name
         */
        abstract public function getTemplateName() ;
        /**
         * Returns debug information about the template.
         *
         * @return array Debug information
         */
        abstract public function getDebugInfo() ;
        /**
         * Returns information about the original template source code.
         *
         * @return Source
         */
        abstract public function getSourceContext() ;
        public function getParent(array $context) {}
        protected function doGetParent(array $context) {}
        public function isTraitable() {}
        public function displayParentBlock($name, array $context, array $blocks = [ ]) {}
        public function displayBlock($name, array $context, array $blocks = [ ], $useBlocks = true, self $templateContext = null) {}
        public function renderParentBlock($name, array $context, array $blocks = [ ]) {}
        public function renderBlock($name, array $context, array $blocks = [ ], $useBlocks = true) {}
        public function hasBlock($name, array $context, array $blocks = [ ]) {}
        public function getBlockNames(array $context, array $blocks = [ ]) {}
        protected function loadTemplate($template, $templateName = null, $line = null, $index = null) {}
        /**
         * @internal
         *
         * @return Template
         */
        protected function unwrap() {}
        /**
         * Returns all blocks.
         *
         * This method is for internal use only and should never be called
         * directly.
         *
         * @return array An array of blocks
         */
        public function getBlocks() {}
        public function display(array $context, array $blocks = [ ]) {}
        public function render(array $context) {}
        protected function displayWithErrorHandling(array $context, array $blocks = [ ]) {}
        abstract protected function doDisplay(array $context, array $blocks = [ ]) ;
    }

    /**
     * Represents a template function.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @see https://twig.symfony.com/doc/templates.html#functions
     */
    final class TwigFunction {
        private $name;
        private $callable;
        private $options;
        private $arguments;

        public function __construct(string $name, $callable = null, array $options = [ ]) {}
        public function getName() : string {}
        /**
         * Returns the callable to execute for this function.
         *
         * @return callable|null
         */
        public function getCallable() {}
        public function getNodeClass() : string {}
        public function setArguments(array $arguments) : void {}
        public function getArguments() : array {}
        public function needsEnvironment() : bool {}
        public function needsContext() : bool {}
        public function getSafe(Node $functionArgs) : ?array {}
        public function isVariadic() : bool {}
        public function isDeprecated() : bool {}
        public function getDeprecatedVersion() : string {}
        public function getAlternative() : ?string {}
    }

    /**
     * A node traverser.
     *
     * It visits all nodes and their children and calls the given visitor for each.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class NodeTraverser {
        private $env;
        private $visitors;

        public function __construct(Environment $env, array $visitors = [ ]) {}
        public function addVisitor(NodeVisitorInterface $visitor) : void {}
        public function traverse(Node $node) : Node {}
        private function traverseForVisitor(NodeVisitorInterface $visitor, Node $node) : ?Node {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Compiler {
        private $lastLine;
        private $source;
        private $indentation;
        private $env;
        private $debugInfo;
        private $sourceOffset;
        private $sourceLine;
        private $varNameSalt;

        public function __construct(Environment $env) {}
        public function getEnvironment() : Environment {}
        public function getSource() : string {}
        public function compile(Node $node, int $indentation = 0) {}
        public function subcompile(Node $node, bool $raw = true) {}
        public function raw(string $string) {}
        public function write($strings) {}
        public function string(string $value) {}
        public function repr($value) {}
        public function addDebugInfo(Node $node) {}
        public function getDebugInfo() : array {}
        public function indent(int $step = 1) {}
        public function outdent(int $step = 1) {}
        public function getVarName() : string {}
    }

    /**
     * Stores the Twig configuration and renders templates.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Environment {
        const RELEASE_VERSION = 5;
        const EXTRA_VERSION = '';
        const VERSION = '3.0.5';
        const VERSION_ID = 30005;
        const MAJOR_VERSION = 3;
        const MINOR_VERSION = 0;

        private $charset;
        private $loader;
        private $debug;
        private $autoReload;
        private $cache;
        private $lexer;
        private $parser;
        private $compiler;
        private $globals;
        private $resolvedGlobals;
        private $loadedTemplates;
        private $strictVariables;
        private $templateClassPrefix;
        private $originalCache;
        private $extensionSet;
        private $runtimeLoaders;
        private $runtimes;
        private $optionsHash;

        public function __construct(LoaderInterface $loader, $options = [ ]) {}
        /**
         * Enables debugging mode.
         */
        public function enableDebug() {}
        /**
         * Disables debugging mode.
         */
        public function disableDebug() {}
        /**
         * Checks if debug mode is enabled.
         *
         * @return bool true if debug mode is enabled, false otherwise
         */
        public function isDebug() {}
        /**
         * Enables the auto_reload option.
         */
        public function enableAutoReload() {}
        /**
         * Disables the auto_reload option.
         */
        public function disableAutoReload() {}
        /**
         * Checks if the auto_reload option is enabled.
         *
         * @return bool true if auto_reload is enabled, false otherwise
         */
        public function isAutoReload() {}
        /**
         * Enables the strict_variables option.
         */
        public function enableStrictVariables() {}
        /**
         * Disables the strict_variables option.
         */
        public function disableStrictVariables() {}
        /**
         * Checks if the strict_variables option is enabled.
         *
         * @return bool true if strict_variables is enabled, false otherwise
         */
        public function isStrictVariables() {}
        public function getCache($original = true) {}
        public function setCache($cache) {}
        public function getTemplateClass(string $name, int $index = null) : string {}
        public function render($name, array $context = [ ]) : string {}
        public function display($name, array $context = [ ]) : void {}
        public function load($name) : TemplateWrapper {}
        public function loadTemplate(string $cls, string $name, int $index = null) : Template {}
        public function createTemplate(string $template, string $name = null) : TemplateWrapper {}
        public function isTemplateFresh(string $name, int $time) : bool {}
        public function resolveTemplate($names) : TemplateWrapper {}
        public function setLexer(Lexer $lexer) {}
        public function tokenize(Source $source) : TokenStream {}
        public function setParser(Parser $parser) {}
        public function parse(TokenStream $stream) : ModuleNode {}
        public function setCompiler(Compiler $compiler) {}
        public function compile(Node $node) : string {}
        public function compileSource(Source $source) : string {}
        public function setLoader(LoaderInterface $loader) {}
        public function getLoader() : LoaderInterface {}
        public function setCharset(string $charset) {}
        public function getCharset() : string {}
        public function hasExtension(string $class) : bool {}
        public function addRuntimeLoader(RuntimeLoaderInterface $loader) {}
        public function getExtension(string $class) : ExtensionInterface {}
        public function getRuntime(string $class) {}
        public function addExtension(ExtensionInterface $extension) {}
        public function setExtensions(array $extensions) {}
        /**
         * @return ExtensionInterface[] An array of extensions (keys are for internal usage only and should not be relied on)
         */
        public function getExtensions() : array {}
        public function addTokenParser(TokenParserInterface $parser) {}
        /**
         * @return TokenParserInterface[]
         *
         * @internal
         */
        public function getTokenParsers() : array {}
        /**
         * @return TokenParserInterface[]
         *
         * @internal
         */
        public function getTags() : array {}
        public function addNodeVisitor(NodeVisitorInterface $visitor) {}
        /**
         * @return NodeVisitorInterface[]
         *
         * @internal
         */
        public function getNodeVisitors() : array {}
        public function addFilter(TwigFilter $filter) {}
        public function getFilter(string $name) : ?TwigFilter {}
        public function registerUndefinedFilterCallback(callable $callable) {}
        /**
         * Gets the registered Filters.
         *
         * Be warned that this method cannot return filters defined with registerUndefinedFilterCallback.
         *
         * @return TwigFilter[]
         *
         * @see registerUndefinedFilterCallback
         *
         * @internal
         */
        public function getFilters() : array {}
        public function addTest(TwigTest $test) {}
        /**
         * @return TwigTest[]
         *
         * @internal
         */
        public function getTests() : array {}
        public function getTest(string $name) : ?TwigTest {}
        public function addFunction(TwigFunction $function) {}
        public function getFunction(string $name) : ?TwigFunction {}
        public function registerUndefinedFunctionCallback(callable $callable) {}
        /**
         * Gets registered functions.
         *
         * Be warned that this method cannot return functions defined with registerUndefinedFunctionCallback.
         *
         * @return TwigFunction[]
         *
         * @see registerUndefinedFunctionCallback
         *
         * @internal
         */
        public function getFunctions() : array {}
        public function addGlobal(string $name, $value) {}
        /**
         * @internal
         */
        public function getGlobals() : array {}
        public function mergeGlobals(array $context) : array {}
        /**
         * @internal
         */
        public function getUnaryOperators() : array {}
        /**
         * @internal
         */
        public function getBinaryOperators() : array {}
        private function updateOptionsHash() : void {}
    }

    /**
     * Represents a template filter.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @see https://twig.symfony.com/doc/templates.html#filters
     */
    final class TwigFilter {
        private $name;
        private $callable;
        private $options;
        private $arguments;

        public function __construct(string $name, $callable = null, array $options = [ ]) {}
        public function getName() : string {}
        /**
         * Returns the callable to execute for this filter.
         *
         * @return callable|null
         */
        public function getCallable() {}
        public function getNodeClass() : string {}
        public function setArguments(array $arguments) : void {}
        public function getArguments() : array {}
        public function needsEnvironment() : bool {}
        public function needsContext() : bool {}
        public function getSafe(Node $filterArgs) : ?array {}
        public function getPreservesSafety() : ?array {}
        public function getPreEscape() : ?string {}
        public function isVariadic() : bool {}
        public function isDeprecated() : bool {}
        public function getDeprecatedVersion() : string {}
        public function getAlternative() : ?string {}
    }

    /**
     * Represents a token stream.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class TokenStream {
        private $tokens;
        private $current;
        private $source;

        public function __construct(array $tokens, Source $source = null) {}
        public function __toString() {}
        public function injectTokens(array $tokens) {}
        /**
         * Sets the pointer to the next token and returns the old one.
         */
        public function next() : Token {}
        public function nextIf($primary, $secondary = null) {}
        public function expect($type, $value = null, string $message = null) : Token {}
        public function look(int $number = 1) : Token {}
        public function test($primary, $secondary = null) : bool {}
        /**
         * Checks if end of stream was reached.
         */
        public function isEOF() : bool {}
        public function getCurrent() : Token {}
        /**
         * Gets the source associated with this stream.
         *
         * @internal
         */
        public function getSourceContext() : Source {}
    }

}

namespace Twig\Extension {
    final class EscaperExtension extends \twig\extension\abstractextension {
        private $defaultStrategy;
        private $escapers;
        /** @internal */
        public $safeClasses;
        /** @internal */
        public $safeLookup;

        public function __construct($defaultStrategy = 'html') {}
        public function getTokenParsers() : array {}
        public function getNodeVisitors() : array {}
        public function getFilters() : array {}
        public function setDefaultStrategy($defaultStrategy) : void {}
        public function getDefaultStrategy(string $name) {}
        public function setEscaper($strategy, callable $callable) {}
        /**
         * Gets all defined escapers.
         *
         * @return callable[] An array of escapers
         */
        public function getEscapers() {}
        public function setSafeClasses(array $safeClasses = [ ]) {}
        public function addSafeClass(string $class, array $strategies) {}
    }

    class ProfilerExtension extends \twig\extension\abstractextension {
        private $actives;

        public function __construct(Profile $profile) {}
        public function enter(Profile $profile) {}
        public function leave(Profile $profile) {}
        public function getNodeVisitors() : array {}
    }

    /**
     * Used by \Twig\Environment as a staging area.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @internal
     */
    final class StagingExtension extends \twig\extension\abstractextension {
        private $functions;
        private $filters;
        private $visitors;
        private $tokenParsers;
        private $tests;

        public function addFunction(TwigFunction $function) : void {}
        public function getFunctions() : array {}
        public function addFilter(TwigFilter $filter) : void {}
        public function getFilters() : array {}
        public function addNodeVisitor(NodeVisitorInterface $visitor) : void {}
        public function getNodeVisitors() : array {}
        public function addTokenParser(TokenParserInterface $parser) : void {}
        public function getTokenParsers() : array {}
        public function addTest(TwigTest $test) : void {}
        public function getTests() : array {}
    }

    final class StringLoaderExtension extends \twig\extension\abstractextension {
        public function getFunctions() : array {}
    }

    abstract class AbstractExtension implements \twig\extension\extensioninterface {
        public function getTokenParsers() {}
        public function getNodeVisitors() {}
        public function getFilters() {}
        public function getTests() {}
        public function getFunctions() {}
        public function getOperators() {}
    }

    final class SandboxExtension extends \twig\extension\abstractextension {
        private $sandboxedGlobally;
        private $sandboxed;
        private $policy;

        public function __construct(SecurityPolicyInterface $policy, $sandboxed = false) {}
        public function getTokenParsers() : array {}
        public function getNodeVisitors() : array {}
        public function enableSandbox() : void {}
        public function disableSandbox() : void {}
        public function isSandboxed() : bool {}
        public function isSandboxedGlobally() : bool {}
        public function setSecurityPolicy(SecurityPolicyInterface $policy) {}
        public function getSecurityPolicy() : SecurityPolicyInterface {}
        public function checkSecurity($tags, $filters, $functions) : void {}
        public function checkMethodAllowed($obj, $method, int $lineno = -1, Source $source = null) : void {}
        public function checkPropertyAllowed($obj, $method, int $lineno = -1, Source $source = null) : void {}
        public function ensureToStringAllowed($obj, int $lineno = -1, Source $source = null) {}
    }

    final class CoreExtension extends \twig\extension\abstractextension {
        private $dateFormats;
        private $numberFormat;
        private $timezone;

        public function setDateFormat($format = null, $dateIntervalFormat = null) {}
        /**
         * Gets the default format to be used by the date filter.
         *
         * @return array The default date format string and the default date interval format string
         */
        public function getDateFormat() {}
        public function setTimezone($timezone) {}
        /**
         * Gets the default timezone to be used by the date filter.
         *
         * @return \DateTimeZone The default timezone currently in use
         */
        public function getTimezone() {}
        public function setNumberFormat($decimal, $decimalPoint, $thousandSep) {}
        /**
         * Get the default format used by the number_format filter.
         *
         * @return array The arguments for number_format()
         */
        public function getNumberFormat() {}
        public function getTokenParsers() : array {}
        public function getFilters() : array {}
        public function getFunctions() : array {}
        public function getTests() : array {}
        public function getNodeVisitors() : array {}
        public function getOperators() : array {}
    }

    final class OptimizerExtension extends \twig\extension\abstractextension {
        private $optimizers;

        public function __construct(int $optimizers = -1) {}
        public function getNodeVisitors() : array {}
    }

    final class DebugExtension extends \twig\extension\abstractextension {
        public function getFunctions() : array {}
    }


    /**
     * @author Grgoire Pineau <lyrixx@lyrixx.info>
     */
    interface RuntimeExtensionInterface {}

    /**
     * Interface implemented by extension classes.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface ExtensionInterface {
        /**
         * Returns the token parser instances to add to the existing list.
         *
         * @return TokenParserInterface[]
         */
        function getTokenParsers() ;
        /**
         * Returns the node visitor instances to add to the existing list.
         *
         * @return NodeVisitorInterface[]
         */
        function getNodeVisitors() ;
        /**
         * Returns a list of filters to add to the existing list.
         *
         * @return TwigFilter[]
         */
        function getFilters() ;
        /**
         * Returns a list of tests to add to the existing list.
         *
         * @return TwigTest[]
         */
        function getTests() ;
        /**
         * Returns a list of functions to add to the existing list.
         *
         * @return TwigFunction[]
         */
        function getFunctions() ;
        /**
         * Returns a list of operators to add to the existing list.
         *
         * @return array<array> First array of unary operators, second array of binary operators
         */
        function getOperators() ;
    }

    /**
     * Enables usage of the deprecated Twig\Extension\AbstractExtension::getGlobals() method.
     *
     * Explicitly implement this interface if you really need to implement the
     * deprecated getGlobals() method in your extensions.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface GlobalsInterface {
        function getGlobals() : array ;
    }

}

namespace Twig\Cache {
    /**
     * Implements a cache on the filesystem.
     *
     * @author Andrew Tch <andrew@noop.lv>
     */
    class FilesystemCache implements \twig\cache\cacheinterface {
        const FORCE_BYTECODE_INVALIDATION = 1;

        private $directory;
        private $options;

        public function __construct(string $directory, int $options = 0) {}
        public function generateKey(string $name, string $className) : string {}
        public function load(string $key) : void {}
        public function write(string $key, string $content) : void {}
        public function getTimestamp(string $key) : int {}
    }

    /**
     * Implements a no-cache strategy.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class NullCache implements \twig\cache\cacheinterface {
        public function generateKey(string $name, string $className) : string {}
        public function write(string $key, string $content) : void {}
        public function load(string $key) : void {}
        public function getTimestamp(string $key) : int {}
    }


    /**
     * Interface implemented by cache classes.
     *
     * It is highly recommended to always store templates on the filesystem to
     * benefit from the PHP opcode cache. This interface is mostly useful if you
     * need to implement a custom strategy for storing templates on the filesystem.
     *
     * @author Andrew Tch <andrew@noop.lv>
     */
    interface CacheInterface {
        function generateKey(string $name, string $className) : string ;
        function write(string $key, string $content) : void ;
        function load(string $key) : void ;
        function getTimestamp(string $key) : int ;
    }

}

namespace Twig\NodeVisitor {
    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class EscaperNodeVisitor implements \twig\nodevisitor\nodevisitorinterface {
        private $statusStack;
        private $blocks;
        private $safeAnalysis;
        private $traverser;
        private $defaultStrategy;
        private $safeVars;

        public function __construct() {}
        public function enterNode(Node $node, Environment $env) : Node {}
        public function leaveNode(Node $node, Environment $env) : ?Node {}
        private function shouldUnwrapConditional(ConditionalExpression $expression, Environment $env, string $type) : bool {}
        private function unwrapConditional(ConditionalExpression $expression, Environment $env, string $type) : ConditionalExpression {}
        private function escapeInlinePrintNode(InlinePrint $node, Environment $env, string $type) : Node {}
        private function escapePrintNode(PrintNode $node, Environment $env, string $type) : Node {}
        private function preEscapeFilterNode(FilterExpression $filter, Environment $env) : FilterExpression {}
        private function isSafeFor(string $type, Node $expression, Environment $env) : bool {}
        private function needEscaping(Environment $env) {}
        private function getEscaperFilter(string $type, Node $node) : FilterExpression {}
        public function getPriority() : int {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class SandboxNodeVisitor implements \twig\nodevisitor\nodevisitorinterface {
        private $inAModule;
        private $tags;
        private $filters;
        private $functions;
        private $needsToStringWrap;

        public function enterNode(Node $node, Environment $env) : Node {}
        public function leaveNode(Node $node, Environment $env) : ?Node {}
        private function wrapNode(Node $node, string $name) : void {}
        private function wrapArrayNode(Node $node, string $name) : void {}
        public function getPriority() : int {}
    }

    /**
     * Used to make node visitors compatible with Twig 1.x and 2.x.
     *
     * To be removed in Twig 3.1.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    abstract class AbstractNodeVisitor implements \twig\nodevisitor\nodevisitorinterface {
        public function enterNode(Node $node, Environment $env) : Node {}
        public function leaveNode(Node $node, Environment $env) : ?Node {}
        abstract protected function doEnterNode(Node $node, Environment $env) ;
        abstract protected function doLeaveNode(Node $node, Environment $env) ;
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class MacroAutoImportNodeVisitor implements \twig\nodevisitor\nodevisitorinterface {
        private $inAModule;
        private $hasMacroCalls;

        public function enterNode(Node $node, Environment $env) : Node {}
        public function leaveNode(Node $node, Environment $env) : Node {}
        public function getPriority() : int {}
    }

    /**
     * Tries to optimize the AST.
     *
     * This visitor is always the last registered one.
     *
     * You can configure which optimizations you want to activate via the
     * optimizer mode.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class OptimizerNodeVisitor implements \twig\nodevisitor\nodevisitorinterface {
        const OPTIMIZE_FOR = 2;
        const OPTIMIZE_RAW_FILTER = 4;
        const OPTIMIZE_ALL = -1;
        const OPTIMIZE_NONE = 0;

        private $loops;
        private $loopsTargets;
        private $optimizers;

        public function __construct(int $optimizers = -1) {}
        public function enterNode(Node $node, Environment $env) : Node {}
        public function leaveNode(Node $node, Environment $env) : ?Node {}
        private function optimizePrintNode(Node $node, Environment $env) : Node {}
        private function optimizeRawFilter(Node $node, Environment $env) : Node {}
        private function enterOptimizeFor(Node $node, Environment $env) : void {}
        private function leaveOptimizeFor(Node $node, Environment $env) : void {}
        private function addLoopToCurrent() : void {}
        private function addLoopToAll() : void {}
        public function getPriority() : int {}
    }

    final class SafeAnalysisNodeVisitor implements \twig\nodevisitor\nodevisitorinterface {
        private $data;
        private $safeVars;

        public function setSafeVars(array $safeVars) : void {}
        public function getSafe(Node $node) {}
        private function setSafe(Node $node, array $safe) : void {}
        public function enterNode(Node $node, Environment $env) : Node {}
        public function leaveNode(Node $node, Environment $env) : ?Node {}
        private function intersectSafe(array $a = null, array $b = null) : array {}
        public function getPriority() : int {}
    }


    /**
     * Interface for node visitor classes.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface NodeVisitorInterface {
        function enterNode(Node $node, Environment $env) : Node ;
        function leaveNode(Node $node, Environment $env) : ?Node ;
        /**
         * Returns the priority for this visitor.
         *
         * Priority should be between -10 and 10 (0 is the default).
         *
         * @return int The priority level
         */
        function getPriority() ;
    }

}

namespace Twig\Test {
    abstract class NodeTestCase extends \phpunit\framework\testcase {
        abstract public function getTests() ;
        public function testCompile($node, $source, $environment = null, $isPattern = false) {}
        public function assertNodeCompilation($source, Node $node, Environment $environment = null, $isPattern = false) {}
        protected function getCompiler(Environment $environment = null) {}
        protected function getEnvironment() {}
        protected function getVariableGetter($name, $line = false) {}
        protected function getAttributeGetter() {}
    }

    /**
     * Integration test helper.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Karma Dordrak <drak@zikula.org>
     */
    abstract class IntegrationTestCase extends \phpunit\framework\testcase {
        /**
         * @return string
         */
        abstract protected function getFixturesDir() ;
        /**
         * @return RuntimeLoaderInterface[]
         */
        protected function getRuntimeLoaders() {}
        /**
         * @return ExtensionInterface[]
         */
        protected function getExtensions() {}
        /**
         * @return TwigFilter[]
         */
        protected function getTwigFilters() {}
        /**
         * @return TwigFunction[]
         */
        protected function getTwigFunctions() {}
        /**
         * @return TwigTest[]
         */
        protected function getTwigTests() {}
        public function testIntegration($file, $message, $condition, $templates, $exception, $outputs, $deprecation = '') {}
        public function testLegacyIntegration($file, $message, $condition, $templates, $exception, $outputs, $deprecation = '') {}
        public function getTests($name, $legacyTests = false) {}
        public function getLegacyTests() {}
        protected function doIntegrationTest($file, $message, $condition, $templates, $exception, $outputs, $deprecation = '') {}
        protected static function parseTemplates($test) {}
    }

}

namespace Twig\Util {
    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class DeprecationCollector {
        private $twig;

        public function __construct(Environment $twig) {}
        public function collectDir(string $dir, string $ext = '.twig') : array {}
        public function collect(\Traversable $iterator) : array {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class TemplateDirIterator extends \iteratoriterator {
        public function current() {}
        public function key() {}
    }

}

namespace Twig\RuntimeLoader {
    /**
     * Lazy loads the runtime implementations for a Twig element.
     *
     * @author Robin Chalas <robin.chalas@gmail.com>
     */
    class FactoryRuntimeLoader implements \twig\runtimeloader\runtimeloaderinterface {
        private $map;

        public function __construct(array $map = [ ]) {}
        public function load(string $class) {}
    }

    /**
     * Lazily loads Twig runtime implementations from a PSR-11 container.
     *
     * Note that the runtime services MUST use their class names as identifiers.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Robin Chalas <robin.chalas@gmail.com>
     */
    class ContainerRuntimeLoader implements \twig\runtimeloader\runtimeloaderinterface {
        private $container;

        public function __construct(ContainerInterface $container) {}
        public function load(string $class) {}
    }


    /**
     * Creates runtime implementations for Twig elements (filters/functions/tests).
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface RuntimeLoaderInterface {
        function load(string $class) ;
    }

}

namespace Twig\Sandbox {
    /**
     * Represents a security policy which need to be enforced when sandbox mode is enabled.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class SecurityPolicy implements \twig\sandbox\securitypolicyinterface {
        private $allowedTags;
        private $allowedFilters;
        private $allowedMethods;
        private $allowedProperties;
        private $allowedFunctions;

        public function __construct(array $allowedTags = [ ], array $allowedFilters = [ ], array $allowedMethods = [ ], array $allowedProperties = [ ], array $allowedFunctions = [ ]) {}
        public function setAllowedTags(array $tags) : void {}
        public function setAllowedFilters(array $filters) : void {}
        public function setAllowedMethods(array $methods) : void {}
        public function setAllowedProperties(array $properties) : void {}
        public function setAllowedFunctions(array $functions) : void {}
        public function checkSecurity($tags, $filters, $functions) : void {}
        public function checkMethodAllowed($obj, $method) : void {}
        public function checkPropertyAllowed($obj, $property) : void {}
    }

    /**
     * Exception thrown when a not allowed function is used in a template.
     *
     * @author Martin Haso <martin.hason@gmail.com>
     */
    final class SecurityNotAllowedFunctionError extends \twig\sandbox\securityerror {
        private $functionName;

        public function __construct(string $message, string $functionName) {}
        public function getFunctionName() : string {}
    }

    /**
     * Exception thrown when a not allowed class method is used in a template.
     *
     * @author Kit Burton-Senior <mail@kitbs.com>
     */
    final class SecurityNotAllowedMethodError extends \twig\sandbox\securityerror {
        private $className;
        private $methodName;

        public function __construct(string $message, string $className, string $methodName) {}
        public function getClassName() : string {}
        public function getMethodName() {}
    }

    /**
     * Exception thrown when a security error occurs at runtime.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class SecurityError extends \twig\error\error {}

    /**
     * Exception thrown when a not allowed tag is used in a template.
     *
     * @author Martin Haso <martin.hason@gmail.com>
     */
    final class SecurityNotAllowedTagError extends \twig\sandbox\securityerror {
        private $tagName;

        public function __construct(string $message, string $tagName) {}
        public function getTagName() : string {}
    }

    /**
     * Exception thrown when a not allowed filter is used in a template.
     *
     * @author Martin Haso <martin.hason@gmail.com>
     */
    final class SecurityNotAllowedFilterError extends \twig\sandbox\securityerror {
        private $filterName;

        public function __construct(string $message, string $functionName) {}
        public function getFilterName() : string {}
    }

    /**
     * Exception thrown when a not allowed class property is used in a template.
     *
     * @author Kit Burton-Senior <mail@kitbs.com>
     */
    final class SecurityNotAllowedPropertyError extends \twig\sandbox\securityerror {
        private $className;
        private $propertyName;

        public function __construct(string $message, string $className, string $propertyName) {}
        public function getClassName() : string {}
        public function getPropertyName() {}
    }


    /**
     * Interface that all security policy classes must implements.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface SecurityPolicyInterface {
        function checkSecurity($tags, $filters, $functions) : void ;
        function checkMethodAllowed($obj, $method) : void ;
        function checkPropertyAllowed($obj, $method) : void ;
    }

}

namespace Twig\Loader {
    /**
     * Loads template from the filesystem.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class FilesystemLoader implements \twig\loader\loaderinterface {
        const MAIN_NAMESPACE = '__main__';

        protected $paths;
        protected $cache;
        protected $errorCache;
        private $rootPath;

        public function __construct($paths = [ ], string $rootPath = null) {}
        public function getPaths(string $namespace = self::MAIN_NAMESPACE) : array {}
        /**
         * Returns the path namespaces.
         *
         * The main namespace is always defined.
         */
        public function getNamespaces() : array {}
        public function setPaths($paths, string $namespace = self::MAIN_NAMESPACE) : void {}
        public function addPath(string $path, string $namespace = self::MAIN_NAMESPACE) : void {}
        public function prependPath(string $path, string $namespace = self::MAIN_NAMESPACE) : void {}
        public function getSourceContext(string $name) : Source {}
        public function getCacheKey(string $name) : string {}
        public function exists(string $name) {}
        public function isFresh(string $name, int $time) : bool {}
        protected function findTemplate(string $name, bool $throw = true) {}
        private function normalizeName(string $name) : string {}
        private function parseName(string $name, string $default = self::MAIN_NAMESPACE) : array {}
        private function validateName(string $name) : void {}
        private function isAbsolutePath(string $file) : bool {}
    }

    /**
     * Loads a template from an array.
     *
     * When using this loader with a cache mechanism, you should know that a new cache
     * key is generated each time a template content "changes" (the cache key being the
     * source code of the template). If you don't want to see your cache grows out of
     * control, you need to take care of clearing the old cache file by yourself.
     *
     * This loader should only be used for unit testing.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class ArrayLoader implements \twig\loader\loaderinterface {
        private $templates;

        public function __construct(array $templates = [ ]) {}
        public function setTemplate(string $name, string $template) : void {}
        public function getSourceContext(string $name) : Source {}
        public function exists(string $name) : bool {}
        public function getCacheKey(string $name) : string {}
        public function isFresh(string $name, int $time) : bool {}
    }

    /**
     * Loads templates from other loaders.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class ChainLoader implements \twig\loader\loaderinterface {
        private $hasSourceCache;
        private $loaders;

        public function __construct(array $loaders = [ ]) {}
        public function addLoader(LoaderInterface $loader) : void {}
        /**
         * @return LoaderInterface[]
         */
        public function getLoaders() : array {}
        public function getSourceContext(string $name) : Source {}
        public function exists(string $name) : bool {}
        public function getCacheKey(string $name) : string {}
        public function isFresh(string $name, int $time) : bool {}
    }


    /**
     * Interface all loaders must implement.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface LoaderInterface {
        function getSourceContext(string $name) : Source ;
        function getCacheKey(string $name) : string ;
        function isFresh(string $name, int $time) : bool ;
        function exists(string $name) ;
    }

}

namespace Twig\Profiler {
    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class Profile implements \serializable, \iteratoraggregate {
        const ROOT = 'ROOT';
        const BLOCK = 'block';
        const TEMPLATE = 'template';
        const MACRO = 'macro';

        private $template;
        private $name;
        private $type;
        private $starts;
        private $ends;
        private $profiles;

        public function __construct(string $template = 'main', string $type = self::ROOT, string $name = 'main') {}
        public function getTemplate() : string {}
        public function getType() : string {}
        public function getName() : string {}
        public function isRoot() : bool {}
        public function isTemplate() : bool {}
        public function isBlock() : bool {}
        public function isMacro() : bool {}
        /**
         * @return Profile[]
         */
        public function getProfiles() : array {}
        public function addProfile(self $profile) : void {}
        /**
         * Returns the duration in microseconds.
         */
        public function getDuration() : float {}
        /**
         * Returns the memory usage in bytes.
         */
        public function getMemoryUsage() : int {}
        /**
         * Returns the peak memory usage in bytes.
         */
        public function getPeakMemoryUsage() : int {}
        /**
         * Starts the profiling.
         */
        public function enter() : void {}
        /**
         * Stops the profiling.
         */
        public function leave() : void {}
        public function reset() : void {}
        public function getIterator() : \Traversable {}
        public function serialize() {}
        public function unserialize($data) {}
        /**
         * @internal
         */
        public function __serialize() {}
        public function __unserialize(array $data) {}
    }

}

namespace Twig\Profiler\NodeVisitor {
    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class ProfilerNodeVisitor implements \twig\nodevisitor\nodevisitorinterface {
        private $extensionName;

        public function __construct(string $extensionName) {}
        public function enterNode(Node $node, Environment $env) : Node {}
        public function leaveNode(Node $node, Environment $env) : ?Node {}
        private function getVarName() : string {}
        public function getPriority() : int {}
    }

}

namespace Twig\Profiler\Node {
    /**
     * Represents a profile enter node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class EnterProfileNode extends \twig\node\node {
        public function __construct(string $extensionName, string $type, string $name, string $varName) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a profile leave node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class LeaveProfileNode extends \twig\node\node {
        public function __construct(string $varName) {}
        public function compile(Compiler $compiler) : void {}
    }

}

namespace Twig\Profiler\Dumper {
    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class BlackfireDumper {
        public function dump(Profile $profile) : string {}
        private function dumpChildren(string $parent, Profile $profile, $data) {}
        private function dumpProfile(string $edge, Profile $profile, $data) {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class TextDumper extends \twig\profiler\dumper\basedumper {
        protected function formatTemplate(Profile $profile, $prefix) : string {}
        protected function formatNonTemplate(Profile $profile, $prefix) : string {}
        protected function formatTime(Profile $profile, $percent) : string {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    abstract class BaseDumper {
        private $root;

        public function dump(Profile $profile) : string {}
        abstract protected function formatTemplate(Profile $profile, $prefix) : string ;
        abstract protected function formatNonTemplate(Profile $profile, $prefix) : string ;
        abstract protected function formatTime(Profile $profile, $percent) : string ;
        private function dumpProfile(Profile $profile, $prefix = '', $sibling = false) : string {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class HtmlDumper extends \twig\profiler\dumper\basedumper {
        static private $colors;

        public function dump(Profile $profile) : string {}
        protected function formatTemplate(Profile $profile, $prefix) : string {}
        protected function formatNonTemplate(Profile $profile, $prefix) : string {}
        protected function formatTime(Profile $profile, $percent) : string {}
    }

}

namespace Twig\TokenParser {
    /**
     * Deprecates a section of a template.
     *
     *    {% deprecated 'The "base.twig" template is deprecated, use "layout.twig" instead.' %}
     *    {% extends 'layout.html.twig' %}
     *
     * @author Yonel Ceruto <yonelceruto@gmail.com>
     */
    final class DeprecatedTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function getTag() : string {}
    }

    /**
     * Loops over each item of a sequence.
     *
     *   <ul>
     *    {% for user in users %}
     *      <li>{{ user.username|e }}</li>
     *    {% endfor %}
     *   </ul>
     */
    final class ForTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideForFork(Token $token) : bool {}
        public function decideForEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Evaluates an expression, discarding the returned value.
     */
    final class DoTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function getTag() : string {}
    }

    /**
     * Imports macros.
     *
     *   {% from 'forms.html' import forms %}
     */
    final class FromTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function getTag() : string {}
    }

    /**
     * Base class for all token parsers.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    abstract class AbstractTokenParser implements \twig\tokenparser\tokenparserinterface {
        /**
         * @var Parser
         */
        protected $parser;

        public function setParser(Parser $parser) : void {}
    }

    /**
     * Marks a section of a template as untrusted code that must be evaluated in the sandbox mode.
     *
     *    {% sandbox %}
     *        {% include 'user.html' %}
     *    {% endsandbox %}
     *
     * @see https://twig.symfony.com/doc/api.html#sandbox-extension for details
     */
    final class SandboxTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideBlockEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Imports blocks defined in another template into the current template.
     *
     *    {% extends "base.html" %}
     *
     *    {% use "blocks.html" %}
     *
     *    {% block title %}{% endblock %}
     *    {% block content %}{% endblock %}
     *
     * @see https://twig.symfony.com/doc/templates.html#horizontal-reuse for details.
     */
    final class UseTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function getTag() : string {}
    }

    /**
     * Marks a section of a template to be escaped or not.
     */
    final class AutoEscapeTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideBlockEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Includes a template.
     *
     *   {% include 'header.html' %}
     *     Body
     *   {% include 'footer.html' %}
     */
    class IncludeTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        protected function parseArguments() {}
        public function getTag() : string {}
    }

    /**
     * Applies filters on a section of a template.
     *
     *   {% apply upper %}
     *      This text becomes uppercase
     *   {% endapply %}
     */
    final class ApplyTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideApplyEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Defines a variable.
     *
     *  {% set foo = 'foo' %}
     *  {% set foo = [1, 2] %}
     *  {% set foo = {'foo': 'bar'} %}
     *  {% set foo = 'foo' ~ 'bar' %}
     *  {% set foo, bar = 'foo', 'bar' %}
     *  {% set foo %}Some content{% endset %}
     */
    final class SetTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideBlockEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Embeds a template.
     */
    final class EmbedTokenParser extends \twig\tokenparser\includetokenparser {
        public function parse(Token $token) : Node {}
        public function decideBlockEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Flushes the output to the client.
     *
     * @see flush()
     */
    final class FlushTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function getTag() : string {}
    }

    /**
     * Creates a nested scope.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class WithTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideWithEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Imports macros.
     *
     *   {% import 'forms.html' as forms %}
     */
    final class ImportTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function getTag() : string {}
    }

    /**
     * Marks a section of a template as being reusable.
     *
     *  {% block head %}
     *    <link rel="stylesheet" href="style.css" />
     *    <title>{% block title %}{% endblock %} - My Webpage</title>
     *  {% endblock %}
     */
    final class BlockTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideBlockEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Extends a template by another one.
     *
     *  {% extends "base.html" %}
     */
    final class ExtendsTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function getTag() : string {}
    }

    /**
     * Tests a condition.
     *
     *   {% if users %}
     *    <ul>
     *      {% for user in users %}
     *        <li>{{ user.username|e }}</li>
     *      {% endfor %}
     *    </ul>
     *   {% endif %}
     */
    final class IfTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideIfFork(Token $token) : bool {}
        public function decideIfEnd(Token $token) : bool {}
        public function getTag() : string {}
    }

    /**
     * Defines a macro.
     *
     *   {% macro input(name, value, type, size) %}
     *      <input type="{{ type|default('text') }}" name="{{ name }}" value="{{ value|e }}" size="{{ size|default(20) }}" />
     *   {% endmacro %}
     */
    final class MacroTokenParser extends \twig\tokenparser\abstracttokenparser {
        public function parse(Token $token) : Node {}
        public function decideBlockEnd(Token $token) : bool {}
        public function getTag() : string {}
    }


    /**
     * Interface implemented by token parsers.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface TokenParserInterface {
        function setParser(Parser $parser) : void ;
        function parse(Token $token) ;
        /**
         * Gets the tag name associated with this token parser.
         *
         * @return string
         */
        function getTag() ;
    }

}

namespace Twig\Node {
    /**
     * Represents a sandbox node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class SandboxNode extends \twig\node\node {
        public function __construct(Node $body, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents an include node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class IncludeNode extends \twig\node\node implements \twig\node\nodeoutputinterface {
        public function __construct(AbstractExpression $expr, ?AbstractExpression $variables, bool $only, bool $ignoreMissing, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
        protected function addGetTemplate(Compiler $compiler) {}
        protected function addTemplateArguments(Compiler $compiler) {}
    }

    /**
     * Represents a for node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class ForNode extends \twig\node\node {
        private $loop;

        public function __construct(AssignNameExpression $keyTarget, AssignNameExpression $valueTarget, AbstractExpression $seq, ?Node $ifexpr, Node $body, ?Node $else, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class CheckSecurityNode extends \twig\node\node {
        private $usedFilters;
        private $usedTags;
        private $usedFunctions;

        public function __construct(array $usedFilters, array $usedTags, array $usedFunctions) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a block call node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class BlockReferenceNode extends \twig\node\node implements \twig\node\nodeoutputinterface {
        public function __construct(string $name, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a text node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class TextNode extends \twig\node\node implements \twig\node\nodeoutputinterface {
        public function __construct(string $data, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a body node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class BodyNode extends \twig\node\node {}

    /**
     * Represents a macro node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class MacroNode extends \twig\node\node {
        const VARARGS_NAME = 'varargs';

        public function __construct(string $name, Node $body, Node $arguments, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a block node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class BlockNode extends \twig\node\node {
        public function __construct(string $name, Node $body, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a node in the AST.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Node implements \countable, \iteratoraggregate {
        protected $nodes;
        protected $attributes;
        protected $lineno;
        protected $tag;
        private $name;
        private $sourceContext;

        public function __construct(array $nodes = [ ], array $attributes = [ ], int $lineno = 0, string $tag = null) {}
        public function __toString() {}
        public function compile(Compiler $compiler) {}
        public function getTemplateLine() : int {}
        public function getNodeTag() : ?string {}
        public function hasAttribute(string $name) : bool {}
        public function getAttribute(string $name) {}
        public function setAttribute(string $name, $value) : void {}
        public function removeAttribute(string $name) : void {}
        public function hasNode(string $name) : bool {}
        public function getNode(string $name) : self {}
        public function setNode(string $name, self $node) : void {}
        public function removeNode(string $name) : void {}
        public function count() {}
        public function getIterator() : \Traversable {}
        public function getTemplateName() : ?string {}
        public function setSourceContext(Source $source) : void {}
        public function getSourceContext() : ?Source {}
    }

    /**
     * Represents a nested "with" scope.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class WithNode extends \twig\node\node {
        public function __construct(Node $body, ?Node $variables, bool $only, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents an autoescape node.
     *
     * The value is the escaping strategy (can be html, js, ...)
     *
     * The true value is equivalent to html.
     *
     * If autoescaping is disabled, then the value is false.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class AutoEscapeNode extends \twig\node\node {
        public function __construct($value, Node $body, int $lineno, string $tag = 'autoescape') {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a set node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class SetNode extends \twig\node\node implements \twig\node\nodecaptureinterface {
        public function __construct(bool $capture, Node $names, Node $values, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents an import node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class ImportNode extends \twig\node\node {
        public function __construct(AbstractExpression $expr, AbstractExpression $var, int $lineno, string $tag = null, bool $global = true) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a do node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class DoNode extends \twig\node\node {
        public function __construct(AbstractExpression $expr, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a module node.
     *
     * Consider this class as being final. If you need to customize the behavior of
     * the generated class, consider adding nodes to the following nodes: display_start,
     * display_end, constructor_start, constructor_end, and class_end.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    final class ModuleNode extends \twig\node\node {
        public function __construct(Node $body, ?AbstractExpression $parent, Node $blocks, Node $macros, Node $traits, $embeddedTemplates, Source $source) {}
        public function setIndex($index) {}
        public function compile(Compiler $compiler) : void {}
        protected function compileTemplate(Compiler $compiler) {}
        protected function compileGetParent(Compiler $compiler) {}
        protected function compileClassHeader(Compiler $compiler) {}
        protected function compileConstructor(Compiler $compiler) {}
        protected function compileDisplay(Compiler $compiler) {}
        protected function compileClassFooter(Compiler $compiler) {}
        protected function compileMacros(Compiler $compiler) {}
        protected function compileGetTemplateName(Compiler $compiler) {}
        protected function compileIsTraitable(Compiler $compiler) {}
        protected function compileDebugInfo(Compiler $compiler) {}
        protected function compileGetSourceContext(Compiler $compiler) {}
        protected function compileLoadTemplate(Compiler $compiler, $node, $var) {}
    }

    /**
     * Represents a flush node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class FlushNode extends \twig\node\node {
        public function __construct(int $lineno, string $tag) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Internal node used by the for node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class ForLoopNode extends \twig\node\node {
        public function __construct(int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Checks if casting an expression to __toString() is allowed by the sandbox.
     *
     * For instance, when there is a simple Print statement, like {{ article }},
     * and if the sandbox is enabled, we need to check that the __toString()
     * method is allowed if 'article' is an object. The same goes for {{ article|upper }}
     * or {{ random(article) }}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class CheckToStringNode extends \twig\node\expression\abstractexpression {
        public function __construct(AbstractExpression $expr) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents an if node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class IfNode extends \twig\node\node {
        public function __construct(Node $tests, ?Node $else, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents an embed node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class EmbedNode extends \twig\node\includenode {
        public function __construct(string $name, int $index, ?AbstractExpression $variables, bool $only, bool $ignoreMissing, int $lineno, string $tag = null) {}
        protected function addGetTemplate(Compiler $compiler) : void {}
    }

    /**
     * Represents a node that outputs an expression.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class PrintNode extends \twig\node\node implements \twig\node\nodeoutputinterface {
        public function __construct(AbstractExpression $expr, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a deprecated node.
     *
     * @author Yonel Ceruto <yonelceruto@gmail.com>
     */
    class DeprecatedNode extends \twig\node\node {
        public function __construct(AbstractExpression $expr, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }


    /**
     * Represents a displayable node in the AST.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface NodeOutputInterface {}

    /**
     * Represents a node that captures any nested displayable nodes.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface NodeCaptureInterface {}

}

namespace Twig\Node\Expression {
    abstract class CallExpression extends \twig\node\expression\abstractexpression {
        private $reflector;

        protected function compileCallable(Compiler $compiler) {}
        protected function compileArguments(Compiler $compiler, $isArray = false) : void {}
        protected function getArguments($callable, $arguments) {}
        protected function normalizeName(string $name) : string {}
        private function getCallableParameters($callable, bool $isVariadic) : array {}
        private function reflectCallable($callable) {}
    }

    class FunctionExpression extends \twig\node\expression\callexpression {
        public function __construct(string $name, Node $arguments, int $lineno) {}
        public function compile(Compiler $compiler) {}
    }

    /**
     * Represents a parent node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class ParentExpression extends \twig\node\expression\abstractexpression {
        public function __construct(string $name, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents a block call node.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class BlockReferenceExpression extends \twig\node\expression\abstractexpression {
        public function __construct(Node $name, ?Node $template, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
        private function compileTemplateCall(Compiler $compiler, string $method) : Compiler {}
        private function compileBlockArguments(Compiler $compiler) : Compiler {}
    }

    class FilterExpression extends \twig\node\expression\callexpression {
        public function __construct(Node $node, ConstantExpression $filterName, Node $arguments, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Represents an arrow function.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class ArrowFunctionExpression extends \twig\node\expression\abstractexpression {
        public function __construct(AbstractExpression $expr, Node $names, $lineno, $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

    class MethodCallExpression extends \twig\node\expression\abstractexpression {
        public function __construct(AbstractExpression $node, string $method, ArrayExpression $arguments, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    class ConstantExpression extends \twig\node\expression\abstractexpression {
        public function __construct($value, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    class VariadicExpression extends \twig\node\expression\arrayexpression {
        public function compile(Compiler $compiler) : void {}
    }

    class AssignNameExpression extends \twig\node\expression\nameexpression {
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * @internal
     */
    final class InlinePrint extends \twig\node\expression\abstractexpression {
        public function __construct(Node $node, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Abstract class for all nodes that represents an expression.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    abstract class AbstractExpression extends \twig\node\node {}

    class TempNameExpression extends \twig\node\expression\abstractexpression {
        public function __construct(string $name, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    class NullCoalesceExpression extends \twig\node\expression\conditionalexpression {
        public function __construct(Node $left, Node $right, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    class ArrayExpression extends \twig\node\expression\abstractexpression {
        private $index;

        public function __construct(array $elements, int $lineno) {}
        public function getKeyValuePairs() : array {}
        public function hasElement(AbstractExpression $key) : bool {}
        public function addElement(AbstractExpression $value, AbstractExpression $key = null) : void {}
        public function compile(Compiler $compiler) : void {}
    }

    class TestExpression extends \twig\node\expression\callexpression {
        public function __construct(Node $node, string $name, ?Node $arguments, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    class NameExpression extends \twig\node\expression\abstractexpression {
        private $specialVars;

        public function __construct(string $name, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
        public function isSpecial() {}
        public function isSimple() {}
    }

    class ConditionalExpression extends \twig\node\expression\abstractexpression {
        public function __construct(AbstractExpression $expr1, AbstractExpression $expr2, AbstractExpression $expr3, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

    class GetAttrExpression extends \twig\node\expression\abstractexpression {
        public function __construct(AbstractExpression $node, AbstractExpression $attribute, ?AbstractExpression $arguments, string $type, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
    }

}

namespace Twig\Node\Expression\Unary {
    class NegUnary extends \twig\node\expression\unary\abstractunary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class NotUnary extends \twig\node\expression\unary\abstractunary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class PosUnary extends \twig\node\expression\unary\abstractunary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    abstract class AbstractUnary extends \twig\node\expression\abstractexpression {
        public function __construct(Node $node, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
        abstract public function operator(Compiler $compiler) : Compiler ;
    }

}

namespace Twig\Node\Expression\Test {
    /**
     * Checks if a number is even.
     *
     *  {{ var is even }}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class EvenTest extends \twig\node\expression\testexpression {
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Checks if a variable is the same as another one (=== in PHP).
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class SameasTest extends \twig\node\expression\testexpression {
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Checks if a variable is divisible by a number.
     *
     *  {% if loop.index is divisible by(3) %}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class DivisiblebyTest extends \twig\node\expression\testexpression {
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Checks if a variable is the exact same value as a constant.
     *
     *    {% if post.status is constant('Post::PUBLISHED') %}
     *      the status attribute is exactly the same as Post::PUBLISHED
     *    {% endif %}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class ConstantTest extends \twig\node\expression\testexpression {
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Checks that a variable is null.
     *
     *  {{ var is none }}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class NullTest extends \twig\node\expression\testexpression {
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Checks if a variable is defined in the current context.
     *
     *    {# defined works with variable names and variable attributes #}
     *    {% if foo is defined %}
     *        {# ... #}
     *    {% endif %}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class DefinedTest extends \twig\node\expression\testexpression {
        public function __construct(Node $node, string $name, ?Node $arguments, int $lineno) {}
        private function changeIgnoreStrictCheck(GetAttrExpression $node) {}
        public function compile(Compiler $compiler) : void {}
    }

    /**
     * Checks if a number is odd.
     *
     *  {{ var is odd }}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class OddTest extends \twig\node\expression\testexpression {
        public function compile(Compiler $compiler) : void {}
    }

}

namespace Twig\Node\Expression\Binary {
    class NotInBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class RangeBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class EndsWithBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class MulBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class MatchesBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class GreaterEqualBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    abstract class AbstractBinary extends \twig\node\expression\abstractexpression {
        public function __construct(Node $left, Node $right, int $lineno) {}
        public function compile(Compiler $compiler) : void {}
        abstract public function operator(Compiler $compiler) : Compiler ;
    }

    class ModBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class SubBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class BitwiseOrBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class FloorDivBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class StartsWithBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class LessEqualBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class InBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class LessBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class AddBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class EqualBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class SpaceshipBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class BitwiseXorBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class ConcatBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class AndBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class BitwiseAndBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class NotEqualBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

    class PowerBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class DivBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class OrBinary extends \twig\node\expression\binary\abstractbinary {
        public function operator(Compiler $compiler) : Compiler {}
    }

    class GreaterBinary extends \twig\node\expression\binary\abstractbinary {
        public function compile(Compiler $compiler) : void {}
        public function operator(Compiler $compiler) : Compiler {}
    }

}

namespace Twig\Node\Expression\Filter {
    /**
     * Returns the value or the default value when it is undefined or empty.
     *
     *  {{ var.foo|default('foo item on var is not defined') }}
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class DefaultFilter extends \twig\node\expression\filterexpression {
        public function __construct(Node $node, ConstantExpression $filterName, Node $arguments, int $lineno, string $tag = null) {}
        public function compile(Compiler $compiler) : void {}
    }

}

namespace Twig\Error {
    /**
     * Exception thrown when an error occurs during template loading.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class LoaderError extends \twig\error\error {}

    /**
     * Exception thrown when an error occurs at runtime.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class RuntimeError extends \twig\error\error {}

    /**
     * Twig base exception.
     *
     * This exception class and its children must only be used when
     * an error occurs during the loading of a template, when a syntax error
     * is detected in a template, or when rendering a template. Other
     * errors must use regular PHP exception classes (like when the template
     * cache directory is not writable for instance).
     *
     * To help debugging template issues, this class tracks the original template
     * name and line where the error occurred.
     *
     * Whenever possible, you must set these information (original template name
     * and line number) yourself by passing them to the constructor. If some or all
     * these information are not available from where you throw the exception, then
     * this class will guess them automatically (when the line number is set to -1
     * and/or the name is set to null). As this is a costly operation, this
     * can be disabled by passing false for both the name and the line number
     * when creating a new instance of this class.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Error extends \exception {
        private $lineno;
        private $name;
        private $rawMessage;
        private $sourcePath;
        private $sourceCode;

        public function __construct(string $message, int $lineno = -1, Source $source = null, \Exception $previous = null) {}
        public function getRawMessage() : string {}
        public function getTemplateLine() : int {}
        public function setTemplateLine(int $lineno) : void {}
        public function getSourceContext() : ?Source {}
        public function setSourceContext(Source $source = null) : void {}
        public function guess() : void {}
        public function appendMessage($rawMessage) : void {}
        private function updateRepr() : void {}
        private function guessTemplateInfo() : void {}
    }

    /**
     * \Exception thrown when a syntax error occurs during lexing or parsing of a template.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class SyntaxError extends \twig\error\error {
        public function addSuggestions(string $name, array $items) : void {}
    }

}

?>
