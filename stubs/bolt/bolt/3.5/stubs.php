<?php
/**
  * Generated by Exakat 2.1.6 (Build 1091)
  * On 2020-09-08T04:45:17+00:00
  * See https://www.exakat.io/
  */

namespace  {
}

namespace Bolt {
    class Application extends \silex\application {
        const DEFAULT_LOCALE = 'en_GB';

        /** @var bool */
        protected $initialized;

/** @internal Parameter to track a deprecated PHP version */
        public function __construct(/** @internal Parameter to track a deprecated PHP version */
array $values = [ ]) {}
        public function run(Request $request = null) {}
        protected function initConfig() {}
        protected function initSession() {}
        public function initialize() {}
        /**
         * Initialize the loggers.
         */
        public function initLogger() {}
        /**
         * Initialize the database providers.
         */
        public function initDatabase() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        protected function checkDatabaseConnection() {}
        /**
         * Initialize the rendering providers.
         */
        public function initRendering() {}
        /**
         * Set up the debugging if required.
         */
        public function initDebugging() {}
        /**
         * Set up the profilers for the toolbar.
         */
        public function initProfiler() {}
        public function initLocale() {}
        public function initProviders() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function initExtensions() {}
        public function mount($prefix, $controllers) {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use {@see ControllerEvents::MOUNT} instead.
         */
        public function initMountpoints() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function beforeHandler() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function afterHandler() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function errorHandler() {}
        public function __isset($name) {}
        /**
         * Get the Bolt version string.
         *
         * @return string
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         *             Use parameters in application instead
         */
        public function getVersion() {}
        public function generatePath($route, $parameters = [ ]) {}
    }

    /**
     * Simple, file based cache for volatile data. Useful for storing non-vital
     * information like feeds, and other stuff that can be recovered easily.
     *
     * @author Bob den Otter <bob@twokings.nl>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Cache extends \doctrine\common\cache\filesystemcache {
        const DEFAULT_MAX_AGE = 600;
        const EXTENSION = '.data';

        /** @var CompositeFilesystemInterface */
        private $filesystem;
        /** @var int */
        private $umask;

        public function __construct($directory, $extension = self::EXTENSION, $umask = 2, CompositeFilesystemInterface $filesystem = null) {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use flushAll() instead.
         */
        public function clearCache() {}
        /**
         * Clear the cache. Both the doctrine FilesystemCache, as well as twig and thumbnail temp files.
         *
         * @return bool
         */
        protected function doFlush() {}
/** @var HandlerInterface $file */
        private function flushDirectory(/** @var HandlerInterface $file */
DirectoryInterface $directory) {}
        /**
         * Create base path path if needed.
         *
         * @return bool
         */
        private function createPathIfNeeded() {}
    }

    /**
     * @deprecated since 3.3, to be removed in 4.0.
     */
    class DeepDiff {
        public static function diff($a, $b) {}
    }

    /**
     * Class for Bolt's generic library functions.
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Library {
        public static function formatFilesize($size) {}
        public static function filesizeToBytes($size) {}
        public static function getExtension($filename) {}
        public static function safeFilename($filename) {}
        public static function path($path, $param = [ ], $add = '') {}
        public static function redirect($path, $param = [ ], $add = '') {}
        public static function simpleredirect($path, $abort = false) {}
        public static function smartUnserialize($str, $assoc = true) {}
    }

    /**
     * Simple search implementation for the Bolt backend.
     *
     * TODO:
     * - permissions
     * - a config.yml for search options
     *
     * @author Xiao-HuTai, xiao@twokings.nl
     */
    class Omnisearch {
        const OMNISEARCH_LANDINGPAGE = 99999;
        const OMNISEARCH_FILE = 1000;
        const OMNISEARCH_CONTENT = 2000;
        const OMNISEARCH_EXTENSION = 3000;
        const OMNISEARCH_MENUITEM = 5000;
        const OMNISEARCH_CONTENTTYPE = 9999;

        private $showNewContentType;
        private $showViewContentType;
        private $showConfiguration;
        private $showMaintenance;
        private $showExtensions;
        private $showFiles;
        private $showRecords;
        private $showLandingpage;
        private $app;
        private $data;

        public function __construct(Silex\Application $app) {}
        public function initialize() {}
        private function initContentTypes() {}
        private function initMenuitems() {}
        /** @var \Bolt\Menu\MenuEntry $extension */
        private function initExtensions() {}
        public function register($options) {}
        public function query($query, $withRecord = false) {}
/** @var \Symfony\Component\Finder\SplFileInfo $file */
        private function find(/** @var \Symfony\Component\Finder\SplFileInfo $file */
$query, /** @var \Symfony\Component\Finder\SplFileInfo $file */
$path = 'theme', /** @var \Symfony\Component\Finder\SplFileInfo $file */
$name = '*.twig', /** @var \Symfony\Component\Finder\SplFileInfo $file */
$contains = false, /** @var \Symfony\Component\Finder\SplFileInfo $file */
$priority = 0) {}
/** @var Content[] $searchresults */
        private function search(/** @var Content[] $searchresults */
$query, /** @var Content[] $searchresults */
$withRecord = false) {}
        private function matches($sentence, $word) {}
        private function compareOptions($a, $b) {}
        private function generatePath($route, $parameters = [ ]) {}
    }

    /**
     * Handles creating the Application with .bolt.[yml|php] configuration.
     *
     * This does not handle autoloading.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Bootstrap {
        public static function run($rootPath) {}
    }

    /**
     * Class for our config object.
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     *
     * @author Bob den Otter, bob@twokings.nl
     */
    class Config {
        /** @var Silex\Application */
        protected $app;
        /** @var array */
        protected $data;
        /** @var array */
        protected $defaultConfig;
        /** @var array */
        protected $reservedFieldNames;
        /** @var int */
        protected $cachetimestamp;
        /**
         * Use {@see Config::getFields} instead.
         * Will be made protected in Bolt 3.0.
         *
         * @var \Bolt\Storage\Field\Manager
         */
        public $fields;
        /** @var bool @deprecated Deprecated since 3.2, to be removed in 4.0 */
        public $notify_update;
        /** @var array */
        private $exceptions;
        /** @var JsonFile */
        private $cacheFile;
        private $passed;

        public function __construct(Silex\Application $app) {}
        /**
         * @return array|null
         */
        public function getExceptions() {}
        public function initialize() {}
        /**
         * Checks if cache is valid for theme; if not invalidate and load it.
         */
        private function loadTheme() {}
        protected function parseConfigYaml($filename, DirectoryInterface $directory = null) {}
        public function set($path, $value) {}
        public function get($path, $default = null) {}
        public function doReplacements($value = null) {}
        /**
         * Load the configuration from the various YML files.
         *
         * @return array
         */
        public function getConfig() {}
        /**
         * Read and parse the config.yml and config_local.yml configuration files.
         *
         * @return array
         */
        protected function parseGeneral() {}
        protected function parseTaxonomy(array $taxonomies = null) {}
        protected function parseContentTypes(array $generalConfig) {}
/** @deprecated Deprecated since 3.0, to be removed in 4.0. (config.yml was the old filename) */
        protected function parseTheme(/** @deprecated Deprecated since 3.0, to be removed in 4.0. (config.yml was the old filename) */
DirectoryInterface $themeDir, /** @deprecated Deprecated since 3.0, to be removed in 4.0. (config.yml was the old filename) */
array $generalConfig) {}
        /**
         * This method pulls the templatefields config from the theme config and appends it
         * to the contenttypes configuration.
         */
        protected function parseTemplatefields() {}
        protected function parseContentType($key, $contentType, $generalConfig) {}
        protected function parseFieldsAndGroups(array $fields, array $generalConfig) {}
        private function parseFieldRepeaters(array $fields, $key) {}
        protected function parseDatabase(array $options) {}
        protected function parseSqliteOptions(array $config) {}
        protected function parseConnectionParams($params, $defaults = [ ]) {}
        /**
         * Sanity check for slashes in in taxonomy slugs.
         *
         * @return bool
         */
        private function checkTaxonomy() {}
        /**
         * Sanity checks for doubles in in contenttypes.
         *
         * @return bool
         */
        public function checkConfig() {}
        /**
         * A getter to access the fields manager.
         *
         * @return \Bolt\Storage\Field\Manager
         **/
        public function getFields() {}
        /**
         * Assume sensible defaults for a number of options.
         */
        protected function getDefaults() {}
        /**
         * Build an array of Twig paths.
         *
         * @return string[]
         */
        public function getTwigPath() {}
        /**
         * @deprecated Deprecated since 3.3, to be removed in 4.0.
         */
        public function setCKPath() {}
        /**
         * Attempt to load cached configuration files.
         *
         * @throws RuntimeException
         *
         * @return array|null
         */
        protected function loadCache() {}
        /** @var \Bolt\Filesystem\Filesystem $configFs */
        private function isCacheValid() {}
        /**
         * Check if the cache is still valid with theme file as well.
         *
         * @return bool
         */
        private function isThemeCacheValid() {}
        /**
         * Invalidate (remove) the cache file.
         */
        private function invalidateCache() {}
        public function cacheConfig($force = false) {}
        /**
         * @deprecated Deprecated since 3.2, to be removed in 4.0. Now handled in a listener.
         */
        protected function saveCache() {}
        /**
         * @deprecated Deprecated since 3.2, to be removed in 4.0.
         */
        protected function checkValidCache() {}
        public function getTimestamp($when) {}
        /**
         * Get the current timestamp, corrected to the timezone.
         *
         * @return string Current timestamp
         */
        public function getCurrentTimestamp() {}
        /**
         * Use {@see Zone} instead with a {@see Request}.
         *
         * Going forward, decisions determined by current request
         * should be done in an app or route middleware.
         * Application should be setup agnostic to the current request.
         *
         * Route middlewares apply only to a certain route or group of routes.
         * See {@see \Bolt\Controller\Async\AsyncBase::before} for an example.
         *
         * App middlewares apply to all routes.
         * See classes in \Bolt\EventListener for examples of these.
         * These middlewares could also be filtered by checking for Zone inside of listener.
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         *
         * @return string
         */
        public function getWhichEnd() {}
        /** @var \Bolt\EventListener\ZoneGuesser $guesser */
        private function determineZone() {}
    }

    /**
     * Class to handle things dealing with users.
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     */
    class Users {
        /** @internal Visibility will be changed to 'private' for these two in Bolt 3.0 */
        public $users;
        public $currentuser;
        /** @var Repository\UsersRepository */
        protected $repository;
        /** @var \Silex\Application $app */
        private $app;

        public function __construct(Silex\Application $app) {}
        /**
         * @return Repository\UsersRepository
         */
        private function getRepository() {}
        public function saveUser($user) {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function isValidSession() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function checkValidSession() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function getAntiCSRFToken() {}
        public function checkAntiCSRFToken($token = '') {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function getActiveSessions() {}
/** @var Repository\AuthtokenRepository $authtokenRepository */
        public function deleteUser(/** @var Repository\AuthtokenRepository $authtokenRepository */
$id) {}
        /**
         * Create a stub for a new/empty user.
         *
         * @return array
         */
        public function getEmptyUser() {}
        /**
         * Get an array with the current users.
         *
         * @return array[]
         */
        public function getUsers() {}
        /**
         * Test to see if there are users in the user table.
         *
         * @return int
         */
        public function hasUsers() {}
        public function getUser($userId) {}
        /**
         * Get the current user as an array.
         *
         * @return array
         */
        public function getCurrentUser() {}
        public function getCurrentUserProperty($property) {}
        /**
         * Get the username of the current user.
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         *
         * @return string
         */
        public function getCurrentUsername() {}
        public function isEnabled($id = false) {}
        public function setEnabled($id, $enabled = true) {}
        public function hasRole($id, $role) {}
        public function addRole($id, $role) {}
        public function removeRole($id, $role) {}
        public function filterManipulatableRoles($id, array $newRoles) {}
        /**
         * Check for a user with the 'root' role.
         *
         * There should always be at least one If there isn't we promote the current
         * user.
         *
         * @return bool
         */
        public function checkForRoot() {}
        public function isAllowed($what, $contenttype = null, $contentid = null) {}
        public function isContentStatusTransitionAllowed($fromStatus, $toStatus, $contenttype, $contentid = null) {}
        private function canonicalizeFieldValue($fieldname, $fieldvalue) {}
        public function checkAvailability($fieldname, $value, $currentid = 0) {}
        public function updateUserLogin($user) {}
    }

    /**
     * Simple cron dispatch class for Bolt.
     *
     * To create a listener you need to something similar in your class:
     *      use Bolt\Events\CronEvents;
     *      $this->app['dispatcher']->addListener(CronEvents::CRON_INTERVAL, [$this, 'myJobCallbackMethod']);
     *
     * CRON_INTERVAL should be replace with one of the following:
     *      * CRON_HOURLY
     *      * CRON_DAILY
     *      * CRON_WEEKLY
     *      * CRON_MONTHLY
     *      * CRON_YEARLY
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Cron extends \symfony\component\eventdispatcher\event {
        /** @var array */
        public $lastruns;
        /** @var \Bolt\Storage\Repository\CronRepository */
        protected $repository;
        /** @var \Silex\Application */
        private $app;
        /** @var \Symfony\Component\Console\Output\OutputInterface */
        private $output;
        /** @var array Passed in console paramters. */
        private $param;
        /** @var \DateTime The start of the execution time for this cron instance. */
        private $runtime;
        /** @var \DateTime */
        private $cronHour;
        /** @var array The next elegible run time for each interim. */
        private $jobs;

        public function __construct(Silex\Application $app, OutputInterface $output = null) {}
        public function execute($param = [ ]) {}
/** @var Entity\Cron $cronEntity */
        private function executeSingle(/** @var Entity\Cron $cronEntity */
CronEvent $event, /** @var Entity\Cron $cronEntity */
$interimName, /** @var Entity\Cron $cronEntity */
array $data) {}
        private function isExecutable($interimName) {}
        /**
         * Get our configured hour and convert it to UNIX time.
         */
        private function getScheduleThreshold() {}
        /**
         * Query table for last run time of each interim.
         */
        private function getRunTimes() {}
        private function getNextRunTime($interimName, Entity\Cron $runEntity) {}
        private function notify($message) {}
        private function handleError(\Exception $e, $interimName) {}
    }

    /**
     * Bolt's current version.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class Version {
        const VERSION = '3.5.7';

        /**
         * Whether this release is a stable one.
         *
         * @return bool
         */
        public static function isStable() {}
        public static function compare($version, $operator) {}
        /**
         * Returns a version formatted for composer.
         *
         * @return string
         */
        public static function forComposer() {}
        /**
         * @deprecated since 3.0, to be removed in 4.0.
         *
         * @return string|null
         */
        public static function name() {}
        /**
         * Must not be instantiated.
         */
        private function __construct() {}
    }

    /**
     * Stack for remembering the most recently used files for the current user.
     *
     * @author Bob den Otter, bob@twokings.nl
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Stack implements \countable, \iteratoraggregate {
        const MAX_ITEMS = 7;

        /** @var Filesystem\Matcher */
        private $matcher;
        /** @var Users */
        private $users;
        /** @var SessionInterface */
        private $session;
        /** @var string[] */
        private $acceptedFileTypes;
        /** @var FileInterface[] */
        private $files;
        /** @var bool */
        private $initialized;

        public function __construct(Filesystem\Matcher $matcher, Users $users, SessionInterface $session, $acceptedFileTypes) {}
        public function add($filename, FileInterface $removed = null) {}
        public function delete($filename) {}
        public function contains($filename) {}
        public function isStackable($filename) {}
        public function getList(array $types = [ ]) {}
        /**
         * {@inheritdoc}
         */
        public function getIterator() {}
        /**
         * {@inheritdoc}
         */
        public function count() {}
        /**
         * Initialize file list for current user, either from session or database.
         */
        private function initialize() {}
        /**
         * Persist the contents of the current stack to the session, as well as the database.
         */
        private function persist() {}
        private function hydrateList($paths) {}
        /**
         * Returns the list of files as full paths.
         *
         * @return string[]
         */
        private function persistableList() {}
    }

    /**
     * Wrapper around Twig's render() function. Handles the following responsibilities:.
     *
     * - Calls twig's render
     * - Stores a page in cache, if needed
     * - Store template (partials) in cache, if needed
     * - Fetches pages or template (partials) from cache
     *
     * @author Bob den Otter, bob@twokings.nl
     *
     * @deprecated Since 3.3, will be removed in 4.0.
     */
    class Render {
        private $app;
        /** @var bool */
        private $safe;

        public function __construct(Silex\Application $app, $safe = false) {}
        public function __get($property) {}
        public function __set($property, $value) {}
        public function render($templateName, $context = [ ], $globals = [ ]) {}
        public function hasTemplate($template) {}
        /**
         * Retrieve a fully cached page from cache.
         *
         * @deprecated Deprecated since 3.1, to be removed in 4.0. @see \Silex\HttpCache
         *
         * @return \Symfony\Component\HttpFoundation\Response|bool
         */
        public function fetchCachedRequest() {}
        public function cacheRequest(Response $response) {}
        /**
         * Get the duration (in seconds) for the cache.
         *
         * @deprecated Deprecated since 3.1, to be removed in 4.0. @see \Silex\HttpCache
         *
         * @return int
         */
        public function cacheDuration() {}
        public function checkCacheConditions($type = 'template', $checkoverride = false) {}
    }

    /**
     * A class for choosing whichever template should be used.
     */
    class TemplateChooser {
        /** @var Config */
        private $config;

        public function __construct(Config $config) {}
        public function homepage($content) {}
        public function record($record, $data = null) {}
        public function listing($contenttype) {}
        public function taxonomy($taxonomyslug) {}
        /**
         * Select a search template.
         *
         * @return string[]
         */
        public function search() {}
        /**
         * Select a template to use for the "maintenance" page.
         *
         * @return string[]
         */
        public function maintenance() {}
    }

    /**
     * Class Pager.
     *
     * @author Rix Beck <rix@neologik.hu>
     *
     * @deprecated
     */
    class Pager extends \arrayobject {
        public $for;
        public $count;
        public $totalpages;
        public $current;
        public $showing_from;
        public $showing_to;
        public $link;
        protected $app;

        public function __construct($array, Silex\Application $app) {}
        /**
         * Used for calling from template to build up right paginated URL link.
         *
         * @return string
         */
        public function makelink() {}
        public static function makeParameterId($suffix) {}
    }

}

namespace Bolt\Configuration {
    /**
     * Allows (simple) modifications of Bolt .yml files.
     *
     * @author Bob den Otter <bob@twokings.nl>
     **/
    class YamlUpdater {
        /** @var FileInterface */
        private $file;
        /** @var MutableBag|string[] Contains a line of the file per index. */
        private $lines;
        /** @var MutableBag the parsed yml file */
        private $parsed;

        public function __construct($file) {}
        public function parse(FileInterface $file) {}
        public function get($key, $throwEx = false) {}
        public function change($key, $value, $backup = true) {}
        public function prepareValue($value) {}
        protected function save($backup) {}
    }

    /**
     * Class ConfigurationProxy a simple wrapper that allows passing a pointer to the eventual
     * compiled and validated configuration.
     *
     * @internal
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class ConfigurationValueProxy implements \arrayaccess, \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var mixed|null */
        protected $data;
        /** @var Config */
        protected $config;
        /** @var string */
        protected $path;
        /** @var mixed|null */
        protected $default;
        /** @var bool */
        protected $checked;

        public function __construct(Config $config, $path, $default = null) {}
        /**
         *{@inheritdoc}
         */
        public static function getSubscribedEvents() {}
        /**
         * Get the data of the loaded config.
         *
         * @return array
         */
        public function getData() {}
        public function offsetExists($offset) {}
        /**
         * Initialize the configuration value.
         */
        public function initialize() {}
        public function offsetGet($offset) {}
        public function offsetSet($offset, $value) {}
        public function offsetUnset($offset) {}
        /**
         * Kernel request event callback.
         */
        public function onKernelRequest() {}
    }

    /**
     * Inherits from default and adds some specific checks for composer installs.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     **/
    class ComposerChecks extends \bolt\configuration\lowlevelchecks {
        public $composerSuffix;

        public function __construct($config = null) {}
        public function checkConfig() {}
        public function checkCache() {}
        public function checkDatabase() {}
        public function checkPublicAssets() {}
        protected function checkSummary() {}
        public function checkDir($location) {}
    }

    /**
     * Left as a blank extension of ResourceManager for now, this semantically
     * represents a default configuration for a Bolt application.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class Standard extends \bolt\configuration\resourcemanager {
        public function __construct($loader, Request $request = null, PathResolverFactory $pathResolverFactory = null) {}
    }

    /**
     * Bolt\Configuration\ResourceManager::getPaths() is proxied here, which used to return a simple array.
     *
     * This allows us to still use getPath, getUrl, and getRequest methods which have custom logic in them to maintain BC.
     *
     * @deprecated since 3.0, to be removed in 4.0.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class LazyPathsProxy extends \bolt\configuration\pathsproxy {
        /** @var callable */
        private $factory;

        public function __construct(callable $factory) {}
        public function offsetGet($offset) {}
    }

    /**
     * A Base Class to handle resource management of paths and urls within a Bolt App.
     *
     * Intended to simplify the ability to override resource location
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     *
     * @author Ross Riley, riley.ross@gmail.com
     */
    class ResourceManager {
        /** @var \Silex\Application */
        public $app;
        /** @var string */
        public $urlPrefix;
        /** @var \Eloquent\Pathogen\AbsolutePathInterface */
        protected $root;
        /** @var Request */
        protected $requestObject;
        /** @var AbsolutePathInterface[] */
        protected $paths;
        /** @var array */
        protected $urls;
        /** @var string[] */
        protected $request;
        /** @var LowLevelChecks|null */
        protected $verifier;
        /** @var \Composer\Autoload\ClassLoader|null */
        protected $classLoader;
        /** @var \Eloquent\Pathogen\FileSystem\Factory\FileSystemPathFactory */
        protected $pathManager;
        /**
         * @deprecated since 3.0, to be removed in 4.0.
         *
         * @var PathsProxy
         */
        private $pathsProxy;
        /** @var bool */
        private $requestInitialized;
        /** @var bool */
        private $configInitialized;
        /** @var PathResolver|null */
        private $pathResolver;
        /** @var PathResolverFactory */
        private $pathResolverFactory;
        private $disableApacheChecks;

        public function __construct(\ArrayAccess $container) {}
        public function useLoader(ClassLoader $loader) {}
        public function setApp(Application $app) {}
        public function disableApacheChecks() {}
        public function setPath($name, $value, $applyToResolver = true) {}
        public function getPath($name) {}
        public function getPathObject($name) {}
        public function hasPath($name) {}
        public function getPathResolverFactory() {}
        public function setPathResolver(PathResolver $pathResolver) {}
        public function setUrl($name, $value) {}
        public function getUrl($name, $includeBasePath = true) {}
        public function setRequest($name, $value) {}
        public function getRequest($name) {}
        /**
         * Just don't use this.
         *
         * @deprecated since 3.0, to be removed in 4.0.
         *
         * @return PathsProxy
         */
        public function getPaths() {}
        public function initializeRequest(Application $app, Request $request = null) {}
        /**
         * Takes a loaded config array and uses it to initialize settings that depend on it.
         */
        public function initializeConfig() {}
        public function initialize() {}
        public function setThemePath($generalConfig) {}
        /**
         * @deprecated Deprecated since 3.1, to be removed in 4.0.
         */
        public function verify() {}
        /**
         * @deprecated Deprecated since 3.1, to be removed in 4.0.
         */
        public function verifyDb() {}
        /**
         * Get the LowlevelChecks object.
         *
         * @return LowlevelChecks
         */
        public function getVerifier() {}
        public function setVerifier($verifier) {}
        /**
         * Get the Composer autoload ClassLoader.
         *
         * @return ClassLoader
         */
        public function getClassLoader() {}
        /**
         * Get the Bolt\Application object.
         *
         * @throws \RuntimeException
         *
         * @return \Silex\Application
         */
        public static function getApp() {}
        public function findRelativePath($frompath, $topath) {}
        private function callerNotSelfOrPathsProxy($index = 1) {}
        private function callerNotSelfOrChild($index = 1) {}
        private function callerNotSelf($index = 1) {}
        private function callerNot(array $files, $index = 1) {}
    }

    /**
     * A class to resolve and manage paths. Paths defined here are allowed to have variables within them.
     * For example: "files" folder is within the web directory so it is defined as "%web%/files". This allows
     * the web directory to be changed and the files path does not have to be redefined.
     *
     * This functionality could be added within ResourceManager, but given that 90% of that code is deprecated I figured
     * it would be better to create this separately.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class PathResolver {
        /** @var array */
        protected $paths;
        /** @var array */
        private $resolving;

        /**
         * Default paths for Bolt installation.
         *
         * @return array
         */
        public static function defaultPaths() {}
        public function __construct($root, $paths = [ ]) {}
        public function define($name, $path) {}
        public function resolve($path, $absolute = true) {}
        public function raw($name) {}
        /**
         * Returns the names of all paths.
         *
         * @return array
         */
        public function names() {}
        /**
         * Returns all path names and their raw definitions.
         *
         * @return array
         */
        protected function rawAll() {}
        private function normalizeName($name) {}
    }

    /**
     * Configuration for a Bolt application Composer install.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class Composer extends \bolt\configuration\standard {
        public function __construct($path, Request $request = null, PathResolverFactory $pathResolverFactory = null) {}
        public function getVerifier() {}
    }

    /**
     * Bolt\Configuration\ResourceManager::getPaths() is proxied here, which used to return a simple array.
     *
     * This allows us to still use getPath, getUrl, and getRequest methods which have custom logic in them to maintain BC.
     *
     * @deprecated since 3.0, to be removed in 4.0.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class PathsProxy implements \arrayaccess {
        /** @var ResourceManager */
        protected $resources;

        public function __construct(ResourceManager $resources) {}
        public function offsetExists($offset) {}
        public function offsetGet($offset) {}
        public function offsetSet($offset, $value) {}
        public function offsetUnset($offset) {}
    }

    /**
     * Forwards all relevant paths to PathResolver.
     *
     * @author Carson Full <carsonfull@gmail.com>
     *
     * @deprecated since 3.3, to be removed in 4.0.
     */
    class ForwardToPathResolver extends \bolt\configuration\resourcemanager {
        public function __construct(\ArrayAccess $container) {}
    }

    /**
     * This acts as a staging area for PathResolver so that it doesn't have to be created until it is needed.
     * It is basically only to bridge ResourceManager to PathResolver.
     *
     * @deprecated since 3.3, will be removed in 4.0.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class PathResolverFactory {
        /** @var string */
        private $rootPath;
        /** @var array */
        private $paths;

        /**
         * Constructor.
         */
        public function __construct() {}
        public function setRootPath($rootPath) {}
        /**
         * @return bool
         */
        public function hasRootPath() {}
        /**
         * @return string
         */
        public function getRootPath() {}
        public function setPaths(array $paths) {}
        public function addPaths(array $paths) {}
        /**
         * @return array
         */
        public function getPaths() {}
        /**
         * Create PathResolver.
         *
         * @return PathResolver
         */
        public function create() {}
    }

    /**
     * Environment set up and management class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Environment {
        /** @var Cache */
        protected $cache;
        /** @var Pimple */
        protected $actions;
        /** @var Filesystem */
        protected $filesystem;
        /** @var string */
        protected $boltPath;
        /** @var string */
        protected $boltAssetsPath;
        /** @var string */
        protected $appPath;
        /** @var string */
        protected $viewPath;
        /** @var string */
        protected $boltVersion;
        /** @var bool */
        private $versionChange;

        public function __construct($boltPath, $boltAssetsPath, Cache $cache, Pimple $actions, $boltVersion) {}
        /**
         * Has a Bolt version change been detected.
         *
         * @return bool
         */
        public function hasVersionChange() {}
        /**
         * Check Bolt's version against a cached key. If there is a change we flush
         * the cache data and if required synchronise asset directories.
         */
        public function checkVersion() {}
        /**
         * Perform a synchronisation of files in specific app/view/ subdirectories.
         *
         * @return array|null
         */
        public function syncAssets() {}
        protected function syncAssetsDirectory($dir) {}
        /**
         * Check if the cache version matches Bolt's current version.
         *
         * @return bool TRUE  - versions match
         *              FALSE - versions don't match
         */
        protected function checkCacheVersion() {}
        /** @var DumpAutoload $autoload */
        protected function updateAutoloader() {}
        /**
         * Write our version string out to given cache directory.
         */
        protected function updateCacheVersion() {}
        private function getVersionFileName() {}
    }

    /**
     * Sorts PathResolver paths based on their dependencies.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class PathDependencySorter {
        /** @var PathResolver */
        private $resolver;
        /** @var array */
        private $resolving;

        public function __construct(PathResolver $resolver) {}
        /**
         * Returns the list of path names sorted by least dependent first.
         *
         * @return string[]
         */
        public function getSortedNames() {}
        /**
         * Returns path names with their dependencies.
         *
         * @return array [name => dependencies]
         */
        private function getDependencies() {}
        private function getDependenciesRecursive($path, $dependencies = [ ]) {}
    }

    /**
     * @deprecated Deprecated since 3.1, to be removed in 4.0.
     */
    class LowlevelChecks {
        public $config;
        private $disableApacheChecks;
        public $checks;
        public $configChecks;
        public $magicQuotes;
        public $safeMode;
        public $isApache;
        public $mysqlLoaded;
        public $postgresLoaded;
        public $sqliteLoaded;

        public function __construct($config = null) {}
        public function __get($property) {}
        public function __set($property, $value) {}
        public function removeCheck($check) {}
        public function addCheck($check, $top = false) {}
        /**
         * Perform the checks.
         */
        public function doChecks() {}
        public function checkMagicQuotes() {}
        public function checkSafeMode() {}
        public function assertWritableDir($path) {}
        /**
         * Check if the cache dir is present and writable.
         */
        public function checkCache() {}
        /**
         * This check looks for the presence of the .htaccess file inside the web directory.
         * It is here only as a convenience check for users that install the basic version of Bolt.
         *
         * If you see this error and want to disable it, call $config->getVerifier()->disableApacheChecks();
         * inside your bootstrap.php file, just before the call to $config->verify().
         **/
        public function checkApache() {}
        /**
         * Perform the check for the database folder. We do this separately, because it can only
         * be done _after_ the other checks, since we need to have the $config, to see if we even
         * _need_ to do this check.
         */
        public function doDatabaseCheck() {}
        public function disableApacheChecks() {}
        protected function lowlevelConfigFix($name) {}
    }

}

namespace Bolt\Configuration\Check {
    /**
     * Checks for PHP extension configuration.
     *
     * @deprecated Since 3.4, to be removed in 4.0
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class PhpExtensions extends \bolt\configuration\check\basecheck implements \bolt\configuration\check\configurationcheckinterface {
        /** @var array */
        protected $options;

        public function setOptions(array $options) {}
        /**
         * {@inheritdoc}
         */
        public function runCheck() {}
    }

    /**
     * A container class for a check result.
     *
     * @deprecated Since 3.4, to be removed in 4.0
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Result implements \jsonserializable {
        /** @var bool */
        protected $pass;
        /** @var string */
        protected $message;
        /** @var \Exception */
        protected $exception;

        public function __construct() {}
        /**
         * Check if the result is a pass or fail.
         *
         * @return bool
         */
        public function isPass() {}
        /**
         * Set a pass condition for the check.
         *
         * @return \Bolt\Configuration\Check\Result
         */
        public function pass() {}
        /**
         * Set a fail condition for the check.
         *
         * @return \Bolt\Configuration\Check\Result
         */
        public function fail() {}
        /**
         * Check if the result contains an exception.
         *
         * @return bool
         */
        public function isException() {}
        public function setMessage($message) {}
        /**
         * Get the message that describes the check result.
         *
         * @return string
         */
        public function getMessage() {}
        public function setException(\Exception $exception) {}
        /**
         * Get the exception that occurred during the check.
         *
         * @return \Exception
         */
        public function getException() {}
        /**
         * {@inheritdoc}
         */
        public function jsonSerialize() {}
    }

    /**
     * Checks for email configuration.
     *
     * @deprecated Since 3.4, to be removed in 4.0
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class EmailSetup extends \bolt\configuration\check\basecheck implements \bolt\configuration\check\configurationcheckinterface {
        /** @var array */
        protected $options;

        public function setOptions(array $options) {}
        /**
         * {@inheritdoc}
         */
        public function runCheck() {}
        protected function checkMailOptions() {}
        /**
         * Render HTML for the sample email.
         *
         * @return string
         */
        private function getEmailHtml() {}
        private function sendMessage($senderMail, $senderName, $mailhtml) {}
    }

    /**
     * Base class for checks.
     *
     * @deprecated Since 3.4, to be removed in 4.0
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class BaseCheck {
        /** @var Application */
        protected $app;
        /** @var array */
        protected $options;
        /** @var Result[] */
        protected $results;

        public function __construct(Application $app) {}
        /**
         * Getter for the result container.
         *
         * @return \Bolt\Configuration\Check\Result
         */
        protected function createResult() {}
    }

    /**
     * Checks for writeable directories.
     *
     * @deprecated Since 3.4, to be removed in 4.0
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DirectoryAccess extends \bolt\configuration\check\basecheck implements \bolt\configuration\check\configurationcheckinterface {
        /** @var array */
        protected $options;

        public function setOptions(array $options) {}
        /**
         * {@inheritdoc}
         */
        public function runCheck() {}
    }


    /**
     * System configuration check interface.
     *
     * @deprecated Since 3.4, to be removed in 4.0
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface ConfigurationCheckInterface {
        function setOptions(array $options) ;
        /**
         * Execute the test.
         *
         * @return \Bolt\Configuration\Check\Result
         */
        function runCheck() ;
    }

}

namespace Bolt\Configuration\Validation {
    /**
     * System validator.
     *
     * @internal For BC. Use of this class should not include use of LowlevelChecks
     *           methods/properties.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Validator implements \bolt\configuration\validation\validatorinterface {
        const CHECK_CONFIG = 'configuration';
        const CHECK_DATABASE = 'database';
        const CHECK_APACHE = 'apache';
        const CHECK_CACHE = 'cache';

        /** @var Config */
        private $configManager;
        /** @var PathResolver */
        private $pathResolver;
        /** @var FlashLoggerInterface */
        private $flashLogger;
        /** @var array */
        private $check;

        public function __construct(Config $config, PathResolver $pathResolver, FlashLoggerInterface $flashLogger) {}
        public function add($checkName, $className, $prepend = false) {}
        public function has($checkName) {}
        public function remove($checkName) {}
        public function check($checkName) {}
        /**
         * Run system installation checks.
         */
        public function checks() {}
/** @var ValidationInterface $validator */
        private function getValidator(/** @var ValidationInterface $validator */
$className, /** @var ValidationInterface $validator */
$constructorArgs) {}
    }

    /**
     * Database validation check.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Database implements \bolt\configuration\validation\configawareinterface, \bolt\configuration\validation\validationinterface, \bolt\configuration\validation\pathresolverawareinterface {
        /** @var PathResolver */
        private $pathResolver;
        /** @var Config */
        private $config;

        /**
         * {@inheritdoc}
         */
        public function check() {}
        public function setPathResolver(PathResolver $pathResolver) {}
        public function setConfig(Config $config) {}
        protected function doDatabaseSqliteCheck(array $dbConfig) {}
    }

    /**
     * Cache validation check.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Cache implements \bolt\configuration\validation\validationinterface, \bolt\configuration\validation\pathresolverawareinterface {
        /** @var PathResolver */
        private $pathResolver;

        /**
         * {@inheritdoc}
         */
        public function check() {}
        public function setPathResolver(PathResolver $pathResolver) {}
    }

    /**
     * Apache .htaccess validation check.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Apache implements \bolt\configuration\validation\validationinterface, \bolt\configuration\validation\pathresolverawareinterface {
        /** @var PathResolver */
        private $pathResolver;

        /**
         * This check looks for the presence of the .htaccess file inside the web directory.
         * It is here only as a convenience check for users that install the basic version of Bolt.
         *
         * {@inheritdoc}
         */
        public function check() {}
        public function setPathResolver(PathResolver $pathResolver) {}
    }

    /**
     * Configuration parameters validation check.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Configuration implements \bolt\configuration\validation\validationinterface, \bolt\configuration\validation\configawareinterface, \bolt\configuration\validation\flashloggerawareinterface {
        /** @var Config */
        private $config;
        /** @var FlashLoggerInterface */
        private $flashLogger;

        /**
         * {@inheritdoc}
         */
        public function check() {}
        public function setConfig(Config $config) {}
        public function setFlashLogger(FlashLoggerInterface $flashLogger) {}
    }


    /**
     * Validation check interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface ValidationInterface {
        /**
         * Perform the validation check.
         */
        function check() ;
    }

    /**
     * Interface for validation checks that require FlashLoggerInterface.
     *
     * @internal do not use
     *
     * @deprecated Deprecated since 3.2, to be removed in 4.0.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface FlashLoggerAwareInterface {
        function setFlashLogger(FlashLoggerInterface $flashLogger) ;
    }

    /**
     * Interface for validation checks that require ResourceManager.
     *
     * @internal do not use
     *
     * @deprecated Deprecated since 3.1, to be removed in 4.0.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface PathResolverAwareInterface {
        function setPathResolver(PathResolver $pathResolver) ;
    }

    /**
     * Validator interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface ValidatorInterface {
        function add($checkName, $className, $prepend = false) ;
        function has($checkName) ;
        function remove($checkName) ;
        function check($checkName) ;
        /**
         * Perform all checks.
         */
        function checks() ;
    }

    /**
     * Interface for validation checks that require Config.
     *
     * @internal do not use
     *
     * @deprecated Deprecated since 3.1, to be removed in 4.0.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface ConfigAwareInterface {
        function setConfig(Config $config) ;
    }

}

namespace Bolt\Form {
    /**
     * Symfony Forms extension to provide types, type extensions and a guesser.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class BoltExtension extends \symfony\component\form\abstractextension {
        /** @var Application */
        protected $app;

        public function __construct(Application $app) {}
        /**
         * {@inheritdoc}
         */
        protected function loadTypes() {}
    }

}

namespace Bolt\Form\FormType {
    /**
     * Bolt new user editing form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UserNewType extends \bolt\form\formtype\abstractusertype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
    }

    /**
     * User form DTO.
     *
     * @internal
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class UserData {
        /** @var int */
        private $id;
        /** @var string */
        private $userName;
        /** @var string */
        private $password;
        /** @var string */
        private $email;
        /** @var string */
        private $displayName;
        /** @var \DateTime */
        private $lastSeen;
        /** @var string */
        private $lastIp;
        /** @var array */
        private $stack;
        /** @var bool */
        private $enabled;
        /** @var array */
        private $roles;

        /**
         * Constructor.
         */
        private function __construct() {}
        public static function createFromEntity(Entity\Users $entity) {}
        public function applyToEntity(Entity\Users $entity, ListMutator $mutator = null) {}
        /**
         * @return int
         */
        public function getId() {}
        /**
         * @return string
         */
        public function getUserName() {}
        public function setUserName($userName) {}
        /**
         * @return string
         */
        public function getPassword() {}
        public function setPassword($password) {}
        /**
         * @return string
         */
        public function getEmail() {}
        public function setEmail($email) {}
        /**
         * @return string
         */
        public function getDisplayName() {}
        public function setDisplayName($displayName) {}
        /**
         * @return \DateTime
         */
        public function getLastSeen() {}
        public function setLastSeen($lastSeen) {}
        /**
         * @return string
         */
        public function getLastIp() {}
        public function setLastIp($lastIp) {}
        /**
         * @return array
         */
        public function getStack() {}
        public function setStack($stack) {}
        /**
         * @return bool
         */
        public function isEnabled() {}
        public function setEnabled($enabled) {}
        /**
         * @return array
         */
        public function getRoles() {}
        public function setRoles($roles) {}
    }

    /**
     * Bolt user editing form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UserEditType extends \bolt\form\formtype\abstractusertype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
        public function configureOptions(OptionsResolver $resolver) {}
    }

    /**
     * Bolt base user form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class AbstractUserType extends \symfony\component\form\abstracttype {
        public function configureOptions(OptionsResolver $resolver) {}
        public function buildForm(FormBuilderInterface $builder, array $options) {}
        protected function addId(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addUserName(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addDisplayName(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addEmail(FormBuilderInterface $builder, array $options = [ ], $checkMx = false) {}
        protected function addPassword(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addEnabled(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addLastSeen(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addLastIp(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addRoles(FormBuilderInterface $builder, array $options = [ ]) {}
        protected function addSave(FormBuilderInterface $builder, array $options = [ ]) {}
    }

    /**
     * Bolt user login form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UserLoginType extends \symfony\component\form\abstracttype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
    }

    /**
     * Bolt user profile editing form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UserProfileType extends \bolt\form\formtype\abstractusertype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
    }

    /**
     * Prefill form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class PrefillType extends \symfony\component\form\abstracttype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
        public function configureOptions(OptionsResolver $resolver) {}
    }

    /**
     * ContentType editing form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ContentEditType extends \symfony\component\form\abstracttype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
        public function configureOptions(OptionsResolver $resolver) {}
    }

    /**
     * File upload form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FileUploadType extends \symfony\component\form\abstracttype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
        public function configureOptions(OptionsResolver $resolver) {}
    }

    /**
     * File editing form type.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FileEditType extends \symfony\component\form\abstracttype {
        public function buildForm(FormBuilderInterface $builder, array $options) {}
        public function configureOptions(OptionsResolver $resolver) {}
    }

}

namespace Bolt\Form\Validator\Constraints {
    /**
     * Equivalent field value validator.
     *
     * Validates that a non-NULL value does not match the value of another field.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FieldEqualsValidator extends \symfony\component\validator\constraintvalidator {
        public function validate($value, Constraint $constraint) {}
        protected function addViolation($value, Constraint $constraint) {}
    }

    /**
     * Field containing a value subset validation constraint.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FieldContains extends \symfony\component\validator\constraint {
        public $message;
        public $field;
        public $insensitive;

        /**
         * {@inheritDoc}
         */
        public function getDefaultOption() {}
        /**
         * {@inheritDoc}
         */
        public function getRequiredOptions() {}
    }

    /**
     * Existing entity validator.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExistingEntityValidator extends \symfony\component\validator\constraintvalidator {
        /** @var EntityManager */
        protected $em;

        public function __construct(EntityManager $em) {}
        public function validate($value, Constraint $constraint) {}
/** @var Entity $formEntity */
        protected function hasEntity(/** @var Entity $formEntity */
$value, /** @var Entity $formEntity */
Constraint $constraint) {}
        protected function addViolation($value, Constraint $constraint) {}
    }

    /**
     * Existing entity validation constraint.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExistingEntity extends \symfony\component\validator\constraint {
        const ENTITY_EXISTS_ERROR = '63e88f63-0a35-4ac9-9d55-ad987e1d5c7b';

        static protected $errorNames;
        public $message;
        /** @var string Class name or alias that is passed to getRepository() */
        public $className;
        /** @var array Field names that are OR-ed in the SQL query */
        public $fieldNames;

        public function __construct($options = null) {}
    }

    /**
     * Equivalent field value validation constraint.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FieldEquals extends \symfony\component\validator\constraint {
        public $message;
        public $field;
        public $loose;
        public $insensitive;

        /**
         * {@inheritDoc}
         */
        public function getDefaultOption() {}
        /**
         * {@inheritDoc}
         */
        public function getRequiredOptions() {}
    }

    /**
     * YAML validation constraint.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Yaml extends \symfony\component\validator\constraint {
        public $message;

    }

    /**
     * Field containing a value subset validator.
     *
     * Validates that a non-NULL value does not match part of the value of another
     * field.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FieldContainsValidator extends \symfony\component\validator\constraintvalidator {
        public function validate($value, Constraint $constraint) {}
        protected function addViolation($value, Constraint $constraint) {}
    }

    /**
     * YAML validator.
     *
     * Validates a given input string parses as valid YAML.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class YamlValidator extends \symfony\component\validator\constraintvalidator {
        public function validate($value, Constraint $constraint) {}
        protected function addViolation($error, Constraint $constraint) {}
    }

}

namespace Bolt\Form\FieldType {
    /**
     * User permission/role type.
     *
     * @deprecated Since 3.4. Do not use
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UserRoleType extends \symfony\component\form\abstracttype {
        /** @var Permissions */
        private $permissions;
        /** @var SessionInterface */
        private $session;

        public function __construct(SessionInterface $session, Permissions $permissions) {}
        /**
         * {@inheritdoc}
         */
        public function getParent() {}
        public function configureOptions(OptionsResolver $resolver) {}
        /** @var Token $sessionAuth */
        protected function getRoleAccessCallback() {}
    }

}

namespace Bolt\Form\Resolver {
    /**
     * Choice resolver.
     *
     * @internal DO NOT USE. Will be replaced circa Bolt 3.5.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class Choice {
        /** @var Query */
        private $query;

        public function __construct(Query $query) {}
        public function get(ContentType $contentType, array $templateFields) {}
        private function build(ArrayObject $select, array $fields, $prefix = null) {}
        private function getValues(array $field) {}
        private function getYamlValues(Bag $field) {}
/** @var QueryResultset $entities */
        private function getEntityValues(/** @var QueryResultset $entities */
Bag $field) {}
    }

}

namespace Bolt\Extension {
    /**
     * This wraps an extension and provides additional functionality
     * that does not belong in the extension itself.
     *
     * This works similar to Symfony's ResolvedFormType.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ResolvedExtension {
        /** @var ExtensionInterface */
        protected $innerExtension;
        /** @var bool */
        protected $enabled;
        /** @var PackageDescriptor|null */
        protected $descriptor;

        public function __construct(ExtensionInterface $innerExtension) {}
        /**
         * Returns the wrapped extension.
         *
         * @return \Bolt\Extension\ExtensionInterface
         */
        public function getInnerExtension() {}
        /**
         * Returns a unique identifier for the extension, such as: Vendor/Name.
         *
         * @return string
         */
        public function getId() {}
        /**
         * Returns the extension name (the class short name).
         *
         * @return string
         */
        public function getName() {}
        /**
         * Returns the extension vendor.
         *
         * @return string
         */
        public function getVendor() {}
        /**
         * Returns the extension human friendly name.
         *
         * @return string
         */
        public function getDisplayName() {}
        /**
         * Returns the extension class name.
         *
         * @return string
         */
        public function getClassName() {}
        /**
         * Returns the root directory for the extension.
         *
         * @return \Bolt\Filesystem\Handler\DirectoryInterface
         */
        public function getBaseDirectory() {}
        /**
         * Return the extension's package descriptor.
         *
         * @return PackageDescriptor|null
         */
        public function getDescriptor() {}
        public function setDescriptor(PackageDescriptor $descriptor = null) {}
        /**
         * Returns whether the extension is managed by Bolt. This is the opposite of "bundled".
         *
         * @return bool
         */
        public function isManaged() {}
        /**
         * Returns whether the extension is bundled by user. This is the opposite of "managed".
         *
         * @return bool
         */
        public function isBundled() {}
        /**
         * Check if the extension is enabled.
         *
         * @return bool
         */
        public function isEnabled() {}
        public function setEnabled($enabled) {}
        /**
         * Check if the extension is valid.
         *
         * @return bool
         */
        public function isValid() {}
    }

    /**
     * A Container proxy that prevents non-whitelisted services from being invoked.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ContainerProxy extends \pimple {
        /** @var Container */
        private $container;
        /** @var string[] */
        private $serviceWhiteList;

        public function __construct(Container $container, array $serviceWhiteList = [ ]) {}
        public function offsetSet($id, $value) {}
        public function offsetGet($id) {}
        public function offsetExists($id) {}
        public function offsetUnset($id) {}
        public function raw($id) {}
        public function extend($id, $callable) {}
        /**
         * {@inheritdoc}
         */
        public function keys() {}
    }

    /**
     * Defined some base functionality for extensions.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class AbstractExtension implements \bolt\extension\extensioninterface {
        /** @var Container */
        protected $container;
        /** @var DirectoryInterface|null */
        private $baseDirectory;
        /** @var DirectoryInterface|null */
        private $webDirectory;
        /** @var string */
        private $name;
        /** @var string */
        private $vendor;
        /** @var string */
        private $namespace;

        public function setContainer(Container $container) {}
        public function setBaseDirectory(DirectoryInterface $directory) {}
        /**
         * {@inheritdoc}
         */
        public function getBaseDirectory() {}
        public function setWebDirectory(DirectoryInterface $directory) {}
        /**
         * {@inheritdoc}
         */
        public function getWebDirectory() {}
        /**
         * {@inheritdoc}
         */
        public function getId() {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getVendor() {}
        /**
         * {@inheritdoc}
         */
        public function getNamespace() {}
        /**
         * {@inheritdoc}
         */
        public function getDisplayName() {}
        /**
         * Return the container.
         *
         * Note: This is allows traits to access app without losing coding completion
         *
         * @return Container
         */
        protected function getContainer() {}
    }

    /**
     * Class to manage loading of extensions.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Manager {
        /** @var ResolvedExtension[] */
        protected $extensions;
        /** @var string[] */
        protected $composerNames;
        /** @var FilesystemInterface */
        private $extFs;
        /** @var FilesystemInterface */
        private $webFs;
        /** @var FlashLoggerInterface */
        private $flashLogger;
        /** @var Config */
        private $config;
        /** @var bool */
        private $booted;
        /** @var bool */
        private $loaded;
        /** @var bool */
        private $registered;
        /** @var Application @deprecated */
        private $app;

        public function __construct(FilesystemInterface $extensions, FilesystemInterface $web, FlashLoggerInterface $flashLogger, Config $config) {}
        /**
         * Get all installed extensions.
         *
         * @return ResolvedExtension[]
         */
        public function all() {}
        public function get($id) {}
        public function getResolved($id) {}
        public function add(ExtensionInterface $extension, DirectoryInterface $baseDir = null, DirectoryInterface $webDir = null, $composerName = null) {}
        /**
         * Load a collection of extension classes.
         */
        public function addManagedExtensions() {}
        public function register(Application $app) {}
        public function boot(Application $app) {}
        /**
         * Load the extension autoload.json cache file and build the PackageDescriptor array.
         *
         * @return PackageDescriptor[]
         */
        private function loadPackageDescriptors() {}
/** @var ExtensionInterface $extension */
        private function addManagedExtension(/** @var ExtensionInterface $extension */
PackageDescriptor $descriptor) {}
        private function isClassLoadable($className) {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         *
         * @internal do not use! For legacy support only
         */
        protected function getApp() {}
    }

    /**
     * This will replace current BaseExtension.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class SimpleExtension extends \bolt\extension\abstractextension implements \symfony\component\eventdispatcher\eventsubscriberinterface, \silex\serviceproviderinterface {
    use \bolt\extension\storagetrait, \bolt\extension\twigtrait, \bolt\extension\translationtrait, \bolt\extension\menutrait, \bolt\extension\nuttrait, \bolt\extension\controllertrait, \bolt\extension\controllermounttrait, \bolt\extension\assettrait, \bolt\extension\configtrait;

        public function register(Application $app) {}
        protected function registerServices(Application $app) {}
        protected function subscribe(EventDispatcherInterface $dispatcher) {}
        /**
         * {@inheritdoc}
         */
        public function getServiceProviders() {}
        public function boot(Application $app) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }


    /**
     * ExtensionInterface.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface ExtensionInterface {
        /**
         * Returns the service provider.
         *
         * @return ServiceProviderInterface[]
         */
        function getServiceProviders() ;
        function setContainer(Container $container) ;
        function setBaseDirectory(DirectoryInterface $directory) ;
        /**
         * Returns the root directory for the extension.
         *
         * @throws \LogicException if the extension has not been registered with a base directory
         *
         * @return DirectoryInterface
         */
        function getBaseDirectory() ;
        /**
         * Returns the web directory for the extension.
         *
         * The extension's assets should be installed in this folder.
         *
         * @throws \LogicException if the extension has not been registered with a web directory
         *
         * @return DirectoryInterface
         */
        function getWebDirectory() ;
        function setWebDirectory(DirectoryInterface $directory) ;
        /**
         * Returns a unique identifier for the extension, such as: Vendor/Name.
         *
         * @return string
         */
        function getId() ;
        /**
         * Returns the extension name (the class short name).
         *
         * @return string
         */
        function getName() ;
        /**
         * Returns the extension vendor.
         *
         * @return string
         */
        function getVendor() ;
        /**
         * Returns the human friendly extension name.
         *
         * @return string
         */
        function getDisplayName() ;
    }


    /**
     * Controller mounting trait for an extension.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait ControllerMountTrait {
        /**
         * Returns a list of frontend controllers to mount.
         *
         * <pre>
         *  return [
         *      '/foobar' => new FooController(),
         *  ];
         * </pre>
         *
         * @return ControllerCollection[]|ControllerProviderInterface[]
         */
        protected function registerFrontendControllers() {}
        /**
         * Returns a list of backend controllers to mount.
         *
         * Note: The backend prefix will be automatically prepended to prefixes defined here.
         *
         * <pre>
         *  return [
         *      '/foobar' => new FooController(),
         *  ];
         * </pre>
         *
         * @return ControllerCollection[]|ControllerProviderInterface[]
         */
        protected function registerBackendControllers() {}
        public function onMountControllers(MountEvent $event) {}
        /** @return Container */
        abstract protected function getContainer() ;
    }

    /**
     * Twig function/filter addition and interface functions for an extension.
     *
     * @author Carson Full <carsonfull@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait TwigTrait {
        /** @var TwigFilter[] */
        private $twigFilters;
        /** @var TwigFunction[] */
        private $twigFunctions;
        /** @var string[] */
        private $safeFilterNames;
        /** @var string[] */
        private $safeFunctionNames;
        /** @var bool */
        private $pathAdded;
        /**
         * Returns a list of twig functions to register.
         *
         * Example:
         * <pre>
         *  return [
         *      'foo' => 'fooFunction',
         *      'bar' => ['barFunction', ['is_safe' => ['html']]]
         *  ];
         * </pre>
         *
         * @return array
         */
        protected function registerTwigFunctions() {}
        /**
         * Returns a list of twig filters to register.
         *
         * Example:
         * <pre>
         *  return [
         *      'foo' => 'fooFilter',
         *      'bar' => ['barFilter', ['is_safe' => ['html']]]]
         *  ];
         * </pre>
         *
         * @return array
         */
        protected function registerTwigFilters() {}
        /**
         * Returns a list of relative paths to add to Twig's path array.
         *
         * Example:
         * <pre>
         *  return [
         *      'templates/foo',
         *      'templates/bar' => ['position' => 'prepend', 'namespace' => 'MyExtension']
         *  ];
         * </pre>
         *
         * @return array
         */
        protected function registerTwigPaths() {}
        /**
         * Call this in register method.
         *
         * @internal
         */
        protected function extendTwigService() {}
        private function loadTwig(Environment $twig) {}
/** @var SandboxExtension $sandbox */
        private function updateSandboxPolicy(/** @var SandboxExtension $sandbox */
Environment $twig) {}
        private function addTwigPath($path, array $options = [ ]) {}
        protected function addTwigFunction($name, $callback, $options = [ ]) {}
        protected function addTwigFilter($name, $callback, $options = [ ]) {}
        protected function renderTemplate($template, array $context = [ ]) {}
        /** @return Container */
        abstract protected function getContainer() ;
        /** @return string */
        abstract public function getName() ;
        /** @return DirectoryInterface */
        abstract protected function getBaseDirectory() ;
    }

    /**
     * Database schema modification.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait DatabaseSchemaTrait {
        /**
         * Return a set of tables to register.
         *
         * <pre>
         *  return [
         *      'table_name' => \Fully\Qualified\Table\ClassName::class,
         *  ];
         * </pre>
         *
         * @return string[]
         */
        protected function registerExtensionTables() {}
        /** @var \Doctrine\DBAL\Platforms\AbstractPlatform $platform */
        protected function extendDatabaseSchemaServices() {}
        /** @return Container */
        abstract protected function getContainer() ;
    }

    /**
     * Automatic translation inclusion for an extension.
     *
     * Based upon three factors:
     *  - All translations are in the translations dub-directory of the extension
     *  - Translations are named as en.yml, en_GB.yml, or etc... based upon the locale
     *
     * @author Aaron Valandra <amvalandra@gmail.com>
     */
    trait TranslationTrait {
        /**
         * Call this in register method.
         *
         * @internal
         */
        protected function extendTranslatorService() {}
        /** @var DirectoryInterface $translationDirectory */
        private function loadTranslationsFromDefaultPath() {}
        /** @return Container */
        abstract protected function getContainer() ;
        /** @return DirectoryInterface */
        abstract protected function getBaseDirectory() ;
    }

    /**
     * Admin menu handling trait for an extension.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait MenuTrait {
        /** @var MenuEntry[] */
        private $menuEntries;
        /**
         * Returns a list of menu entries to register.
         *
         * @return MenuEntry[]
         */
        protected function registerMenuEntries() {}
        /** @var MenuEntry $menus */
        protected function extendMenuService() {}
        protected function addMenuEntry($label, $path, $icon = null, $permission = null) {}
        /** @return Container */
        abstract protected function getContainer() ;
    }

    /**
     * Adding nut commands trait for an extension.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait NutTrait {
        protected function registerNutCommands(Container $container) {}
        /**
         * Call this in register method.
         *
         * @internal
         */
        protected function extendNutService() {}
        protected function addConsoleCommand(Command $command) {}
        /** @return Container */
        abstract protected function getContainer() ;
    }

    /**
     * Storage helpers.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait StorageTrait {
        /**
         * Return a list of entities to map to repositories.
         *
         * <pre>
         *  return [
         *      'alias' => [\Entity\Class::class => \Repository\Class::class],
         *  ];
         * </pre>
         *
         * @return array
         */
        protected function registerRepositoryMappings() {}
        /**
         * Call this in register method.
         *
         * @internal
         */
        protected function extendRepositoryMapping() {}
        /** @return Container */
        abstract protected function getContainer() ;
    }

    /**
     * Controller routes trait for an extension.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait ControllerTrait {
        protected function registerFrontendRoutes(ControllerCollection $collection) {}
        protected function registerBackendRoutes(ControllerCollection $collection) {}
        public function onMountRoutes(MountEvent $event) {}
        /** @return Container */
        abstract protected function getContainer() ;
    }

    /**
     * Asset loading trait for an extension.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait AssetTrait {
        /** @var AssetInterface[] */
        private $assets;
        /** @var bool */
        private $loadedAssets;
        /**
         * Returns a list of assets to register. Assets can be a file, snippet, or widget.
         *
         * @return AssetInterface[]
         */
        protected function registerAssets() {}
        /**
         * Call this in register method.
         *
         * @internal
         *
         * @throws \InvalidArgumentException
         */
        protected function extendAssetServices() {}
        /**
         * Merges assets returned from registerAssets() to our list.
         *
         * @throws \InvalidArgumentException
         */
        private function loadAssets() {}
        private function addAsset(AssetInterface $asset) {}
        /**
         * Add jQuery to the output.
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        protected function addJquery() {}
        /**
         * Don't add jQuery to the output.
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        protected function disableJquery() {}
        private function normalizeAsset(FileAssetInterface $asset) {}
        private function isAbsoluteUrl($url) {}
        /** @return Container */
        abstract protected function getContainer() ;
        /** @return string */
        abstract protected function getName() ;
        /** @return DirectoryInterface */
        abstract protected function getBaseDirectory() ;
        /** @return DirectoryInterface */
        abstract protected function getWebDirectory() ;
    }

    /**
     * Config file handling for extensions.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait ConfigTrait {
        /** @var array */
        private $config;
        /**
         * Register a list of Bolt fields.
         *
         * Example:
         * <pre>
         *  return [
         *      new ColourPickField(),
         *  ];
         * </pre>
         *
         * @return FieldInterface[]
         */
        protected function registerFields() {}
        /**
         * Call this in register method.
         */
        protected function extendConfigService() {}
        /**
         * Override this to provide a default configuration,
         * which will be used in the absence of a config file.
         *
         * @return array
         */
        protected function getDefaultConfig() {}
        /**
         * Returns the config for the extension.
         *
         * @return array
         */
        protected function getConfig() {}
        private function addConfig(ParsableInterface $file) {}
        private function copyDistFile(FileInterface $file) {}
        /** @return string */
        abstract public function getName() ;
        /** @return string */
        abstract public function getVendor() ;
        /** @return DirectoryInterface */
        abstract protected function getBaseDirectory() ;
        /** @return Container */
        abstract protected function getContainer() ;
    }

}

namespace Bolt\Logger {
    /**
     * Storage logger for FlashBag messages.
     *
     * This class stores messages in memory until they are ready to be dispatched,
     * as this allows them to be set without a session being started and a cookie
     * set when it might not be valid.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FlashLogger implements \bolt\logger\flashbagattachableinterface, \bolt\logger\flashloggerinterface {
        /** @var array $flash */
        protected $flashes;
        /** @var FlashBagInterface|null */
        protected $flashBag;

        public function danger($message) {}
        public function error($message) {}
        public function info($message) {}
        public function success($message) {}
        public function warning($message) {}
        public function configuration($message) {}
        public function has($type) {}
        public function get($type, array $default = [ ]) {}
        /**
         * {@inheritdoc}
         */
        public function clear() {}
        public function add($type, $message) {}
        /**
         * {@inheritdoc}
         */
        public function keys() {}
        public function attachFlashBag(FlashBagInterface $flashBag) {}
        /**
         * Return whether a FlashBag has been attached.
         *
         * @return bool
         */
        public function isFlashBagAttached() {}
    }

    /**
     * Bolt's logger service class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Manager {
        /** @var Application */
        private $app;
        /** @var \Bolt\Storage\Repository\LogChangeRepository */
        private $changeRepository;
        /** @var \Bolt\Storage\Repository\LogSystemRepository */
        private $systemRepository;

        public function __construct(Application $app, Repository\LogChangeRepository $changeRepository, Repository\LogSystemRepository $systemRepository) {}
        public function trim($log) {}
        public function clear($log) {}
/** @var \Bolt\Pager\PagerManager $manager */
        public function getActivity(/** @var \Bolt\Pager\PagerManager $manager */
$log, /** @var \Bolt\Pager\PagerManager $manager */
$page = 1, /** @var \Bolt\Pager\PagerManager $manager */
$amount = 10, /** @var \Bolt\Pager\PagerManager $manager */
$options = [ ]) {}
        public function getListingData(array $contenttype, $contentId, array $queryOptions) {}
    }


    /**
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface FlashBagAttachableInterface {
        function attachFlashBag(FlashBagInterface $flashBag) ;
        /**
         * Returns whether a FlashBag has been attached.
         *
         * @return bool
         */
        function isFlashBagAttached() ;
    }

    /**
     * FlashBag logger interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface FlashLoggerInterface {
    const CONFIGURATION = 'configuration';
    const SUCCESS = 'success';
    const WARNING = 'warning';
    const ERROR = 'error';
    const INFO = 'info';
    const DANGER = 'danger';
        function danger($message) ;
        function error($message) ;
        function info($message) ;
        function success($message) ;
        function warning($message) ;
        function configuration($message) ;
        function add($type, $message) ;
        function get($type, array $default = [ ]) ;
        function has($type) ;
        /**
         * Clear out messages.
         */
        function clear() ;
        /**
         * Returns a list of all defined types.
         *
         * @return array
         */
        function keys() ;
    }

}

namespace Bolt\Logger\Handler {
    /**
     * Monolog Database handler for system logging.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SystemHandler extends \monolog\handler\abstractprocessinghandler {
        /** @var Application */
        private $app;
        /** @var bool */
        private $initialized;
        /** @var string */
        private $tablename;

        public function __construct(Application $app, $level = Logger::DEBUG, $bubble = true) {}
        public function handle(array $record) {}
/** @var Token $sessionAuth */
        protected function write(/** @var Token $sessionAuth */
array $record) {}
        /**
         * Initialize class parameters.
         */
        private function initialize() {}
    }

    /**
     * Monolog Database handler for record changes (changelog).
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class RecordChangeHandler extends \monolog\handler\abstractprocessinghandler {
        /** @var Application */
        private $app;
        /** @var bool */
        private $initialized;
        /** @var string */
        private $tablename;
        /** @var array */
        private $allowed;

        public function __construct(Application $app, $level = Logger::DEBUG, $bubble = true) {}
        public function handle(array $record) {}
        protected function write(array $record) {}
        protected function checkTransaction(array $context) {}
        protected function getData(array $context) {}
        protected function getContentObject(array $contenttype, array $values) {}
        /**
         * Initialize class parameters.
         */
        private function initialize() {}
        private function diff(array $a, array $b) {}
    }

}

namespace Bolt\Response {
    /**
     * A view that will be rendered with Twig and converted to a response.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class TemplateView {
        /** @var string */
        protected $template;
        /** @var MutableBag */
        protected $context;

        public function __construct($template, $context = [ ]) {}
        /**
         * @return string
         */
        public function getTemplate() {}
        public function setTemplate($template) {}
        /**
         * @return MutableBag
         */
        public function getContext() {}
        public function setContext($context) {}
        /**
         * Don't call directly.
         *
         * @internal
         */
        public function __clone() {}
    }

    /**
     * Template based response.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class TemplateResponse extends \symfony\component\httpfoundation\response {
        /** @var string */
        protected $template;
        /** @var Bag */
        protected $context;

        public function __construct($template, $context = [ ], $content = '', $status = 200, $headers = [ ]) {}
        public static function create($template = '', $context = [ ], $content = '', $status = 200, $headers = [ ]) {}
        /**
         * @return string
         */
        public function getTemplate() {}
        /**
         * @return Bag
         */
        public function getContext() {}
        protected function setContext($context) {}
        /**
         * Don't call directly.
         *
         * @internal
         */
        public function __clone() {}
    }

    /**
     * BoltResponse uses a renderer and context variables
     * to create the response content.
     *
     * @deprecated Deprecated since 3.3, use TemplateResponse instead.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class BoltResponse extends \symfony\component\httpfoundation\response {
        /** @var Template */
        protected $template;
        protected $context;
        protected $compiled;
        /** @var Stopwatch|null */
        protected $stopwatch;

        public function __construct(Template $template, array $context = [ ], array $globals = [ ], $status = 200, $headers = [ ]) {}
        public static function create($template = null, $context = [ ], $globals = [ ], $status = 200, $headers = [ ]) {}
        public function setStopwatch(Stopwatch $stopwatch) {}
        public function setTemplate(Template $template) {}
        public function setContext(array $context) {}
        /**
         * Returns the template.
         *
         * @return Template
         */
        public function getTemplate() {}
        /**
         * Returns the context.
         *
         * @return array
         */
        public function getContext() {}
        /**
         * Gets globals from the template.
         *
         * @return array
         */
        public function getGlobalContext() {}
        public function addGlobals(array $globals) {}
        public function addGlobalContext($name, $value) {}
        /**
         * Gets the name of the main loaded template.
         *
         * @return string
         */
        public function getTemplateName() {}
        /**
         * Returns the Response as a string.
         *
         * @return string The Response as HTML
         */
        public function __toString() {}
        /**
         * Gets HTML content for the response.
         *
         * @return string
         */
        public function getContent() {}
        /**
         * Returns whether the response has been compiled.
         *
         * @return bool
         */
        public function isCompiled() {}
        /**
         * Compiles the template using the context.
         */
        public function compile() {}
        private function handleException(\Exception $e) {}
    }

}

namespace Bolt\Asset {
    /**
     * @internal
     * @deprecated to be replaced with upstream implementation in v4
     *
     * The manifest file uses the following format:
     *     {
     *         "main.js": "main.abc123.js",
     *         "css/styles.css": "css/styles.555abc.css"
     *     }
     */
    final class JsonManifestVersionStrategy implements \symfony\component\asset\versionstrategy\versionstrategyinterface {
        /** @var FileInterface|JsonFile */
        private $manifestFile;
        /** @var array|null */
        private $manifestData;

        public function __construct(FileInterface $manifestFile) {}
        public function getVersion($path) {}
        public function applyVersion($path) {}
        private function getManifestPath($path) {}
    }

    /**
     * Bolt Snippet target location.
     *
     * This class categorizes all possible snippet locations in constants.
     */
    class Target {
        const BEFORE_JS = 'beforejs';
        const AFTER_JS = 'afterjs';
        const WIDGET_BACK_LOGIN_MIDDLE = 'login_middle';
        const WIDGET_BACK_LOGIN_BOTTOM = 'login_bottom';
        const WIDGET_BACK_EDITFILE_BOTTOM = 'editfile_bottom';
        const WIDGET_BACK_LOGIN_TOP = 'login_top';
        const WIDGET_BACK_FILES_BOTTOM = 'files_bottom';
        const WIDGET_BACK_EDITFILE_BELOW_HEADER = 'editfile_below_header';
        const WIDGET_BACK_FILES_BELOW_HEADER = 'files_below_header';
        const WIDGET_BACK_EDITCONTENT_BOTTOM = 'editcontent_bottom';
        const WIDGET_BACK_EDITCONTENT_BELOW_HEADER = 'editcontent_below_header';
        const WIDGET_BACK_EDITCONTENT_ASIDE_BOTTOM = 'editcontent_aside_bottom';
        const WIDGET_BACK_EDITCONTENT_ASIDE_MIDDLE = 'editcontent_aside_middle';
        const WIDGET_BACK_EDITCONTENT_ASIDE_TOP = 'editcontent_aside_top';
        const WIDGET_BACK_OVERVIEW_BOTTOM = 'overview_bottom';
        const WIDGET_BACK_OVERVIEW_BELOW_HEADER = 'overview_below_header';
        const WIDGET_BACK_OVERVIEW_ASIDE_BOTTOM = 'overview_aside_bottom';
        const WIDGET_BACK_OVERVIEW_ASIDE_MIDDLE = 'overview_aside_middle';
        const WIDGET_BACK_OVERVIEW_ASIDE_TOP = 'overview_aside_top';
        const WIDGET_BACK_DASHBOARD_BOTTOM = 'dashboard_bottom';
        const WIDGET_BACK_DASHBOARD_BELOW_HEADER = 'dashboard_below_header';
        const WIDGET_BACK_DASHBOARD_ASIDE_BOTTOM = 'dashboard_aside_bottom';
        const WIDGET_BACK_DASHBOARD_ASIDE_MIDDLE = 'dashboard_aside_middle';
        const WIDGET_BACK_DASHBOARD_ASIDE_TOP = 'dashboard_aside_top';
        const WIDGET_FRONT_ASIDE_TOP = 'aside_top';
        const WIDGET_FRONT_ASIDE_MIDDLE = 'aside_middle';
        const WIDGET_FRONT_ASIDE_BOTTOM = 'aside_bottom';
        const WIDGET_FRONT_FOOTER = 'footer';
        const AFTER_BODY_JS = 'afterbodyjs';
        const WIDGET_FRONT_MAIN_TOP = 'main_top';
        const WIDGET_FRONT_MAIN_BREAK = 'main_break';
        const WIDGET_FRONT_MAIN_BOTTOM = 'main_bottom';
        const AFTER_HEAD_JS = 'afterheadjs';
        const BEFORE_BODY_CSS = 'beforebodycss';
        const AFTER_BODY_CSS = 'afterbodycss';
        const BEFORE_BODY_JS = 'beforebodyjs';
        const AFTER_HEAD_META = 'afterheadmeta';
        const BEFORE_HEAD_CSS = 'beforeheadcss';
        const AFTER_HEAD_CSS = 'afterheadcss';
        const BEFORE_HEAD_JS = 'beforeheadjs';
        const END_OF_HTML = 'endofhtml';
        const END_OF_BODY = 'endofbody';
        const BEFORE_HEAD_META = 'beforeheadmeta';
        const AFTER_HTML = 'afterhtml';
        const START_OF_HEAD = 'startofhead';
        const AFTER_META = 'aftermeta';
        const START_OF_BODY = 'startofbody';
        const END_OF_HEAD = 'endofhead';
        const AFTER_CSS = 'aftercss';
        const BEFORE_CSS = 'beforecss';

        /**
         * Returns all possible target locations (which are constants).
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         *
         * @return array
         */
        public function listAll() {}
    }

    /**
     * A version strategy that hashes a base salt, path, and timestamp of file.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class BoltVersionStrategy implements \symfony\component\asset\versionstrategy\versionstrategyinterface {
        /** @var DirectoryInterface */
        protected $directory;
        /** @var string */
        protected $baseSalt;

        public function __construct(DirectoryInterface $directory, $baseSalt) {}
        public function getVersion($path) {}
        public function applyVersion($path) {}
    }

    /**
     * Class for matching HTML elements and injecting text.
     *
     * @author Bob den Otter <bob@twokings.nl>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Injector {
        /**
         * Get a map of function names to locations.
         *
         * @return array
         */
        public function getMap() {}
        public function inject(AssetInterface $asset, $location, Response $response) {}
        protected function headTagStart(AssetInterface $asset, $rawHtml) {}
        protected function headTagEnd(AssetInterface $asset, $rawHtml) {}
        protected function bodyTagStart(AssetInterface $asset, $rawHtml) {}
        protected function bodyTagEnd(AssetInterface $asset, $rawHtml) {}
        protected function htmlTagEnd(AssetInterface $asset, $rawHtml) {}
        protected function metaTagsAfter(AssetInterface $asset, $rawHtml) {}
        protected function cssTagsAfter(AssetInterface $asset, $rawHtml) {}
        protected function cssTagsBefore(AssetInterface $asset, $rawHtml) {}
        protected function jsTagsBefore(AssetInterface $asset, $rawHtml) {}
        protected function jsTagsAfter($asset, $rawHtml, $insidehead = false) {}
        private function getMatches($rawHtml, $htmlTag, $matchRemainder, $matchAll) {}
        private function tagSoup(AssetInterface $asset, $rawHtml) {}
    }


    /**
     * Interface for asset queues.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface QueueInterface {
        function process(Request $request, Response $response) ;
        /**
         * Get the assets in this queue.
         *
         * @return AssetInterface[]|array
         */
        function getQueue() ;
        /**
         * Clears the queue.
         */
        function clear() ;
    }

    /**
     * Interface for assets.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface AssetInterface {
        /**
         * Convert object into a usable string.
         *
         * @return string
         */
        function __toString() ;
        /**
         * Get the priority of the asset used for sorting.
         *
         * @return int
         */
        function getPriority() ;
        function setPriority($priority) ;
        /**
         * Get the asset's zone. Either 'frontend' or 'backend'.
         *
         * @return string|null
         */
        function getZone() ;
        function setZone($zone) ;
        /**
         * Get the assets's target location.
         *
         * @return string|null
         */
        function getLocation() ;
        function setLocation($location) ;
    }


    /**
     * Trait for handling queue priority sorting.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait AssetSortTrait {
        protected function sort(array $assets) {}
    }

    /**
     * Trait for handling callables.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait CallableInvokerTrait {
        protected function invokeCallable(callable $callback, $callbackArguments) {}
        private function getArguments(callable $callback, array $callbackArguments) {}
/** @var object $callback */
        private function getParameters(/** @var object $callback */
callable $callback) {}
    }

}

namespace Bolt\Asset\Widget {
    /**
     * Widget queue processor.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Bob den Otter <bob@twokings.nl>
     */
    class Queue implements \bolt\asset\queueinterface {
    use \bolt\asset\assetsorttrait;

        /** @var WidgetAssetInterface[] Queue with snippets of HTML to insert. */
        protected $queue;
        /** @var \Bolt\Asset\Injector */
        protected $injector;
        /** @var \Doctrine\Common\Cache\CacheProvider */
        protected $cache;
        /** @var Environment */
        protected $render;
        /** @var bool */
        private $deferAdded;

        public function __construct(Injector $injector, CacheProvider $cache, $render) {}
        public function add(WidgetAssetInterface $widget) {}
        public function get($key) {}
        public function getRendered($key) {}
        /**
         * {@inheritdoc}
         */
        public function clear() {}
/** @var WidgetAssetInterface $widget */
        public function process(/** @var WidgetAssetInterface $widget */
Request $request, /** @var WidgetAssetInterface $widget */
Response $response) {}
        /**
         * Get the queued widgets.
         *
         * @return WidgetAssetInterface[]
         */
        public function getQueue() {}
        public function hasItemsInQueue($location, $zone = Zone::FRONTEND) {}
        public function has($location, $zone = Zone::FRONTEND) {}
        public function countItemsInQueue($location, $zone = Zone::FRONTEND) {}
        public function count($location, $zone = Zone::FRONTEND) {}
/** @var WidgetAssetInterface $widget */
        public function render(/** @var WidgetAssetInterface $widget */
$location, /** @var WidgetAssetInterface $widget */
$zone = Zone::FRONTEND, /** @var WidgetAssetInterface $widget */
$wrapperTemplate = 'widgetwrapper.twig') {}
        protected function getHtml(WidgetAssetInterface $widget) {}
        protected function addDeferredJavaScript(WidgetAssetInterface $widget, Response $response) {}
    }

    /**
     * Widget objects.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Bob den Otter <bob@twokings.nl>
     */
    class Widget implements \bolt\asset\widget\widgetassetinterface {
    use \bolt\asset\callableinvokertrait;

        /** @var string */
        protected $key;
        /** @var string */
        protected $zone;
        /** @var string */
        protected $location;
        /** @var callable */
        protected $callback;
        /** @var array */
        protected $callbackArguments;
        /** @var string */
        protected $content;
        /** @var array */
        protected $class;
        /** @var string */
        protected $prefix;
        /** @var string */
        protected $postfix;
        /** @var bool */
        protected $defer;
        /** @var int */
        protected $priority;
        /** @var int */
        protected $cacheDuration;
        /** @var string */
        private $rendered;

        /**
         * @return WidgetAssetInterface
         */
        public static function create() {}
        public function offsetExists($offset) {}
        public function offsetGet($offset) {}
        public function offsetSet($offset, $value) {}
        public function offsetUnset($offset) {}
        /**
         * {@inheritdoc}
         */
        public function getKey() {}
        /**
         * {@inheritdoc}
         */
        public function setKey() {}
        /**
         * {@inheritdoc}
         */
        public function getZone() {}
        public function setZone($zone) {}
        /**
         * {@inheritdoc}
         */
        public function getLocation() {}
        public function setLocation($location) {}
        /**
         * {@inheritdoc}
         */
        public function getCallback() {}
        public function setCallback(callable $callback) {}
        /**
         * {@inheritdoc}
         */
        public function getCallbackArguments() {}
        public function setCallbackArguments(array $callbackArguments) {}
        /**
         * {@inheritdoc}
         */
        public function getContent() {}
        public function setContent($content) {}
        /**
         * {@inheritdoc}
         */
        public function getClass() {}
        public function setClass($class) {}
        /**
         * {@inheritdoc}
         */
        public function getPrefix() {}
        public function setPrefix($prefix) {}
        /**
         * {@inheritdoc}
         */
        public function getPostfix() {}
        public function setPostfix($postfix) {}
        /**
         * {@inheritdoc}
         */
        public function isDeferred() {}
        public function setDefer($defer) {}
        /**
         * {@inheritdoc}
         */
        public function getPriority() {}
        public function setPriority($priority) {}
        /**
         * {@inheritdoc}
         */
        public function getCacheDuration() {}
        public function setCacheDuration($cacheDuration) {}
        /**
         * {@inheritdoc}
         */
        public function __toString() {}
        /**
         * Either return the passed in 'content' or the result of the callback.
         *
         * @return string
         */
        protected function toString() {}
    }


    /**
     * Widget assets interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface WidgetAssetInterface extends \arrayaccess {
        /**
         * Get the wiget's key.
         *
         * @return string|null
         */
        function getKey() ;
        /**
         * Set the widget (semi-) unique key.
         *
         * @internal
         *
         * @return WidgetAssetInterface
         */
        function setKey() ;
        /**
         * Get the optional content provider callback function.
         *
         * callable|null
         */
        function getCallback() ;
        function setCallback(callable $callback) ;
        /**
         * Get the callback function arguments.
         *
         * @return array|null
         */
        function getCallbackArguments() ;
        function setCallbackArguments(array $callbackArguments) ;
        /**
         * Get the static HTML content for the widget.
         *
         * @return string|null
         */
        function getContent() ;
        function setContent($content) ;
        /**
         * Get the HTML class to use for the widget's holder div.
         *
         * @return string|null
         */
        function getClass() ;
        function setClass($class) ;
        /**
         * Get the HTML to be applied before the widget's output.
         *
         * @return string|null
         */
        function getPrefix() ;
        function setPrefix($prefix) ;
        /**
         * Get the HTML to be applied after the widget's output.
         *
         * @return string|null
         */
        function getPostfix() ;
        function setPostfix($postfix) ;
        /**
         * Check if the widget is set to be lazy loaded.
         *
         * @return bool
         */
        function isDeferred() ;
        function setDefer($defer) ;
        /**
         * Get the widget's render priroity in the target position.
         *
         * @return int
         */
        function getPriority() ;
        function setPriority($priority) ;
        /**
         * Get the number of seconds to cache the widgets content.
         *
         * @return int
         */
        function getCacheDuration() ;
        function setCacheDuration($cacheDuration) ;
    }

}

namespace Bolt\Asset\File {
    /**
     * File asset base class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class FileAssetBase implements \bolt\asset\file\fileassetinterface {
        /** @var string */
        protected $type;
        /** @var string */
        protected $path;
        /** @var string */
        protected $packageName;
        /** @var string */
        protected $url;
        /** @var bool */
        protected $late;
        /** @var int */
        protected $priority;
        /** @var string */
        protected $location;
        /** @var array */
        protected $attributes;
        /** @var string */
        protected $zone;

        public function __construct($path = null, $packageName = null) {}
        public static function create($path = null, $packageName = null) {}
        /**
         * {@inheritdoc}
         */
        public function getType() {}
        /**
         * {@inheritdoc}
         */
        public function getFileName() {}
        public function setFileName($fileName) {}
        /**
         * @return string
         */
        public function getPath() {}
        public function setPath($path) {}
        /**
         * @return string
         */
        public function getPackageName() {}
        public function setPackageName($packageName) {}
        /**
         * @return string
         */
        public function getUrl() {}
        public function setUrl($url) {}
        /**
         * {@inheritdoc}
         */
        public function isLate() {}
        public function setLate($late) {}
        /**
         * {@inheritdoc}
         */
        public function getPriority() {}
        public function setPriority($priority) {}
        /**
         * {@inheritdoc}
         */
        public function getLocation() {}
        public function setLocation($location) {}
        public function getAttributes($raw = false) {}
        public function setAttributes(array $attributes) {}
        public function addAttribute($attribute) {}
        /**
         * {@inheritdoc}
         */
        public function getZone() {}
        public function setZone($zone) {}
    }

    /**
     * JavaScript file object class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class JavaScript extends \bolt\asset\file\fileassetbase {
        /** @var string */
        protected $type;

        /**
         * {@inheritdoc}
         */
        public function __toString() {}
    }

    /**
     * File asset queue processor.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Bob den Otter <bob@twokings.nl>
     */
    class Queue implements \bolt\asset\queueinterface {
    use \bolt\asset\assetsorttrait;

        /** @var \Bolt\Asset\Injector */
        protected $injector;
        /** @var Packages */
        protected $packages;
        /** @var Config */
        protected $config;
        /** @var FileAssetInterface[] */
        private $stylesheet;
        /** @var FileAssetInterface[] */
        private $javascript;

        public function __construct(Injector $injector, Packages $packages, Config $config) {}
        public function add(FileAssetInterface $asset) {}
/** @var FileAssetInterface $asset */
        public function process(/** @var FileAssetInterface $asset */
Request $request, /** @var FileAssetInterface $asset */
Response $response) {}
        /**
         * {@inheritdoc}
         */
        public function getQueue() {}
        /**
         * {@inheritdoc}
         */
        public function clear() {}
        protected function processAsset(FileAssetInterface $asset, Request $request, Response $response) {}
        protected function addJquery(Request $request, Response $response) {}
    }

    /**
     * Cascading stylesheet file object class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Stylesheet extends \bolt\asset\file\fileassetbase {
        /** @var string */
        protected $type;

        /**
         * {@inheritdoc}
         */
        public function __toString() {}
    }


    /**
     * File asset interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface FileAssetInterface extends \bolt\asset\assetinterface {
        /**
         * Get the asset's type.
         *
         * @return string
         */
        function getType() ;
        /**
         * Get the package name.
         *
         * @return string
         */
        function getPackageName() ;
        function setPackageName($package) ;
        /**
         * Get the asset's path.
         *
         * @return string
         */
        function getPath() ;
        function setPath($path) ;
        /**
         * Get the asset's url.
         *
         * @return string
         */
        function getUrl() ;
        function setUrl($url) ;
        /**
         * Check if the asset is set to load late.
         *
         * @return bool
         */
        function isLate() ;
        function setLate($late) ;
        function getAttributes($raw = false) ;
        function setAttributes(array $attributes) ;
        function addAttribute($attribute) ;
    }

}

namespace Bolt\Asset\Snippet {
    /**
     * Snippet queue processor.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Bob den Otter <bob@twokings.nl>
     */
    class Queue implements \bolt\asset\queueinterface {
        /** @var Snippet[] Queue with snippets of HTML to insert. */
        protected $queue;
        /** @var \Bolt\Asset\Injector */
        protected $injector;
        /** @var \Doctrine\Common\Cache\CacheProvider */
        protected $cache;

        public function __construct(Injector $injector, CacheProvider $cache) {}
        public function add(SnippetAssetInterface $snippet) {}
        /**
         * {@inheritdoc}
         */
        public function clear() {}
/** @var Snippet $asset */
        public function process(/** @var Snippet $asset */
Request $request, /** @var Snippet $asset */
Response $response) {}
        /**
         * Get the queued snippets.
         *
         * @return \Bolt\Asset\Snippet\Snippet[]
         */
        public function getQueue() {}
    }

    /**
     * Snippet objects.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Snippet implements \bolt\asset\snippet\snippetassetinterface {
        /** @var int */
        protected $priority;
        /** @var string */
        protected $location;
        /** @var callable|string */
        protected $callback;
        /** @var array */
        protected $callbackArguments;
        /** @var string */
        protected $zone;

        /**
         * @return SnippetAssetInterface
         */
        public static function create() {}
        /**
         * {@inheritdoc}
         */
        public function __toString() {}
        /**
         * {@inheritdoc}
         */
        public function getPriority() {}
        public function setPriority($priority) {}
        /**
         * {@inheritdoc}
         */
        public function getLocation() {}
        public function setLocation($location) {}
        /**
         * {@inheritdoc}
         */
        public function getCallback() {}
        public function setCallback($callback) {}
        /**
         * {@inheritdoc}
         */
        public function getCallbackArguments() {}
        public function setCallbackArguments($callbackArguments) {}
        /**
         * {@inheritdoc}
         */
        public function getZone() {}
        public function setZone($zone) {}
        /**
         * Get the output from the callback.
         *
         * @throws \RuntimeException
         *
         * @return string
         */
        private function getCallableResult() {}
    }


    /**
     * Snippet asset interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface SnippetAssetInterface extends \bolt\asset\assetinterface {
        /**
         * Get callback or HTML string.
         *
         * @return callable|string
         */
        function getCallback() ;
        function setCallback($callback) ;
        /**
         * Get the callback arguments.
         *
         * @return array
         */
        function getCallbackArguments() ;
        function setCallbackArguments($callbackArguments) ;
    }

}

namespace Bolt\Embed {
    /**
     * Embed resolver service.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Resolver {
        /** @var callable */
        private $embedFactory;

        public function __construct(callable $embedFactory) {}
/** @var \Embed\Providers\Provider $provider */
        public function embed(/** @var \Embed\Providers\Provider $provider */
UriInterface $url, /** @var \Embed\Providers\Provider $provider */
$providerName) {}
        public function image(UriInterface $url) {}
        public function images(UriInterface $url) {}
        private function getUrlAdapter(UriInterface $url) {}
    }

    /**
     * Guzzle dispatcher for the embed/embed service.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class GuzzleDispatcher implements \embed\http\dispatcherinterface {
        /** @var Client */
        private $client;
        /** @var \Embed\Http\AbstractResponse[] */
        private $responses;
        /** @var HandlerStack */
        private $handlerStack;

        public function __construct(Client $client, HandlerStack $handlerStack) {}
        public function dispatch(Url $url) {}
/** @var Psr7\Response $response */
        public function dispatchImages(/** @var Psr7\Response $response */
array $urls) {}
/** @var Psr7\Response $response */
        protected function getGuzzleResponse(/** @var Psr7\Response $response */
Url $url, /** @var Psr7\Response $response */
array $options = [ ]) {}
        private function getMimeType(Psr7\Response $response) {}
    }

}

namespace Bolt\Translation {
    /**
     * Handles translation file dependent tasks.
     */
    class TranslationFile {
        /** @var \Silex\Application */
        private $app;
        /** @var string Requested Domain. */
        private $domain;
        /** @var string Path to the translation file. */
        private $absPath;
        /** @var string Project relative path to the translation file. */
        private $relPath;
        /** @var array List of all translatable Strings found. */
        private $translatables;

        public function __construct(Application $app, $domain, $locale) {}
        private function buildPath($domain, $locale) {}
        /**
         * Get the path to a translation resource.
         *
         * @return array [absolute path, relative path]
         */
        public function path() {}
        private function addTranslatable($text) {}
        /** @var \Symfony\Component\Finder\SplFileInfo $file */
        private function scanTwigFiles() {}
        /**
         * Scan php files for  __('...' and __("..." and add the strings found to the list of translatable strings.
         *
         * All translatable strings have to be called with:
         * __("text", params=[], domain='messages', locale=null) // $app['translator']->trans()
         * __("text", count, params=[], domain='messages', locale=null) // $app['translator']->transChoice()
         */
        private function scanPhpFiles() {}
        /**
         * Find all twig templates and bolt php code, extract translatables strings, merge with existing translations.
         */
        private function gatherTranslatableStrings() {}
        private function buildNewContent($newTranslations, $savedTranslations, $hinting = [ ]) {}
        /**
         * Parses translations file and returns translations.
         *
         * @return array|null Translations found
         */
        private function readSavedTranslations() {}
        /**
         * Get the content of the info translation file or the fallback file.
         *
         * @return string
         */
        private function contentInfo() {}
        /**
         * Gets all translatable strings and returns a translationsfile for messages or contenttypes.
         *
         * @return string
         */
        private function contentMessages() {}
        /**
         * Gets all translatable strings and returns a translations file for
         * messages.
         *
         * @return string
         */
        public function content() {}
        /**
         * Checks if translations file is allowed to write to.
         *
         * @return bool
         */
        public function isWriteAllowed() {}
    }

    /**
     * Generates translations keys for contenttypes.
     */
    class ContenttypesKeygen {
        /** @var \Silex\Application */
        private $app;
        /** @var array Hints for translations. */
        private $hints;
        /** @var array Translated strings. */
        private $translation;
        /** @var array ContentType names. */
        private $ctnames;
        /** @var array Translations read from file. */
        private $saved;
        /** @var array Translatable strings. */
        private $translatables;

        public function __construct(Silex\Application $app, array $translatables, array $savedTranslations) {}
        /**
         * Returns translations.
         *
         * @return array
         */
        public function translations() {}
        /**
         * Returns hints.
         *
         * @return array
         */
        public function hints() {}
        /**
         * Generates translations keys for contenttypes.
         */
        public function generate() {}
        /**
         * Generates keys for contenttypes names and description and save found names for later usage.
         */
        private function generateNamesDescription() {}
        /**
         * Generates keys for tab group names.
         */
        private function generateGroups() {}
        /**
         * Generates strings for contenttypes from generic translations.
         */
        private function generateFromGeneric() {}
        private function slugifyKey($key) {}
        private function isSaved($key) {}
        private function fallback($key) {}
    }

    /**
     * Handles translation.
     */
    class Translator {
        private static function htmlencodeParams(array $params, $removeKey = '') {}
        private static function trans($key, array $params = [ ], $domain = 'messages', $locale = null, $default = null) {}
        public static function __($key, array $params = [ ], $domain = 'messages', $locale = null) {}
    }

    /**
     * Lazy-loading Translator.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class LazyTranslator {
        /** @var string */
        protected $key;
        /** @var array */
        protected $params;
        /** @var string */
        protected $domain;
        /** @var string */
        protected $locale;

        public function __construct($key, array $params, $domain, $locale) {}
        public static function __($key, array $params = [ ], $domain = 'messages', $locale = null) {}
        public function __toString() {}
    }

}

namespace Bolt\Security\Random {
    /**
     * Random generator.
     *
     * NOTE: PHP 5 polyfill for random_bytes() and random_int() provided by
     * paragonie/random_compat Composer library.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Generator {
        public function generate($length) {}
        public function generateInt($min = 0, $max = PHP_INT_MAX) {}
        public function generateString($length) {}
    }

}

namespace Bolt\AccessControl {
    /**
     * Login authentication handling.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Login extends \bolt\accesscontrol\accesschecker {
        /** @var Factory */
        protected $passwordFactory;
        /** @var string */
        protected $authTokenName;
        /** @var CsrfTokenManagerInterface */
        private $csrfTokenManager;

        public function __construct(Application $app) {}
        public function login($userName, $password, AccessControlEvent $event) {}
        protected function loginCheckPassword($userName, $password, AccessControlEvent $event) {}
        protected function loginCheckAuthtoken($authCookie, AccessControlEvent $event) {}
        protected function getUserEntity($userName) {}
        protected function loginFinish(Entity\Users $userEntity) {}
        protected function loginFailed(Entity\Users $userEntity) {}
        protected function updateUserLogin(Entity\Users $userEntity) {}
        protected function updateUserShadowLogin(Entity\Users $userEntity) {}
/** @deprecated workaround until v4 */
        protected function updateAuthToken(/** @deprecated workaround until v4 */
Entity\Users $userEntity) {}
        private function throttleUntil($attempts) {}
    }

    /**
     * This class implements role-based permissions.
     */
    class Permissions {
        const ROLE_ROOT = 'root';
        const ROLE_OWNER = 'owner';
        const ROLE_ANONYMOUS = 'anonymous';
        const ROLE_EVERYONE = 'everyone';

        /** @var \Silex\Application */
        private $app;
        /** @var array Per-request permission cache */
        private $rqcache;
        /** @var array The list of ContentType permissions */
        private $contentTypePermissions;

        public function __construct(Silex\Application $app) {}
        private function audit($msg) {}
        /**
         * Gets a list of all the roles that can be assigned to users explicitly.
         * This includes all the custom roles from permissions.yml, plus the
         * special 'root' role, but not the special roles 'anonymous', 'everyone',
         * and 'owner' (these are assigned automatically).
         *
         * @return array
         */
        public function getDefinedRoles() {}
        public function getRole($roleName) {}
        public function getUserRoles($user, Content $content = null) {}
        public function getManipulatableRoles(array $currentUser) {}
        public function isAllowedToManipulate(array $user, array $currentUser) {}
        public function checkPermission($roleNames, $permissionName, $type = null, $item = null) {}
        private function checkRolePermission($roleName, $permissionName, $type = 'global', $item = null) {}
        private function checkRoleGlobalPermission($roleName, $permissionName) {}
        private function checkRoleHierarchyPermission($roleName, $permissionName, $role) {}
        private function checkRoleContentTypePermission($roleName, $permissionName, $contenttype) {}
        /**
         * Get the list of ContentType permissions available.
         *
         * @return bool[]
         */
        public function getContentTypePermissions() {}
        public function getContentTypeUserPermissions($contentTypeSlug, $user) {}
        public function getRolesByGlobalPermission($permissionName) {}
        /**
         * Gets the configured global permissions.
         *
         * @return array
         */
        public function getGlobalRoles() {}
        public function getRolesByContentTypePermission($permissionName, $contenttype) {}
        public function getEffectiveRolesForUser($user) {}
        public function isAllowed($what, $user, $content = null, $contentId = null) {}
        private function isAllowedRule($rule, $user, $userRoles, $content, $contenttypeSlug, $contentid) {}
        private function isAllowedSingle($what, $user, $userRoles, $content = null, $contenttypeSlug = null, $contentId = null) {}
        public function getContentStatusTransitionPermission($fromStatus, $toStatus) {}
        public function isContentStatusTransitionAllowed($fromStatus, $toStatus, $user, $contenttype, $contentid = null) {}
    }

    /**
     * Password handling.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Password {
        /** @var EntityManager */
        protected $em;
        /** @var \Silex\Application $app */
        protected $app;

        public function __construct(Application $app) {}
/** @var UsersRepository $repo */
        public function setRandomPassword(/** @var UsersRepository $repo */
$username) {}
/** @var UsersRepository $repo */
        public function resetPasswordConfirm(/** @var UsersRepository $repo */
$token, /** @var UsersRepository $repo */
$remoteIP, /** @var UsersRepository $repo */
Event $event) {}
/** @var Entity\Users $userEntity */
        public function resetPasswordRequest(/** @var Entity\Users $userEntity */
$username, /** @var Entity\Users $userEntity */
$remoteIP, /** @var Entity\Users $userEntity */
Event $event) {}
        private function resetPasswordNotification(Entity\Users $userEntity, $shadowPassword, $shadowToken) {}
    }

    /**
     * Lexer and parser for permission query syntax.
     *
     * Input is a stream of bytes, usually from a call to isAllowed(). Output is
     * a nested associative array representing permission query AST.
     *
     * Each node in the nested tree contains the following keys:
     * - 'type': one of the P_XXXX parse tree node type constants (see below)
     * - 'value': the node's "payload". For nodes that have children (P_AND, P_OR),
     *            this is an array of child nodes; for other nodes, it is the plain
     *            payload - a simple query of the form 'a:b:c:...' for P_SIMPLE, or
     *            NULL for P_TRUE and P_FALSE.
     *
     * Lexer tokens will not typically be used outside the parser. Each lexer token
     * is an associative array with the following keys:
     * - 'type': one of the T_XXXX constants, indicating the token type.
     * - 'capture': if the token captures variable input, this key holds the value.
     * - 'match': the raw input consumed by this token. For any valid input stream,
     *            concatenating the 'match' values for all the output tokens should
     *            yield back the original input.
     */
    class PermissionParser {
        const P_OR = 1;
        const P_SIMPLE = 0;
        const P_FALSE = 4;
        const P_TRUE = 3;
        const P_AND = 2;
        const T_UNDEFINED = 0;
        const T_CLOSE_PARENS = 2;
        const T_OPEN_PARENS = 1;
        const T_AND = 4;
        const T_OR = 3;
        const T_QUERY = 5;
        const T_TRUE = 7;
        const T_SPACE = 6;
        const T_FALSE = 8;

        public static function tokenName($tokenType) {}
        public static function run($what) {}
        public static function lex($query) {}
        private static function expect($expected, $token) {}
        public static function parse($tokens) {}
        private static function parseAnd($tokens) {}
        private static function parseOr($tokens) {}
        private static function parseSimple($tokens) {}
    }

    /**
     * Authentication handling.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class AccessChecker {
        /** @var EntityManagerInterface */
        private $em;
        /** @var \Symfony\Component\HttpFoundation\RequestStack */
        protected $requestStack;
        /** @var \Symfony\Component\HttpFoundation\Session\SessionInterface */
        protected $session;
        /** @var \Bolt\Logger\FlashLoggerInterface */
        protected $flashLogger;
        /** @var LoggerInterface */
        protected $systemLogger;
        /** @var \Bolt\AccessControl\Permissions */
        protected $permissions;
        /** @var Generator */
        protected $randomGenerator;
        /** @var EventDispatcherInterface */
        protected $dispatcher;
        /** @var array */
        protected $cookieOptions;
        /** @var bool */
        protected $validSession;

        public function __construct(EntityManagerInterface $em, RequestStack $requestStack, SessionInterface $session, EventDispatcherInterface $dispatcher, FlashLoggerInterface $flashLogger, LoggerInterface $systemLogger, Permissions $permissions, Generator $randomGenerator, array $cookieOptions) {}
/** @var \Bolt\AccessControl\Token\Token $sessionAuth */
        public function isValidSession(/** @var \Bolt\AccessControl\Token\Token $sessionAuth */
$authCookie) {}
        /**
         * Log out the currently logged in user.
         *
         * @return bool
         */
        public function revokeSession() {}
        protected function checkSessionStored(Token\Token $sessionAuth) {}
        protected function checkSessionDatabase($authCookie) {}
        protected function checkSessionKeys(Token\Token $sessionAuth) {}
        /**
         * Lookup active sessions.
         *
         * @return array
         */
        public function getActiveSessions() {}
        protected function getAuthToken($userId, $salt) {}
        /**
         * Return the user's host name.
         *
         * @return string
         */
        protected function getClientHost() {}
        /**
         * Return the user's IP address.
         *
         * @return string
         */
        protected function getClientIp() {}
        /**
         * Return the user's browser User Agent.
         *
         * @return string
         */
        protected function getClientUserAgent() {}
        /**
         * @return Repository\UsersRepository
         */
        protected function getRepositoryUsers() {}
        /**
         * @return Repository\AuthtokenRepository
         */
        protected function getRepositoryAuthtoken() {}
    }

}

namespace Bolt\AccessControl\Token {
    /**
     * Authentication tokens.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Token {
        /** @var Entity\Users */
        protected $user;
        /** @var Entity\Authtoken */
        protected $token;
        /** @var int */
        protected $checked;

        public function __construct(Entity\Users $userEntity, Entity\Authtoken $tokenEntity) {}
        public function __toString() {}
        /**
         * Check if stored user object is enabled.
         *
         * @return bool|null
         */
        public function isEnabled() {}
        /**
         * Get stored user entity object.
         *
         * @return Entity\Users
         */
        public function getUser() {}
        public function setUser(Entity\Users $user) {}
        /**
         * Get stored token entity object.
         *
         * @return Entity\Authtoken
         */
        public function getToken() {}
        public function setToken(Entity\Authtoken $token) {}
        /**
         * Get time of last check against database.
         *
         * @return int
         */
        public function getChecked() {}
        /**
         * Set time of last database check to now.
         */
        public function setChecked() {}
    }

    /**
     * Token generator.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Generator {
        /** @var string */
        protected $token;

        public function __construct($username, $salt, $remoteIP, $hostName, $userAgent, array $cookieOptions, $algorithm = 'sha256') {}
        public function __toString() {}
    }

}

namespace Bolt\Composer {
    /**
     * Package collection class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class PackageCollection implements \jsonserializable {
        /** @var Package[] */
        private $packages;

        public function add(Package $package) {}
        public function get($name) {}
        /**
         * {@inheritdoc}
         */
        public function jsonSerialize() {}
    }

    /**
     * Class describing a single package, either composer installed, locally installed, or pending installation.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class Package implements \jsonserializable {
        private $status;
        private $type;
        private $name;
        private $title;
        private $description;
        private $version;
        private $authors;
        private $keywords;
        private $readmeLink;
        private $configLink;
        private $repositoryLink;
        private $constraint;
        private $valid;
        private $enabled;

        public static function createFromComposerPackage(CompletePackageInterface $package) {}
        public static function createFromComposerJson(array $composerJson) {}
        /**
         * {@inheritdoc}
         */
        public function jsonSerialize() {}
        public function setStatus($status) {}
        public function setType($type) {}
        public function setName($name) {}
        /**
         * Return a package Composer name.
         *
         * @return string
         */
        public function getName() {}
        public function setTitle($title) {}
        public function setDescription($description) {}
        public function setVersion($version) {}
        public function setAuthors(array $authors) {}
        public function setKeywords(array $keywords) {}
        public function setReadmeLink($readmeLink) {}
        public function setConfigLink($configLink) {}
        public function setRepositoryLink($repositoryLink) {}
        public function setConstraint($constraint) {}
        public function setValid($valid) {}
        public function setEnabled($enabled) {}
    }

    /**
     * Composer JSON file manager class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class JsonManager {
        /** @var array */
        protected $messages;
        /** @var Application */
        private $app;

        public function __construct(Application $app) {}
        public function init($file, array $data = null) {}
        /** @var \Bolt\Filesystem\Handler\JsonFile $jsonFile */
        public function update() {}
/** @deprecated Handle BC on 'stability' key until 4.0 */
        private function setJsonDefaults(/** @deprecated Handle BC on 'stability' key until 4.0 */
array $json) {}
    }

    class PackageManager {
        /** @var Application */
        protected $app;
        /** @var bool */
        protected $started;
        /** @var bool */
        protected $useSsl;
        /** @var array|null */
        private $json;

        public function __construct(Application $app) {}
        /** @var PingService $pinger */
        public function getMessages() {}
        /**
         * Return the output from the last IO.
         *
         * @return string
         */
        public function getOutput() {}
        /**
         * Set up function.
         *
         * - Copy/update the installer event class
         * - Update the composer.json
         * - Test connection to the server
         */
        private function setup() {}
        /**
         * Check if we can/should use SSL/TLS/HTTP2 or HTTP.
         *
         * @throws \Exception
         *
         * @return bool
         */
        public function useSsl() {}
        /**
         * Check for packages that need to be installed or updated.
         *
         * @return array
         */
        public function checkPackage() {}
        public function dependsPackage($packageName, $constraint) {}
        /**
         * Dump fresh autoloader.
         *
         * @return int 0 on success or a positive error code on failure
         */
        public function dumpAutoload() {}
        /**
         * Install configured packages.
         *
         * @return int 0 on success or a positive error code on failure
         */
        public function installPackages() {}
        public function prohibitsPackage($packageName, $constraint) {}
        public function removePackage(array $packages) {}
        public function requirePackage(array $packages) {}
        public function searchPackage(array $packages) {}
        public function showPackage($target, $package = '', $version = '', $root = false) {}
        public function updatePackage(array $packages) {}
        public function initJson($file, array $data = [ ]) {}
        /** @var CompletePackageInterface $composerPackage */
        public function getAllPackages() {}
        private function linkReadMe(ResolvedExtension $extension) {}
        private function linkConfig(ResolvedExtension $extension) {}
        /**
         * Set up Composer JSON file.
         */
        private function updateJson() {}
    }

    /**
     * Composer event script handler.
     *
     * @internal
     */
    final class ScriptHandler {
        public static function installAssets(Event $event, $checkForCreateProject = true) {}
        public static function installThemesAndFiles(Event $event) {}
        public static function updateProject(Event $event) {}
        public static function configureProject(Event $event) {}
        private static function runUpdateProjectFromAssets(Event $event) {}
    }

}

namespace Bolt\Composer\Script {
    /**
     * Updates .bolt.yml paths for changes with PathResolver introduced in 3.3.
     *
     * NOTE: If debugging this with with xdebug, you will need to run Composer from
     * the vendor/bin/ directory, and set the COMPOSER_ALLOW_XDEBUG=1 environment
     * variable, e.g.
     * <pre>
     * COMPOSER_ALLOW_XDEBUG=1 ./vendor/bin/composer run-script <script name>
     * </pre>
     *
     * @internal
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class BootstrapYamlUpdater {
        const FILENAME = '.bolt.yml';

        /** @var IOInterface */
        private $io;
        /** @var Filesystem */
        private $filesystem;

        public function __construct(IOInterface $io, Filesystem $filesystem = null) {}
        public static function fromEvent(Event $event, Filesystem $filesystem = null) {}
        /**
         * Update .bolt.yml file if needed.
         */
        public function update() {}
        public function save(array $contents) {}
        public function updatePaths(MutableBag $paths) {}
        private function determineMostCommonBaseAppPath($paths) {}
    }

    /**
     * Interactively allows CLI user to modify PathResolver paths.
     *
     * @internal
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class PathCustomizer {
        /** @var PathResolver */
        private $resolver;
        /** @var NutStyleInterface */
        private $io;
        /** @var Table */
        private $pathsTable;

        public function __construct(PathResolver $resolver, NutStyleInterface $io) {}
        /**
         * Run the customizer.
         */
        public function run() {}
        /**
         * Render paths table.
         */
        private function renderPaths() {}
        /**
         * Ask which path to modify.
         *
         * @return string|null the path name to modify or null to finish
         */
        private function askPathToModify() {}
        private function askAndSetNewPathValue($name) {}
    }

    /**
     * Configures project default site bundle.
     *
     * This should only be used for new projects.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class BundleConfigurator {
        const FILENAME = '.bolt.yml';

        /** @var NutStyleInterface */
        private $io;
        /** @var Filesystem */
        private $filesystem;

        public function __construct(NutStyleInterface $io, Filesystem $filesystem = null) {}
        public static function fromEvent(Event $event) {}
        /**
         * Setup .bolt.yml file if needed.
         */
        public function run() {}
        /**
         * Load data from .bolt.yml if it exists.
         *
         * @return MutableBag
         */
        private function load() {}
        private function save(MutableBag $contents) {}
        private function updateSiteBundleLoader(MutableBag $contents) {}
    }

    /**
     * Syncs directories from core to user project.
     *
     * @internal
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class DirectorySyncer {
        /** @var PathResolver */
        private $userResolver;
        /** @var PathResolver */
        private $boltResolver;
        /** @var IOInterface */
        private $io;
        /** @var Options */
        private $options;
        /** @var Filesystem */
        private $filesystem;

        public function __construct(PathResolver $userResolver, PathResolver $boltResolver, IOInterface $io, Options $options = null, Filesystem $filesystem = null) {}
/**
 * Use bootstrap.php to ensure autoloader and correct root path is used.
 *
 * @var Application $userApp
 */
        public static function fromEvent(/**
 * Use bootstrap.php to ensure autoloader and correct root path is used.
 *
 * @var Application $userApp
 */
Event $event) {}
        public function sync($srcName, $targetName, $delete = false, $onlySubDirs = [ ]) {}
        private function mirror($origin, $target, $delete = false) {}
    }

    /**
     * Adds handler to composer.json scripts section or shows how (on error).
     *
     * @internal
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class ScriptHandlerUpdater {
        /** @var Event */
        private $event;
        /** @var IOInterface */
        private $io;
        /** @var array|null */
        private $scripts;

        public function __construct(Event $event) {}
        /**
         * Checks if composer.json scripts already have the handler we are adding.
         *
         * @return bool
         */
        public function needsUpdate() {}
        /**
         * Attempt to update composer.json, or show how if we can't update the file.
         */
        public function update() {}
        /**
         * Update composer.json file.
         */
        private function updateAutomatically() {}
        /**
         * Tell users of the change and show how the composer.json file should be updated.
         */
        private function showHow() {}
        private function modifyScripts($scripts) {}
        private function hasScript($eventName, $script) {}
    }

    /**
     * Configures project directories, including:
     * - customizing directories
     * - writing .bolt.yml
     * - moving skeleton directories
     * - updating directory permissions
     *
     * This should only be used for new projects.
     *
     * @internal
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class DirectoryConfigurator {
        /** @var NutStyleInterface */
        private $io;
        /** @var Filesystem */
        private $filesystem;
        /** @var PathResolver */
        private $resolver;
        /** @var PathResolver */
        private $defaults;
        /** @var Options */
        private $options;

        public function __construct(NutStyleInterface $io, Options $options = null, PathResolver $resolver = null, Filesystem $filesystem = null) {}
        public static function fromEvent(Event $event) {}
        /**
         * Go!
         */
        public function run() {}
        /**
         * Configure dirs from env, composer extra values, and via user input.
         */
        private function configureDirs() {}
        /**
         * Writes the .bolt.yml file if paths are not the default.
         */
        private function writeYamlConfig() {}
        /**
         * Move dirs from skeleton to match given paths.
         */
        private function moveSkeletonDirs() {}
        private function moveSkeletonDir($name) {}
        /**
         * Update all path resolver directories permissions.
         */
        private function updatePermissions() {}
        private function verbose($messages) {}
    }

    /**
     * Handles options in composer's extra section and env vars.
     *
     * @internal
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class Options {
        /** @var array */
        private $composerExtra;

        public function __construct(array $composerExtra = [ ]) {}
        public static function fromEvent(Event $event) {}
        /**
         * Returns the directory mode.
         *
         * @return int
         */
        public function getDirMode() {}
        public function get($key, $default = null) {}
        private function getEnv($key) {}
    }

}

namespace Bolt\Composer\Satis {
    class StatService {
        /** @var array */
        public $urls;
        /** @var string */
        private $extendSite;
        /** @var ClientInterface */
        private $client;
        /** @var LoggerInterface */
        private $loggerSystem;

        public function __construct(ClientInterface $client, LoggerInterface $loggerSystem, $extendSite) {}
        public function recordInstall($package, $version) {}
    }

    /**
     * Class to provide querying of the Bolt Extensions repo as a
     * service.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     **/
    class QueryService {
        public $site;
        public $urls;
        public $format;
        /** @var \GuzzleHttp\Client */
        private $client;
        /** @var bool */
        private $isRetry;

        public function __construct(Client $client, $site, $urls = [ ]) {}
        public function all() {}
        public function info($package, $bolt) {}
        public function setFormat($format) {}
        public function execute($url, $params = [ ]) {}
    }

    /**
     * Class to provide pinging of the Bolt Marketplace as a service.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class PingService {
        /** @var Client */
        private $client;
        /** @var RequestStack */
        private $requestStack;
        /** @var string */
        private $uri;
        /** @var MutableBag */
        private $messages;

        public function __construct(Client $client, RequestStack $requestStack, $uri) {}
        public function ping($addQuery = false, $debugClient = false) {}
        /**
         * @return Bag
         */
        public function getMessages() {}
        private function doPing($addQuery, $debugClient) {}
    }

}

namespace Bolt\Composer\Action {
    /**
     * Composer update package class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class UpdatePackage extends \bolt\composer\action\baseaction {
/** @var \Composer\Composer $composer */
        public function execute(/** @var \Composer\Composer $composer */
array $packages = [ ], /** @var \Composer\Composer $composer */
array $options = [ ]) {}
    }

    /**
     * Shows which packages prevent the given package from being installed with
     * detailed information about why a package cannot be installed.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class ProhibitsPackage extends \bolt\composer\action\abstractdependencyaction {
        public function execute($packageName, $textConstraint = '*', $onlyLocal = true) {}
    }

    /**
     * Shows which packages cause the given package to be installed with
     * detailed information about where a package is referenced.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class DependsPackage extends \bolt\composer\action\abstractdependencyaction {
        public function execute($packageName, $textConstraint = '*', $onlyLocal = true) {}
    }

    /**
     * Composer require package class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class RequirePackage extends \bolt\composer\action\baseaction {
/** @var $install \Composer\Installer */
        public function execute(/** @var $install \Composer\Installer */
array $package) {}
        private function updateComposerJson(JsonFile $jsonFile, array $package, $isPostInstall) {}
        private function updateFileCleanly(JsonFile $jsonFile, array $new, $requireKey, $removeKey, $sortPackages, $isPostInstall) {}
    }

    /**
     * Abstract class for mapping Composer dependency relationships.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class AbstractDependencyAction extends \bolt\composer\action\baseaction {
        /** @var bool Whether to invert matching process (why-not vs why behaviour) */
        protected $inverted;
        /** @var bool */
        protected $recursive;

/** @var InstalledFilesystemRepository $repository */
        public function execute(/** @var InstalledFilesystemRepository $repository */
$packageName, /** @var InstalledFilesystemRepository $repository */
$textConstraint = '*', /** @var InstalledFilesystemRepository $repository */
$onlyLocal = true) {}
/** @var BasePackage $rootPackage */
        private function getRequiredPool(/** @var BasePackage $rootPackage */
$packageName, /** @var BasePackage $rootPackage */
$textConstraint, /** @var BasePackage $rootPackage */
$onlyLocal) {}
        private function getNeedles($packageName, $packages, $inverted) {}
        private function getDependencies(array $results) {}
    }

    /**
     * Composer search package class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class SearchPackage extends \bolt\composer\action\baseaction {
/** @var \Composer\Composer $composer */
        public function execute(/** @var \Composer\Composer $composer */
$packages, /** @var \Composer\Composer $composer */
$onlyname = true) {}
    }

    /**
     * Composer autoloader creation class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class DumpAutoload extends \bolt\composer\action\baseaction {
        /**
         * Dump autoloaders.
         *
         * @throws \Bolt\Exception\PackageManagerException
         *
         * @return int 0 on success or a positive error code on failure
         */
        public function execute() {}
    }

    /**
     * Composer action options class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Options extends \symfony\component\httpfoundation\parameterbag {
/** @var Local $adapter */
        public function __construct(/** @var Local $adapter */
JsonFile $composerJson, /** @var Local $adapter */
array $composerOverrides) {}
        /**
         * Extension base directory.
         *
         * @return string
         */
        public function baseDir() {}
        /**
         * Location of the composer.json file.
         *
         * @return JsonFile
         */
        public function composerJson() {}
        /**
         * Outputs the operations but will not execute anything (implicitly enables --verbose).
         *
         * Composer parameter: --dry-run
         *
         * @return bool
         */
        public function dryRun() {}
        /**
         * Shows more details including new commits pulled in when updating packages.
         *
         * Composer parameter: --verbose
         *
         * @return bool
         */
        public function verbose() {}
        /**
         * Disables installation of require-dev packages.
         *
         * Composer parameter: --no-dev
         *
         * @return bool
         */
        public function noDev() {}
        /**
         * Skips autoloader generation.
         *
         * Composer parameter: --no-autoloader
         *
         * @return bool
         */
        public function noAutoloader() {}
        /**
         * Skips the execution of all scripts defined in composer.json file.
         *
         * Composer parameter: --no-scripts
         *
         * @return bool
         */
        public function noScripts() {}
        /**
         * Add also all dependencies of whitelisted packages to the whitelist.
         *
         * Composer parameter: --with-dependencies
         *
         * @return bool
         */
        public function withDependencies() {}
        /**
         * Ignore platform requirements (php & ext- packages).
         *
         * Composer parameter: --ignore-platform-reqs
         *
         * @return bool
         */
        public function ignorePlatformReqs() {}
        /**
         * Prefer stable versions of dependencies.
         *
         * Composer parameter: --prefer-stable
         *
         * @return bool
         */
        public function preferStable() {}
        /**
         * Prefer lowest versions of dependencies.
         *
         * Composer parameter: --prefer-lowest
         *
         * @return bool
         */
        public function preferLowest() {}
        /**
         * Sorts packages when adding/updating a new dependency.
         *
         * Composer parameter: --sort-packages
         *
         * @return bool
         */
        public function sortPackages() {}
        /**
         * Forces installation from package sources when possible, including VCS information.
         *
         * Composer parameter: --prefer-source
         *
         * @return bool
         */
        public function preferSource() {}
        /**
         * Forces installation from package dist (archive) even for dev versions.
         *
         * Composer parameter: --prefer-dist
         *
         * @return bool
         */
        public function preferDist() {}
        /**
         * Do package update as well.
         *
         * Composer parameter: --None: Bolt customisation
         *
         * @return bool
         */
        public function update() {}
        /**
         * Disables the automatic update of the dependencies.
         *
         * Composer parameter: --no-update
         *
         * @return bool
         */
        public function noUpdate() {}
        /**
         * Run the dependency update with the --no-dev option.
         *
         * Composer parameter: --update-no-dev
         *
         * @return bool
         */
        public function updateNoDev() {}
        /**
         * Allows inherited dependencies to be updated with explicit dependencies.
         *
         * Composer parameter: --update-with-dependencies
         *
         * @return bool
         */
        public function updateWithDependencies() {}
        /**
         * Return the 'dev' parameter.
         *
         * Depending on where used:
         *   - Add requirement to require-dev
         *   - Removes a package from the require-dev section
         *   - Disables autoload-dev rules
         *
         * Composer parameter: --dev
         *
         * @return bool
         */
        public function dev() {}
        /**
         * Search only in name.
         *
         * Composer parameter: --only-name
         *
         * @return bool
         */
        public function onlyName() {}
        /**
         * Convert PSR-0/4 autoloading to classmap to get a faster autoloader. This is recommended especially for production.
         *
         * Composer parameter: --optimize
         *
         * @return bool
         */
        public function optimize() {}
        /**
         * Optimizes PSR0 and PSR4 packages to be loaded with classmaps too, good for production.
         *
         * Composer parameter: --optimize-autoloader
         *
         * @return bool
         */
        public function optimizeAutoloader() {}
        /**
         * Autoload classes from the classmap only. Implicitly enables --optimize-autoloader.
         *
         * Composer parameter: --classmap-authoritative
         *
         * @return bool
         */
        public function classmapAuthoritative() {}
    }

    /**
     * Checks for installable, or upgradeable packages.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class CheckPackage extends \bolt\composer\action\baseaction {
        /** @var string $versionConstraint */
        public function execute() {}
    }

    abstract class BaseAction {
        /** @var array */
        protected $messages;
        /** @var \Silex\Application */
        protected $app;
        /** @var \Composer\IO\BufferIO */
        private $io;
        /** @var \Composer\Composer */
        private $composer;
        /** @var \Composer\DependencyResolver\Pool */
        private $pool;
        /** @var \Composer\Repository\CompositeRepository */
        private $repos;

        public function __construct(Application $app) {}
        /**
         * Return the output from the last IO.
         *
         * @return string
         */
        public function getOutput() {}
        /**
         * Get a single option.
         *
         * @return Options
         */
        protected function getOptions() {}
        /**
         * Get a Composer object.
         *
         * @throws \Exception
         *
         * @return \Composer\Composer
         */
        protected function getComposer() {}
        /**
         * Get the IO object.
         *
         * @return \Composer\IO\BufferIO
         */
        protected function getIO() {}
        /**
         * Get a new Composer object.
         *
         * @return \Composer\Composer
         */
        protected function resetComposer() {}
        protected function getPreferedTarget($option) {}
/** @var ConfigurableRepositoryInterface $repo */
        private function setAllowSslDowngrade(/** @var ConfigurableRepositoryInterface $repo */
$choice) {}
        protected function findBestVersionForPackage($packageName, $targetPackageVersion = null, $returnArray = false) {}
        /**
         * Return a resolver pool that contains repositories, that provide packages.
         *
         * @return \Composer\DependencyResolver\Pool
         */
        protected function getPool() {}
        /**
         * Determine the minimum required stability.
         *
         * @return string
         */
        protected function getMinimumStability() {}
        /**
         * Get all our repos.
         *
         * @return \Composer\Repository\CompositeRepository
         */
        protected function getRepos() {}
        protected function formatRequirements(array $packages) {}
        protected function normalizeRequirements(array $packages) {}
    }

    /**
     * Composer remove package class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class RemovePackage extends \bolt\composer\action\baseaction {
/** @var \Bolt\Filesystem\Handler\JsonFile $jsonFile */
        public function execute(/** @var \Bolt\Filesystem\Handler\JsonFile $jsonFile */
array $packages) {}
    }

    /**
     * Composer package install class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class InstallPackage extends \bolt\composer\action\baseaction {
        /**
         * Install packages.
         *
         * @throws \Bolt\Exception\PackageManagerException
         *
         * @return int 0 on success or a positive error code on failure
         */
        public function execute() {}
    }

    /**
     * Composer show package class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class ShowPackage extends \bolt\composer\action\baseaction {
        /** @var \Composer\Package\Version\VersionParser */
        private $versionParser;

/** @var $package \Composer\Package\PackageInterface */
        public function execute(/** @var $package \Composer\Package\PackageInterface */
$type, /** @var $package \Composer\Package\PackageInterface */
$package = '', /** @var $package \Composer\Package\PackageInterface */
$version = '', /** @var $package \Composer\Package\PackageInterface */
$root = false) {}
        protected function getPackage(RepositoryInterface $installedRepo, RepositoryInterface $repos, $name, $version = null) {}
    }

}

namespace Bolt\Composer\Package {
    /**
     * Composer package dependency relationship.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DependencyRelationship implements \jsonserializable {
        /** @var string */
        protected $sourceName;
        /** @var string */
        protected $sourceVersion;
        /** @var string */
        protected $targetName;
        /** @var string */
        protected $targetVersion;
        /** @var string */
        protected $reason;

        /**
         * {@inheritdoc}
         */
        public function jsonSerialize() {}
        /**
         * Return object as array.
         *
         * @return array
         */
        public function toArray() {}
        /**
         * @return string
         */
        public function getSourceName() {}
        public function setSourceName($sourceName) {}
        /**
         * @return string
         */
        public function getSourceVersion() {}
        public function setSourceVersion($sourceVersion) {}
        /**
         * @return string
         */
        public function getTargetName() {}
        public function setTargetName($targetName) {}
        /**
         * @return string
         */
        public function getTargetVersion() {}
        public function setTargetVersion($targetVersion) {}
        /**
         * @return string
         */
        public function getReason() {}
        public function setReason($reason) {}
        /**
         * @return array
         */
        private function serialize() {}
    }

    /**
     * A single composer package dependency.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Dependency implements \jsonserializable {
        const PROHIBITS = 'prohibits';
        const DEPENDS = 'depends';

        /** @var string */
        protected $name;
        /** @var string */
        private $type;
        /** @var PackageInterface */
        protected $package;
        /** @var Link */
        protected $link;
        /** @var Dependency[]|false */
        protected $children;
        /** @var DependencyRelationship */
        protected $relationship;

        public function __construct($name, $type, PackageInterface $package, Link $link, $children) {}
        /**
         * {@inheritdoc}
         */
        public function jsonSerialize() {}
        /**
         * Return object as array.
         *
         * @return array
         */
        public function toArray() {}
        public static function create($name, $type, array $result) {}
        /**
         * @return string
         */
        public function getName() {}
        public function setName($name) {}
        /**
         * @return string
         */
        public function getType() {}
        public function setType($type) {}
        /**
         * @return PackageInterface
         */
        public function getPackage() {}
        public function setPackage(PackageInterface $package) {}
        /**
         * @return Link
         */
        public function getLink() {}
        public function setLink(Link $link) {}
        /**
         * @return Dependency[]|false
         */
        public function getChildren() {}
        public function setChildren($children) {}
        /**
         * @return DependencyRelationship
         */
        public function getRelationship() {}
        public function setRelationship(DependencyRelationship $relationship) {}
        /**
         * @return array
         */
        private function serialize() {}
    }

}

namespace Bolt\Composer\EventListener {
    /**
     * Package reference descriptor.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class PackageDescriptor implements \jsonserializable {
        /** @var string */
        private $name;
        /** @var string */
        private $class;
        /** @var string */
        private $path;
        /** @var string */
        private $webPath;
        /** @var string */
        private $constraint;
        /** @var bool */
        private $valid;

        public function __construct($name, $class, $path, $webPath, $constraint, $valid) {}
        /**
         * @return string
         */
        public function getName() {}
        /**
         * @return string
         */
        public function getClass() {}
        /**
         * @return string
         */
        public function getPath() {}
        /**
         * @return string
         */
        public function getWebPath() {}
        /**
         * @return string
         */
        public function getConstraint() {}
        /**
         * @return bool
         */
        public function isValid() {}
        public static function parse(Composer $composer, $webPath, $path, array $jsonData) {}
        public static function create(array $data) {}
        /**
         * {@inheritdoc}
         */
        public function jsonSerialize() {}
        private static function parseClass(array $jsonData) {}
        private static function parseConstraint(array $jsonData) {}
        private static function parseValid(Composer $composer, $class, $constraint) {}
    }

    /**
     * Composer action listeners.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class BufferIOListener implements \composer\eventdispatcher\eventsubscriberinterface {
        /** @var \Bolt\Composer\PackageManager $manager */
        protected $manager;
        /** @var LoggerInterface */
        protected $logger;

        public function __construct(PackageManager $manager, LoggerInterface $logger) {}
        public function onPrePackage(PackageEvent $event) {}
        public function onPostPackage(PackageEvent $event) {}
        /**
         * Return the events to subscribe to.
         *
         * @return array
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * Event listener for extension Composer operations.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class PackageEventListener {
        public static function handle(PackageEvent $event) {}
/** @var PackageDescriptor[] $extensions */
        public static function dump(/** @var PackageDescriptor[] $extensions */
Event $event) {}
        public static function mirror($source, $dest, PackageEvent $event) {}
        /**
         * Return all the installed extension composer.json files.
         *
         * @return Finder|SplFileInfo[]
         */
        private static function getInstalledComposerJson() {}
    }

}

namespace Bolt\Provider {
    /**
     * @author Carson Full <carsonfull@gmail.com>
     */
    class FilesystemServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Session service provider.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class SessionServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Register thumbnails service.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ThumbnailsServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
        private function findDefaultImage(Application $app, $name) {}
    }

    class PrefillServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class PathServiceProvider implements \silex\serviceproviderinterface {
        private $deprecatedResources;

        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Canonical service provider.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class CanonicalServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class CacheServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class TwigServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
        protected function registerSandbox(Application $app) {}
    }

    /**
     * 1st phase: Registers our services. Registers extensions on boot.
     * 2nd phase: Boots extensions on boot.
     */
    class ExtensionServiceProvider implements \silex\serviceproviderinterface {
        /** @var bool */
        private $firstPhase;

        public function __construct($firstPhase = true) {}
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class StackServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class TranslationServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
/** @var \SplFileInfo $fileInfo */
        public static function addResources(/** @var \SplFileInfo $fileInfo */
Application $app, /** @var \SplFileInfo $fileInfo */
$locale) {}
        protected function mergeGenericLocales(array $inputLocales) {}
        protected function mergeUtf8Locales(array $inputLocales) {}
        protected function setDefaultTimezone(Application $app) {}
    }

    class UsersServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * @author Benjamin Georgeault <benjamin@wedgesama.fr>
     */
    class FilePermissionsServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class AccessControlServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * SwiftMailer integration.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class MailerServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Bolt security service provider.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SecurityServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class PermissionsServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Class to handle uploads.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UploadServiceProvider implements \silex\serviceproviderinterface {
/** @var Filesystem $filesystem */
        public function register(/** @var Filesystem $filesystem */
Application $app) {}
        public function boot(Application $app) {}
    }

    class QueryServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class NutServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class CronServiceProvider implements \silex\serviceproviderinterface {
        public function register(Silex\Application $app) {}
        public function boot(Silex\Application $app) {}
    }

    class ConfigServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
/** @var EventDispatcherInterface $dispatcher */
        public function boot(/** @var EventDispatcherInterface $dispatcher */
Application $app) {}
    }

    /**
     * Embed service provider.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class EmbedServiceProvider implements \silex\serviceproviderinterface {
/** @var \Embed\Adapters\Adapter $info */
        public function register(/** @var \Embed\Adapters\Adapter $info */
Application $app) {}
        public function boot(Application $app) {}
    }

    class MarkdownServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class RenderServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class GuzzleServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * HTML asset service providers.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class AssetServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class OmnisearchServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Only use TraceableEventDispatcher and Profiler if $app['debug'] is true.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class WebProfilerServiceProvider extends \silex\provider\webprofilerserviceprovider {
        public function register(Application $app) {}
    }

    class TemplateChooserServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class PagerServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Bolt database storage service provider.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DatabaseSchemaServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class RandomGeneratorServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class RoutingServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Database provider.
     *
     * @author Carson Full <carsonfull@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DatabaseServiceProvider implements \silex\serviceproviderinterface {
/** @var \Bolt\Storage\Database\Connection|\Bolt\Storage\Database\MasterSlaveConnection $db */
        public function register(/** @var \Bolt\Storage\Database\Connection|\Bolt\Storage\Database\MasterSlaveConnection $db */
Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Validator service provider.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ValidatorServiceProvider extends \silex\provider\validatorserviceprovider {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ProfilerServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Monolog provider for Bolt system logging entries.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class LoggerServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Register form services.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class FormServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

    class EventListenerServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
/** @var EventDispatcherInterface $dispatcher */
        public function boot(/** @var EventDispatcherInterface $dispatcher */
Application $app) {}
    }

    class StorageServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
/** @var \Symfony\Component\EventDispatcher\EventDispatcherInterface $dispatcher */
        public function boot(/** @var \Symfony\Component\EventDispatcher\EventDispatcherInterface $dispatcher */
Application $app) {}
    }

    class MenuServiceProvider implements \silex\serviceproviderinterface {
/** @var Stopwatch $watch */
        public function register(/** @var Stopwatch $watch */
Application $app) {}
        public function boot(Application $app) {}
    }

    /**
     * Configure Error & Exception Handlers, DebugClassLoader, and debug value.
     *
     * This should be registered first, so that the handlers can be registered
     * before other boot logic happens and services are invoked.
     *
     * 1. There is no error / exception handlers during app creation and registration stage. This is a very small window,
     *    since closures are just being registered (no logic). Extensions are not loaded either.
     * 2. App Boot
     *   2.a. Debug 1st phase: Error & exception handlers are registered based on `debug.early`'s value.
     *        There should be no logic required to get this value.
     *   2.b. Extensions 1st phase: Extensions are registered.
     *   2.c. Debug 2nd phase: The "real" `debug` value is retrieved from config, which means all the logic to setup config
     *        is ran. This is where everything starts happening. Then the handlers are re-registered if their configuration
     *        has changed.
     *   2.d. Extensions 2nd phase: Extensions are booted.
     *   2.e. App continues to boot everything else.
     * 3. Kernel Request
     *   3.a. Our early exception handler is replaced with either the HttpKernel or Console App exception handling.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class DebugServiceProvider implements \silex\serviceproviderinterface {
        /** @var bool */
        private $firstPhase;

        public function __construct($firstPhase = true) {}
        public function register(Application $app) {}
        public function boot(Application $app) {}
        private function registerHandlers(Application $app) {}
        private function configureLogger(ErrorHandler $handler, LoggerInterface $logger, $loggedAt) {}
    }

    class ControllerServiceProvider implements \symfony\component\eventdispatcher\eventsubscriberinterface, \silex\serviceproviderinterface {
/** @deprecated Deprecated since 3.3, to be removed in 4.0. */
        public function register(/** @deprecated Deprecated since 3.3, to be removed in 4.0. */
Application $app) {}
/** @deprecated Deprecated since 3.0, to be removed in 4.0. */
        public function boot(/** @deprecated Deprecated since 3.0, to be removed in 4.0. */
Application $app) {}
        public function onMountFrontend(MountEvent $event) {}
        public function onMountBackend(MountEvent $event) {}
        public static function getSubscribedEvents() {}
    }

    /**
     * DI for Symfony's VarDumper.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class DumperServiceProvider implements \silex\serviceproviderinterface {
        public function register(Application $app) {}
        public function boot(Application $app) {}
    }

}

namespace Bolt\Legacy {
    /**
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     */
    abstract class BaseExtension extends \bolt\extension\simpleextension {
        public $config;
        protected $app;
        protected $installtype;
        private $extensionConfig;
        private $composerJsonLoaded;
        private $composerJson;

        public function __construct(Application $app) {}
        /**
         * {@inheritdoc}
         */
        protected function getApp() {}
        public function setInstallType($type) {}
        /**
         * Get the extension type.
         *
         * @return string
         */
        public function getInstallType() {}
        /**
         * Gets the Composer name, e.g. 'bolt/foobar-extension'.
         *
         * @return string|null The Composer name for this extension, or NULL if the
         *                     extension is not composerized.
         */
        public function getComposerName() {}
        /**
         * Get the contents of the extension's composer.json file, lazy-loading
         * as needed.
         */
        public function getComposerJSON() {}
        public function setComposerConfiguration(array $configuration) {}
        /**
         * Builds an array suitable for conversion to JSON, which in turn will end
         * up in a consolidated JSON file containing the configurations of all
         * installed extensions.
         */
        public function getExtensionConfig() {}
        /**
         * Allow use of the extension's Twig function in content records when the
         * content type has the setting 'allowtwig: true' is set.
         *
         * @return boolean
         */
        public function isSafe() {}
        /**
         * Return the available Snippets, used in \Bolt\Extensions.
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use $app['asset.queue.snippet']->getQueue()
         *
         * @return array
         */
        public function getSnippets() {}
        /**
         * Returns a list of all css and js assets that are added via extensions.
         *
         * @return array
         */
        public function getAssets() {}
        /**
         * Clear all previously added assets.
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         */
        public function clearAssets() {}
        public function addMenuOption($label, $path, $icon = null, $requiredPermission = null) {}
        public function parseSnippet($callback, $var1 = '', $var2 = '', $var3 = '') {}
    }

    /**
     * Legacy Content class.
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     */
    class Content implements \arrayaccess {
    use \bolt\storage\entity\contenttypetrait, \bolt\storage\entity\contentrelationtrait, \bolt\storage\entity\contentsearchtrait, \bolt\storage\entity\contentroutetrait, \bolt\storage\entity\contenttaxonomytrait, \bolt\storage\entity\contentvaluestrait;

        public $id;
        public $values;
        public $taxonomy;
        public $relation;
        public $contenttype;
        public $user;
        public $sortorder;
        public $config;
        public $group;
        /** @var \Silex\Application */
        protected $app;

        public function __construct(Silex\Application $app, $contenttype = '', $values = [ ], $isRootType = true) {}
        /**
         * Gets a list of the base columns that are hard-coded into all content
         * types (rather than configured through contenttypes.yml).
         */
        public static function getBaseColumns() {}
        public function setContenttype($contenttype) {}
        public function getDecodedValue($name) {}
        public function getRenderedValue($fieldName) {}
        public function preParse($snippet, $allowtwig) {}
        public function getTemplateContext() {}
        public function __call($name, $arguments) {}
        public function previous($field = 'datepublish', $where = [ ]) {}
        public function next($field = 'datepublish', $where = [ ]) {}
        public function offsetExists($offset) {}
        public function offsetGet($offset) {}
        public function offsetSet($offset, $value) {}
        public function offsetUnset($offset) {}
    }

    /**
     * Don't use this. Period.
     *
     * This is the same singleton ResourceManager had. It has just been pulled out so other
     * deprecated parts of the codebase don't have to be coupled to ResourceManager.
     *
     * @deprecated Deprecated since 3.3, to be removed in 4.0.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class AppSingleton {
        /** @var Application */
        static private $app;

        /**
         * Wrong.
         *
         * @return Application
         */
        public static function get() {}
        public static function set(Application $app) {}
    }

    /**
     * Legacy Storage class.
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     */
    class Storage {
        /** @var array */
        public $images;
        /** @var Application */
        private $app;
        /** @var array */
        private $tables;
        /** @var string */
        private $prefix;
        /** @var array */
        private $checkedfortimed;
        /** @var bool Test to indicate if we're inside a dispatcher. */
        private $inDispatcher;

        public function __construct(Application $app) {}
        public function getContentObject($contenttype, $values = [ ], $isRootType = true) {}
/** @var \Bolt\Storage\Database\Prefill\Builder $builder */
        public function preFill(/** @var \Bolt\Storage\Database\Prefill\Builder $builder */
$contentTypes = [ ]) {}
        private function logInsert($contenttype, $contentid, $content, $comment = null) {}
        private function logUpdate($contenttype, $contentid, $newContent, $oldContent = null, $comment = null) {}
        private function logDelete($contenttype, $contentid, $content, $comment = null) {}
        public function saveContent(Content $content, $comment = null) {}
        public function deleteContent($contenttype, $id) {}
        protected function insertContent(Content $content, $comment = null) {}
        private function updateContent(Content $content, $comment = null) {}
        private function getValidSaveData(array $fieldvalues, array $contenttype) {}
        public function updateSingleValue($contenttype, $id, $field, $value) {}
        public function getEmptyContent($contenttypeslug) {}
        private function decodeSearchQuery($q) {}
        private function searchSingleContentType($query, $contenttype, $fields, array $filter = null, $implode = false) {}
        private function compareSearchWeights(Content $a, Content $b) {}
        public function searchContent($q, array $contenttypes = null, array $filters = null, $limit = 9999, $offset = 0) {}
        public function searchAllContentTypes(array $parameters = [ ], $pager = [ ]) {}
/** @var \Bolt\Pager\PagerManager $manager */
        public function searchContentType(/** @var \Bolt\Pager\PagerManager $manager */
$contenttypename, /** @var \Bolt\Pager\PagerManager $manager */
array $parameters = [ ], /** @var \Bolt\Pager\PagerManager $manager */
$pager = [ ]) {}
/** @var \Bolt\Pager\PagerManager $manager */
        public function getContentByTaxonomy(/** @var \Bolt\Pager\PagerManager $manager */
$taxonomyslug, /** @var \Bolt\Pager\PagerManager $manager */
$name, /** @var \Bolt\Pager\PagerManager $manager */
$parameters = [ ]) {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         * @see        \Bolt\Storage\EventProcessor\TimedRecord::publishTimedRecords()
         */
        public function publishTimedRecords() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         * @see        \Bolt\Storage\EventProcessor\TimedRecord::holdExpiredRecords()
         */
        public function depublishExpiredRecords() {}
        private function organizeQueryParameters($inParameters = null) {}
        private function decodeContentTypesFromText($text) {}
        private function parseTextQuery($textquery, array $decoded, array $metaParameters, array $ctypeParameters) {}
        private function prepareDecodedQueryForUse($decoded, $metaParameters, $ctypeParameters) {}
        private function decodeQueryOrder($contenttype, $orderValue) {}
        private function decodeContentQuery($textquery, $inParameters = null) {}
        protected function decodePageParameter($context = '', $inParameters = null) {}
        private function hydrateRows($contenttype, $rows, $getTaxoAndRel = true) {}
        protected function executeGetContentSearch($decoded, $parameters) {}
        protected function executeGetContentQueries($decoded) {}
/** @var \Bolt\Pager\PagerManager $manager */
        public function getContent(/** @var \Bolt\Pager\PagerManager $manager */
$textquery, /** @var \Bolt\Pager\PagerManager $manager */
$parameters = '', /** @var \Bolt\Pager\PagerManager $manager */
$pager = [ ], /** @var \Bolt\Pager\PagerManager $manager */
$whereparameters = [ ]) {}
        private function runContentTypeTableChecks(array $contenttypes) {}
        private function isValidColumn($name, $contenttype, $allowVariants = false) {}
        private function getFieldName($name) {}
        private function getEscapedSortorder($name, $prefix = 'r') {}
        protected function isNotLastItemInArray($totalOrderByElements, $index) {}
        protected function getOrderBys($order) {}
        protected function isMultiOrderQuery($order) {}
        public function getSortOrder($name = '-datepublish') {}
        private function groupingSort(Content $a, Content $b) {}
        private function parseWhereParameter($key, $value, $fieldtype = false) {}
        public function getContentType($contenttypeslug) {}
        public function getTaxonomyType($taxonomyslug) {}
        /**
         * Get an array of the available contenttypes.
         *
         * @return array $contenttypes
         */
        public function getContentTypes() {}
        public function getContentTypeFields($contenttypeslug) {}
        public function getContentTypeFieldType($contenttypeslug, $fieldname) {}
        public function getContentTypeGrouping($contenttypeslug) {}
        public function getContentTypeTaxonomy($contenttypeslug) {}
        protected function getTaxonomy($content) {}
        protected function updateTaxonomy($contenttype, $contentId, $taxonomy) {}
        protected function getRelation($content) {}
        public function getRepeaters($content) {}
        protected function updateRelation($contenttype, $contentId, $relation) {}
        public function getLatestId($contenttypeslug) {}
        public function getUri($title, $id = 0, $contenttypeslug = "", $fulluri = true, $allowempty = true, $slugfield = 'slug') {}
        protected function tableExists($name) {}
        public function getTablename($name) {}
        public function getContenttypeTablename($contenttype) {}
        protected function hasRecords($tablename) {}
        protected function findContent($tablename, $contentId) {}
        public function setPager($name, $pager) {}
        public function &getPager($name = null) {}
        /**
         * @return bool
         */
        public function isEmptyPager() {}
    }

    /**
     * Class Pager
     * -----------
     *  Legacy class to keep compatibility for a while.
     *  It is just for remap deprecated properties like showing_from -> showingFrom
     *
     * @deprecated Deprecated since 3.3, to be removed in 4.0.
     */
    abstract class AbstractPager implements \arrayaccess {
        /**
         * @var \Bolt\Pager\PagerManager
         */
        public $manager;

        public function __get($name) {}
        public function __set($name, $value) {}
        public function __isset($name) {}
        public function offsetExists($offset) {}
        public function offsetGet($offset) {}
        public function offsetSet($offset, $value) {}
        public function offsetUnset($offset) {}
        protected function getCamelPropName($name) {}
        protected function camelize($varname) {}
    }

}

namespace Bolt\Legacy\PasswordLib {
    /**
     * A PasswordLib Random Generator that uses random_bytes.
     *
     * @internal
     *
     * @deprecated Deprecated since 3.3, to be removed in 4.0.
     */
    final class PasswordLibRandomGenerator extends \passwordlib\random\generator {
        /**
         * Constructor.
         */
        public function __construct() {}
        public function generate($size) {}
        public function generateInt($min = 0, $max = PHP_INT_MAX) {}
        public function generateString($length, $characters = '') {}
        public function addSource(Source $source) {}
        /**
         * {@inheritdoc}
         */
        public function getMixer() {}
        /**
         * {@inheritdoc}
         */
        public function getSources() {}
    }

    /**
     * A PasswordLib Factory that uses our random generator.
     *
     * @internal
     *
     * @deprecated Deprecated since 3.3, to be removed in 4.0.
     */
    final class PasswordLibFactory extends \passwordlib\password\factory {
        /** @var AbstractPassword[] */
        protected $implementations;
        /** @var PasswordLibRandomGenerator */
        private $generator;

/** @var AbstractPassword $instance */
        public function createHash(/** @var AbstractPassword $instance */
$password, /** @var AbstractPassword $instance */
$prefix = '$2a$') {}
/** @var AbstractPassword $instance */
        public function verifyHash(/** @var AbstractPassword $instance */
$password, /** @var AbstractPassword $instance */
$hash) {}
        private function getGenerator() {}
    }

}

namespace Bolt\Filesystem {
    class UploadContainer implements \sirius\upload\container\containerinterface {
        /** @var FilesystemInterface */
        private $filesystem;

        public function __construct(FilesystemInterface $filesystem) {}
        /**
         * {@inheritdoc}
         */
        public function isWritable() {}
        public function has($file) {}
        public function save($file, $content) {}
        public function delete($file) {}
        public function moveUploadedFile($localFile, $destination) {}
    }

    /**
     * File and directory listing handler.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class Listing {
        /** @var DirectoryInterface */
        private $directory;
        /** @var HandlerInterface[] */
        private $contents;

        public function __construct(DirectoryInterface $directory) {}
        public function getDirectories($showHidden = false) {}
        public function getFiles($showHidden = false) {}
        /**
         * Does the web server user have read/write file system permissions to the
         * target directory, see {@see \Bolt\Filesystem\Plugin\Authorized}.
         *
         * @deprecated since 3.3 to be removed in 4.0.
         *
         * @throws Exception\IOException
         *
         * @return bool
         */
        public function isAuthorized() {}
        /**
         * Lazy load & cache the directory contents.
         *
         * @return HandlerInterface[]
         */
        private function getContents() {}
    }

    /**
     * Use to check if an access to a file is allowed.
     *
     * @author Benjamin Georgeault <benjamin@wedgesama.fr>
     */
    class FilePermissions {
        /** @var Config */
        protected $config;
        /** @var string[] List of Filesystem prefixes that are editable. */
        protected $allowedPrefixes;
        /** @var array Regex list represented editable resources. */
        protected $allowed;
        /** @var array Regex list represented resources forbidden for edition. */
        protected $blocked;
        /** @var float Maximum upload size allowed by PHP, in bytes. */
        protected $maxUploadSize;

        public function __construct(Config $config) {}
        public function authorized($prefix, $path) {}
        public function allowedUpload($originalFilename) {}
        /**
         * Get the array of configured acceptable file extensions.
         *
         * @return array
         */
        public function getAllowedUploadExtensions() {}
        /**
         * Get the maximum upload size the server is configured to accept.
         *
         * @return float
         */
        public function getMaxUploadSize() {}
        /**
         * Get the max upload value in a formatted string.
         *
         * @return string
         */
        public function getMaxUploadSizeNice() {}
    }

    /**
     * This is designed to help migrate us to our new filesystem abstraction which
     * requires mount points. During this transition period we need to be able to
     * match paths without mount points to a filesystem.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Matcher {
        /** @var FilesystemInterface */
        protected $filesystem;
        /** @var string[] */
        protected $filesystemsToCheck;

        public function __construct(FilesystemInterface $filesystem, array $filesystemsToCheck) {}
        public function getFile($path, $throwException = true) {}
        public function getImage($path, $throwException = true) {}
        private function containsMountPoint($path) {}
    }

}

namespace Bolt\Filesystem\Handler {
    /**
     * Image used for twig where exceptions cannot be caught.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class NullableImage extends \bolt\filesystem\handler\image {
        public function getInfo($cache = true) {}
        /**
         * {@inheritdoc}
         */
        public function getType() {}
    }

}

namespace Bolt\Filesystem\Plugin {
    /**
     * Declare that the filesystem cannot use "url" method.
     *
     * Useful when the AssetUrl plugin is used AND when the filesystem mount point matches an asset package,
     * but you don't want to use that one.
     */
    class NoAssetUrl implements \bolt\filesystem\plugininterface {
    use \bolt\filesystem\plugin\plugintrait;

        /**
         * {@inheritdoc}
         */
        public function getMethod() {}
        public function handle() {}
    }

    /**
     * Connects filesystem to FilePermissions class.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Authorized implements \bolt\filesystem\plugininterface {
    use \bolt\filesystem\plugin\plugintrait;

        /** @var FilePermissions */
        protected $filePermissions;

        public function __construct(FilePermissions $filePermissions) {}
        /**
         * {@inheritdoc}
         */
        public function getMethod() {}
        public function handle($path) {}
    }

    /**
     * Generates thumbnail urls.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ThumbnailUrl implements \bolt\filesystem\plugininterface {
    use \bolt\filesystem\plugin\plugintrait;

        /** @var UrlGeneratorInterface */
        protected $urlGenerator;

        public function __construct(UrlGeneratorInterface $urlGenerator) {}
        /**
         * {@inheritdoc}
         */
        public function getMethod() {}
        public function handle($path, $width, $height, $action) {}
    }

    /**
     * Returns a list of parent directory objects for a path.
     *
     * Example: parents("a/b/c") // [b, a, (root)]
     */
    class Parents implements \bolt\filesystem\plugininterface {
    use \bolt\filesystem\plugin\plugintrait;

        /**
         * {@inheritdoc}
         */
        public function getMethod() {}
        public function handle($path) {}
    }

    /**
     * Returns intrinsic data about file as well as some pre-generated links for JS to use.
     *
     * Goal of this plugin is to always give JS consistent data about a file in a DRY way.
     */
    class ToJs implements \bolt\filesystem\plugininterface {
    use \bolt\filesystem\plugin\plugintrait;

        /**
         * {@inheritdoc}
         */
        public function getMethod() {}
        public function handle($path) {}
    }

    /**
     * Returns the public url/path of an asset (filesystem path).
     *
     * If this plugin is given packages and the filesystem has a mount point
     * it will be used as the package name for getting the url.
     *
     * For example:
     *
     *  // $fs = Bolt\Filesystem\Manager
     *  $fs->url('foo://bar.jpg');
     *
     * Uses the package "foo" in the Packages class to generate url.
     */
    class AssetUrl implements \bolt\filesystem\plugininterface {
    use \bolt\filesystem\plugin\plugintrait;

        /** @var Packages|PackageInterface */
        protected $packages;

        public function __construct($packages) {}
        /**
         * {@inheritdoc}
         */
        public function getMethod() {}
        public function handle($path) {}
    }

    /**
     * Determines if the path has a url by try-catching the url plugin.
     */
    class HasUrl implements \bolt\filesystem\plugininterface {
    use \bolt\filesystem\plugin\plugintrait;

        /**
         * {@inheritdoc}
         */
        public function getMethod() {}
        public function handle($path) {}
    }


    /**
     * Trait to shortcut filesystem setter for plugins.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait PluginTrait {
        /** @var FilesystemInterface */
        protected $filesystem;
        public function setFilesystem(FilesystemInterface $filesystem) {}
    }

}

namespace Bolt\Filesystem\Exception {
    class DefaultImageNotFoundException extends \bolt\filesystem\exception\filenotfoundexception {
        public function __construct($message, $path, \Exception $previous = null) {}
    }

}

namespace Bolt\Storage {
    /**
     * Handles Object to DB naming adjustments.
     */
    class NamingStrategy implements \bolt\storage\namingstrategyinterface {
        public $prefix;

        public function __construct($prefix = 'bolt_') {}
        public function classToTableName($className) {}
        public function classToAlias($className) {}
        public function getRelativeClass($className) {}
    }

    /**
     * Legacy bridge for Content object backward compatibility.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class ContentLegacyService {
    use \bolt\storage\entity\contentvaluestrait, \bolt\storage\entity\contenttaxonomytrait, \bolt\storage\entity\contentsearchtrait, \bolt\storage\entity\contentroutetrait, \bolt\storage\entity\contentrelationtrait;

        protected $app;

        public function __construct(Application $app) {}
        public function initialize(Entity\Entity $entity) {}
        public function setupContenttype(Entity\Entity $entity) {}
    }

    /**
     * This class works keeps a set of queries that will eventually
     * be executed sequentially.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class QuerySet extends \arrayiterator {
        protected $resultCallbacks;
        protected $lastInsertId;
        protected $parentId;

        public function append($qb) {}
        /**
         * Execute function, iterate the queries, and execute them sequentially.
         *
         * @throws \Exception
         *
         * @return \Doctrine\DBAL\Driver\Statement|int|null
         */
        public function execute() {}
        public function onResult(callable $callback) {}
        /**
         * Getter method to return last insert ID from query.
         *
         * @return int|null
         */
        public function getInsertId() {}
        private function setLastInsertId(QueryBuilder $query) {}
        /**
         * @return mixed
         */
        public function getParentId() {}
        public function setParentId($parentId) {}
        /**
         * A helper method to get the primary database query from a set. Normally this points to the first in the set.
         *
         * @return QueryBuilder
         */
        public function getPrimary() {}
    }

    /**
     * Lazy-loading EntityManager.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class LazyEntityManager implements \bolt\storage\entitymanagerinterface {
        /** @var callable $factory */
        private $factory;
        /** @var EntityManager $urlGenerator */
        private $em;

        public function __construct(callable $factory) {}
        /**
         * @return EntityManager
         */
        public function getEntityManager() {}
        public function getRepository($className) {}
        public function getContent($textQuery, $parameters = [ ], $pager = [ ], $whereParameters = [ ]) {}
    }

    /**
     * Uses a typemap to construct an instance of a Field.
     */
    class FieldManager {
        /** @var EntityManager */
        protected $em;
        protected $handlers;
        protected $typemap;
        /** @var Config */
        protected $boltConfig;
        /** @var SanitiserInterface */
        protected $sanitiser;
        protected $customHandlers;

        public function __construct(array $typemap, Config $config, SanitiserInterface $sanitiser) {}
        public function setEntityManager(EntityManager $em = null) {}
        public function get($class, $mapping) {}
        public function getFieldFor($type) {}
        public function setHandler($class, $handler) {}
        public function addFieldType($name, Field\FieldInterface $field) {}
        public function hasCustomHandler($name) {}
    }

    /**
     * Manages all loaded entities across application, provides access to Repository
     * Classes.
     *
     * Legacy methods:
     *
     * @method array getContentType($contenttypeslug)
     * @method void  publishTimedRecords($contenttype)
     * @method void  depublishExpiredRecords($contenttype)
     */
    class EntityManager implements \bolt\storage\entitymanagerinterface {
        /** @var Connection */
        protected $conn;
        /** @var EventDispatcherInterface */
        protected $eventManager;
        /** @var MetadataDriver */
        protected $mapping;
        /** @var LoggerInterface */
        protected $logger;
        /** @var Entity\Builder */
        protected $builder;
        /** @var FieldManager */
        protected $fieldManager;
        /** @var CollectionManager */
        protected $collectionManager;
        /** @var array */
        protected $repositories;
        /** @var array */
        protected $aliases;
        /** @var Storage */
        protected $legacyStorage;
        /** @var callable */
        protected $defaultRepositoryFactory;
        /** @var  ContentLegacyService */
        protected $legacyService;

        public function __construct(Connection $conn, EventDispatcherInterface $eventManager, MetadataDriver $mapping, LoggerInterface $logger = null) {}
        /**
         * @return QueryBuilder
         */
        public function createQueryBuilder() {}
        /**
         * @return ExpressionBuilder
         */
        public function createExpressionBuilder() {}
        public function create($className, $data, ClassMetadataInterface $metadata = null) {}
        public function getEntityBuilder($className = null, ClassMetadata $classMetadata = null) {}
        public function setEntityBuilder(Entity\Builder $builder) {}
        /**
         * @return FieldManager
         */
        public function getFieldManager() {}
        public function setFieldManager(FieldManager $fieldManager) {}
        /**
         * @return CollectionManager
         */
        public function getCollectionManager() {}
        public function setCollectionManager(CollectionManager $collectionManager) {}
        public function createCollection($className) {}
        public function find($className, $id) {}
        public function save($object) {}
        public function delete($object) {}
/** @var ContentRepository $repo */
        public function getRepository(/** @var ContentRepository $repo */
$className) {}
        public function setRepository($entityName, $repositoryClass) {}
        public function setDefaultRepositoryFactory(callable $factory) {}
        public function getDefaultRepositoryFactory($classMetadata) {}
        /**
         * Gets the DBAL Driver Connection.
         *
         * @return Connection
         */
        public function getConnection() {}
        /**
         * Gets the Event Manager.
         *
         * @return EventDispatcherInterface
         */
        public function getEventManager() {}
        /**
         * Gets the Class Metadata Driver.
         *
         * @return MetadataDriver
         */
        public function getMapper() {}
        public function addEntityAlias($alias, $namespace) {}
        /**
         * Returns a proxy to the legacy storage service.
         *
         * @return Storage
         */
        public function legacy() {}
        public function setLegacyStorage(Storage $storage) {}
        public function setLegacyService(ContentLegacyService $service) {}
        /**
         * Getter for logger object.
         *
         * @return LoggerInterface
         */
        public function getLogger() {}
        public function __call($method, array $args) {}
        public function getContent($textquery, $parameters = [ ], $pager = [ ], $whereparameters = [ ]) {}
    }

    /**
     *  This class is used by lazily loaded entities. It stores a reference to an entity but only
     *  fetches it on demand.
     */
    class EntityProxy {
        /** @var string */
        public $entity;
        /** @var string */
        public $reference;
        /** @var bool */
        protected $loaded;
        /** @var object */
        protected $proxy;
        /** @var EntityManager|null */
        private $em;

        public function __construct($entity, $reference, EntityManager $em = null) {}
        public function load() {}
        public function __call($method, $args) {}
        public function __get($attribute) {}
        public function __set($attribute, $value) {}
        /**
         * @return object
         */
        public function getProxy() {}
    }

    /**
     * A default repository class that other repositories can inherit to provide more specific features.
     */
    class Repository implements \doctrine\common\persistence\objectrepository {
        /** @var EntityManager */
        public $em;
        /** @var ClassMetadata */
        public $_class;
        /** @var string */
        public $entityName;
        /** @var Builder */
        public $builder;

        public function __construct($em, ClassMetadata $classMetadata) {}
/** @var Entity $entity */
        public function create(/** @var Entity $entity */
$params = [ ], /** @var Entity $entity */
ClassMetadata $metadata = null) {}
        public function createQueryBuilder($alias = null) {}
        /**
         * Return the number of rows used in this repository table.
         *
         * @return int
         */
        public function count() {}
        public function find($id) {}
        /**
         * {@inheritdoc}
         */
        public function findAll() {}
        public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) {}
        public function findOneBy(array $criteria, array $orderBy = null) {}
        protected function findWithCriteria(array $criteria, array $orderBy = null, $limit = null, $offset = null) {}
        public function findWith(QueryBuilder $query) {}
        public function findOneWith(QueryBuilder $query) {}
        public function queryWith(QueryInterface $query) {}
        /**
         * Internal method to initialise and return a QueryBuilder instance.
         * Note that the metadata fields will be passed the instance to modify where appropriate.
         *
         * @return QueryBuilder
         */
        protected function getLoadQuery() {}
        protected function load(QueryBuilder $query) {}
        protected function query(QueryInterface $query) {}
        protected function persist(QuerySet $queries, $entity, $exclusions = [ ]) {}
        public function delete($entity) {}
        public function save($entity, $silent = null) {}
        public function insert($entity) {}
        public function update($entity, $exclusions = [ ]) {}
        protected function hydrate(array $data, QueryBuilder $qb) {}
        protected function hydrateAll(array $data, QueryBuilder $qb) {}
        protected function refresh($entity) {}
        /**
         * Fetches FieldManager instance from the EntityManager.
         *
         * @return FieldManager
         */
        public function getFieldManager() {}
        /**
         * @return Builder $builder
         */
        public function getEntityBuilder() {}
        /**
         * @return string
         */
        public function getEntityName() {}
        /**
         * @return string
         */
        public function getClassName() {}
        /**
         * @return string
         */
        public function getTableName() {}
        /**
         * @return string
         */
        public function getAlias() {}
        /**
         * @return EntityManager
         */
        public function getEntityManager() {}
        /**
         * Getter for class metadata.
         *
         * @return ClassMetadata
         */
        public function getClassMetadata() {}
        /**
         * Shortcut method to fetch the Event Dispatcher.
         *
         * @return \Symfony\Component\EventDispatcher\EventDispatcherInterface
         */
        public function event() {}
    }


    /**
     * Handles Object to DB naming adjustments.
     */
    interface NamingStrategyInterface {
        function classToTableName($className) ;
        function classToAlias($className) ;
    }

    /**
     * EntityManager interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface EntityManagerInterface {
        function getRepository($className) ;
    }


    /**
     *  This trait provides re-usable methods for converting strings between different case styles.
     */
    trait CaseTransformTrait {
        public function camelize($id) {}
        public function underscore($id) {}
    }

}

namespace Bolt\Storage\Mapping {
    /**
     * This is a Bolt specific metadata driver that provides mapping information
     * for the internal and user-defined schemas. To do this it takes in the
     * constructor, an instance of Bolt\Storage\Database\Schema\Manager and uses
     * this to read in the schema.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class MetadataDriver implements \doctrine\common\persistence\mapping\driver\mappingdriver {
    use \bolt\storage\casetransformtrait;

        /** @var \Bolt\Storage\Database\Schema\Manager */
        protected $schemaManager;
        /** @var array */
        protected $contenttypes;
        /** @var array taxonomy configuration */
        protected $taxonomies;
        /** @var array metadata mappings */
        protected $metadata;
        /** @var array */
        protected $defaultAliases;
        /** @var array */
        protected $typemap;
        /** @var NamingStrategy */
        protected $namingStrategy;
        /** @var array */
        protected $aliases;
        /** @var array */
        protected $generalConfig;
        /**
         * Keeps a reference of which metadata is not mapped to
         * a specific entity.
         *
         * @var array
         */
        protected $unmapped;
        /** @var string A default entity for any table not matched */
        protected $fallbackEntity;
        /** @var bool */
        protected $initialized;

        public function __construct(Manager $schemaManager, ConfigurationValueProxy $contenttypes, ConfigurationValueProxy $taxonomies, array $typemap, NamingStrategy $namingStrategy = null) {}
        /**
         * Reads the schema from Bolt\Storage\Database\Schema\Manager and creates mapping data.
         */
        public function initialize() {}
        /**
         * Setup some short aliases so non prefixed keys can be used to get metadata.
         */
        public function initializeShortAliases() {}
        /**
         *  This seeds the defaultAliases array with the correctly prefixed mappings.
         */
        public function initializeDefaultAliases() {}
        /**
         * Getter for aliases.
         *
         * @return array
         */
        public function getAliases() {}
        public function resolveClassName($alias) {}
        protected function loadMetadataForTable(Table $table) {}
        public function setRepeaters($contentKey, $className, $inputData = null) {}
        protected function postProcessField(array $field) {}
        public function setGeneralConfig($config) {}
        protected function normalizeFieldTypes(array $fields) {}
        public function getRepeaterMapping(array $config) {}
        public function setRelations($contentKey, $className) {}
        public function setIncomingRelations($contentKey, $className) {}
        public function setTaxonomies($contentKey, $className) {}
        public function setTemplatefields($contentKey, $className) {}
        public function setContentFields($contentKey, $className, $table) {}
        public function loadMetadataForClass($className, ClassMetadata $metadata = null) {}
        public function loadMetadataForFields(array $fields) {}
        public function getFieldTypeFor($name, $column, $field = null) {}
        public function getFieldMetadata($contentType, $column, $field = null) {}
        /**
         * {@inheritdoc}
         */
        public function getAllClassNames() {}
        /**
         * Gets a list of tables that are not mapped to specific entities.
         *
         * @return array
         */
        public function getUnmapped() {}
        public function setDefaultAlias($alias, $entity) {}
        public function getClassMetadata($className) {}
        protected function normalizeClassName($className) {}
        public function isTransient($className) {}
        /**
         * @return array
         */
        public function getTaxonomyConfig() {}
        public function getContentTypeFromAlias($alias, $forceSlug = false) {}
    }

    /**
     * Taxonomy mapping.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class TaxonomyValue implements \arrayaccess {
        /** @var string */
        protected $name;
        /** @var string */
        protected $value;
        /** @var array */
        protected $data;

        public function __construct($name, $value, array $data) {}
        public function __toString() {}
        public function offsetSet($offset, $value) {}
        public function offsetExists($offset) {}
        public function offsetUnset($offset) {}
        public function offsetGet($offset) {}
    }

    /**
     * Base metadata class, used to provide info from mapping configuration to Entity objects.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class ClassMetadata implements \doctrine\common\persistence\mapping\classmetadata {
        /** @var string */
        protected $name;
        /** @var string */
        protected $boltname;
        /** @var string */
        protected $tableName;
        /** @var array */
        protected $identifier;
        /** @var NamingStrategyInterface */
        protected $namingStrategy;
        /** @var array */
        protected $fieldMappings;

        public function __construct($className, NamingStrategyInterface $namingStrategy = null) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * Gets the fully-qualified class name of this persistent class.
         *
         * @return string
         */
        public function getTableName() {}
        public function setTableName($tableName) {}
        /**
         * Gets the bolt name of this class (normally table name without prefix).
         *
         * @return string
         */
        public function getBoltName() {}
        public function setBoltName($name) {}
        /**
         * Gets the internal alias using the naming strategy.
         *
         * @return string
         */
        public function getAliasName() {}
        public function getFieldMapping($fieldName) {}
        public function setFieldMappings($fieldMappings) {}
        /**
         * Gets the fieldMappings array.
         *
         *
         * @return array $fieldMappings
         */
        public function getFieldMappings() {}
        /**
         * Gets the mapped identifier field name.
         *
         * The returned structure is an array of the identifier field names.
         *
         * @return array
         */
        public function getIdentifier() {}
        public function setIdentifier($identifier) {}
        /**
         * Gets the ReflectionClass instance for this mapped class.
         *
         * @return \ReflectionClass
         */
        public function getReflectionClass() {}
        public function isIdentifier($fieldName) {}
        public function hasField($fieldName) {}
        /**
         * A numerically indexed list of field names of this persistent class.
         *
         * This array includes identifier fields if present on this class.
         *
         * @return array
         */
        public function getFieldNames() {}
        public function getTypeOfField($fieldName) {}
        /**
         * Returns an array of identifier field names numerically indexed.
         *
         * @return array
         */
        public function getIdentifierFieldNames() {}
        public function hasAssociation($fieldName) {}
        public function isSingleValuedAssociation($fieldName) {}
        public function isCollectionValuedAssociation($fieldName) {}
        public function getAssociationNames() {}
        public function getAssociationTargetClass($assocName) {}
        public function isAssociationInverseSide($assocName) {}
        public function getAssociationMappedByTargetField($assocName) {}
        public function getIdentifierValues($object) {}
    }

    /**
     * Legacy bridge for ContentType array access.
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ContentType implements \arrayaccess {
        /** @var string */
        protected $boltname;
        /** @var array */
        protected $contentType;

        public function __construct($boltname, array $contentType) {}
        public function __toString() {}
        public function offsetSet($offset, $value) {}
        public function offsetExists($offset) {}
        public function offsetUnset($offset) {}
        public function offsetGet($offset) {}
        public function getFields() {}
    }


    /**
     * Trait for mapping a ContentType 'title' to a column name.
     *
     * @deprecated Find something less fugly for v3.0
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait ContentTypeTitleTrait {
        protected function getTitleColumnName($contentType) {}
        protected function getTitleColumnNames($contentType) {}
    }

}

namespace Bolt\Storage\Mapping\Type {
}

namespace Bolt\Storage\Database {
    /**
     * Extension of DBAL's Connection class to allow catching of database connection
     * exceptions.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Connection extends \doctrine\dbal\connection {
        /** @var QueryCacheProfile */
        protected $_queryCacheProfile;

        /**
         * {@inheritdoc}
         */
        public function connect() {}
        public function fetchAll($sql, array $params = [ ], $types = [ ]) {}
        public function executeUpdate($query, array $params = [ ], array $types = [ ]) {}
        public function setQueryCacheProfile(QueryCacheProfile $profile) {}
    }

    /**
     * Extension of DBAL's Connection class to allow catching of database connection
     * exceptions.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class MasterSlaveConnection extends \doctrine\dbal\connections\masterslaveconnection {
        /** @var QueryCacheProfile */
        protected $_queryCacheProfile;

        public function connect($connectionName = null) {}
        public function setQueryCacheProfile(QueryCacheProfile $profile) {}
    }

}

namespace Bolt\Storage\Database\Prefill {
    /**
     * Handles fetching prefill images from an API service.
     */
    class ImageClient {
        /** @var Client */
        protected $client;

        public function __construct(Client $client) {}
        public function get($url) {}
    }

    /**
     * Builder of pre-filled records for set of ContentTypes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Builder {
        /** @var EntityManager */
        private $storage;
        /** @var callable */
        private $generatorFactory;
        /** @var int */
        private $maxCount;
        /** @var Bag */
        private $contentTypes;

        public function __construct(EntityManager $storage, callable $generatorFactory, $maxCount, Bag $contentTypes) {}
        public function build(array $contentTypeNames, $count, $canExceedMax = false) {}
        private function doBuild($contentTypeName, $createCount, MutableBag $response) {}
        /**
         * Return the maximum number of records allowed to exists before we stop
         * generating, or refuse to generate more records,
         *
         * @return int
         */
        public function getMaxCount() {}
        public function setMaxCount($maxCount) {}
        public function setGeneratorFactory(callable $generatorFactory) {}
        protected function createRecordContentGenerator($contentTypeName) {}
    }

    /**
     * Handles fetching prefill text content from an API service.
     */
    class ApiClient {
        /** @var Client */
        protected $client;

        public function __construct(Client $client) {}
        public function get($request, $base = 'http://loripsum.net/api/') {}
    }

    /**
     * Create a generated set of pre-filled records for a ContentType.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class RecordContentGenerator {
        /** @var ApiClient */
        private $apiClient;
        /** @var ImageClient */
        private $imageClient;
        /** @var string */
        private $contentTypeName;
        /** @var ContentRepository */
        private $repository;
        /** @var FilesystemInterface */
        private $filesystem;
        /** @var array */
        private $taxConfig;
        /** @var array */
        private $imageFiles;
        /** @var ImmutableBag */
        private $defaultTitles;
        /** @var array */
        private $createSummary;
        /** @var array */
        private $fieldMap;

        public function __construct($contentTypeName, ApiClient $apiClient, ImageClient $imageClient, ContentRepository $repository, FilesystemInterface $filesystem, array $taxConfig, ImmutableBag $defaultTitles) {}
/** @var Entity\Content $entity */
        public function generate(/** @var Entity\Content $entity */
$count) {}
        /**
         * Return the name of the ContentType that entities are generated for.
         *
         * @return string
         */
        public function getContentTypeName() {}
/** @var Entity\Taxonomy $taxonomy */
        private function fillEntity(/** @var Entity\Taxonomy $taxonomy */
Entity\Content $contentEntity) {}
        private function setFieldValue(Entity\Content $contentEntity, array $contentType, $fieldName, array $values) {}
        private function addBoolean(Entity\Content $contentEntity, $fieldName) {}
        private function addDate(Entity\Content $contentEntity, $fieldName, $type) {}
        private function addNumeric(Entity\Content $contentEntity, $fieldName, $type) {}
        private function addText(Entity\Content $contentEntity, $fieldName, $type, array $contentType) {}
        private function addJson(Entity\Content $contentEntity, $fieldName, $type) {}
/** @var Collection\Taxonomy $taxonomies */
        private function setTaxonomyCollection(/** @var Collection\Taxonomy $taxonomies */
Entity\Content $contentEntity, /** @var Collection\Taxonomy $taxonomies */
array $contentType) {}
        private function getTaxonomyEntity(Entity\Content $contentEntity, $taxonomy) {}
        /**
         * Return an array of enabled system IDs.
         *
         * @return array
         */
        private function getValidOwnerIds() {}
        /**
         * Return an array of file names in the "files" filesystem.
         *
         * @return \Bolt\Filesystem\Handler\Image[]
         */
        private function getImageFiles() {}
        private function getReservedTitle($contentTypeName) {}
        private function getRandomTags($count = 5) {}
        private function getRandomImage($type, $placeholder) {}
        private function fetchPlaceholder($placeholder) {}
    }

}

namespace Bolt\Storage\Database\Schema {
    /**
     * Schema validation check functionality.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Timer {
        const CHECK_INTERVAL = 1800;

        /** @var FileInterface */
        protected $cacheFile;
        /** @var bool */
        protected $expired;

        public function __construct(FileInterface $cacheFile) {}
        /**
         * Check if we have determined that we need to do a database check.
         *
         * @return bool
         */
        public function isCheckRequired() {}
        /**
         * Invalidate our database check by removing the timestamp file from cache.
         *
         * @throws \RuntimeException
         */
        public function setCheckRequired() {}
        /**
         * Set our state as valid by writing the current date/time to the
         * app/cache/dbcheck.ts file.
         *
         * We only want to do these checks once per hour, per session, since it's
         * pretty time consuming Unless specifically requested.
         */
        public function setCheckExpiry() {}
    }

    /**
     * Manager class for Bolt database schema.
     *
     * Based on on parts of the monolithic Bolt\Database\IntegrityChecker class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Manager implements \bolt\storage\database\schema\schemamanagerinterface {
        const INTEGRITY_CHECK_TS_FILENAME = 'dbcheck_ts';
        const INTEGRITY_CHECK_INTERVAL = 1800;

        /** @var \Doctrine\DBAL\Connection */
        protected $connection;
        /** @var \Bolt\Config */
        protected $config;
        /** @var \Doctrine\DBAL\Schema\Schema */
        protected $schema;
        /** @var \Doctrine\DBAL\Schema\Table[] */
        protected $schemaTables;
        /** @var \Doctrine\DBAL\Schema\Table[] */
        protected $installedTables;
        /** @var \Silex\Application */
        private $app;

        public function __construct(Application $app) {}
        public function __call($name, $args) {}
        public function __get($name) {}
/** @var BaseTable $table */
        public function getTableName(/** @var BaseTable $table */
$name) {}
        /**
         * {@inheritdoc}
         */
        public function isCheckRequired() {}
        /**
         * {@inheritdoc}
         */
        public function isUpdateRequired() {}
        /**
         * Run a check against current and configured schemas.
         *
         * @return SchemaCheck
         */
        public function check() {}
        /**
         * Run database table updates.
         *
         * @return \Bolt\Storage\Database\Schema\SchemaCheck
         */
        public function update() {}
        /**
         * Check if just the users table is present.
         *
         * @return bool
         */
        public function hasUserTable() {}
        /**
         * Get the built schema.
         *
         * @return \Doctrine\DBAL\Schema\Schema
         */
        public function getSchema() {}
        /**
         * Get a merged array of tables.
         *
         * @return \Doctrine\DBAL\Schema\Table[]
         */
        public function getSchemaTables() {}
        /** @var $tables \Doctrine\DBAL\Schema\Table[] */
        public function getInstalledTables() {}
        public function registerExtensionTable(callable $generator) {}
        /**
         * @return \Bolt\Storage\Database\Schema\Timer
         */
        private function getSchemaTimer() {}
        /**
         * @return \Bolt\Storage\Database\Schema\Comparison\BaseComparator
         */
        private function getSchemaComparator() {}
    }

    /**
     * A response class for a single table's check.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SchemaCheck {
        /** @var array */
        private $pending;
        /** @var array */
        private $titles;
        /** @var array */
        private $messages;
        /** @var array */
        private $hints;
        /** @var TableDiff[] */
        private $diffs;

        /**
         * Get a table diffs.
         *
         * @return TableDiff[]
         */
        public function getDiff() {}
        public function addHint($hint) {}
        /**
         * Get the hints.
         *
         * @return array
         */
        public function getHints() {}
        /**
         * Check is there are pending hints.
         *
         * @return bool
         */
        public function hasHints() {}
        public function addMessage($tableName, $message) {}
        /**
         * Get the messages.
         *
         * @return array
         */
        public function getMessages() {}
        /**
         * Get the response messages as a string.
         *
         * @return string[]
         */
        public function getResponseStrings() {}
        /**
         * Check is there are pending responses.
         *
         * @return bool
         */
        public function hasResponses() {}
        public function addTitle($tableName, $title) {}
        /**
         * Get the message titles.
         *
         * @return array
         */
        public function getTitles() {}
        public function checkDiff($tableName, TableDiff $diff) {}
/** @var $col \Doctrine\DBAL\Schema\Column */
        private function getAddedColumns(/** @var $col \Doctrine\DBAL\Schema\Column */
$tableName, /** @var $col \Doctrine\DBAL\Schema\Column */
TableDiff $diff) {}
/** @var $index \Doctrine\DBAL\Schema\Index */
        private function getAddedIndexes(/** @var $index \Doctrine\DBAL\Schema\Index */
$tableName, /** @var $index \Doctrine\DBAL\Schema\Index */
TableDiff $diff) {}
/** @var $col \Doctrine\DBAL\Schema\ColumnDiff */
        private function getChangedColumns(/** @var $col \Doctrine\DBAL\Schema\ColumnDiff */
$tableName, /** @var $col \Doctrine\DBAL\Schema\ColumnDiff */
TableDiff $diff) {}
/** @var $index \Doctrine\DBAL\Schema\Index */
        private function getChangedIndexes(/** @var $index \Doctrine\DBAL\Schema\Index */
$tableName, /** @var $index \Doctrine\DBAL\Schema\Index */
TableDiff $diff) {}
        private function getRemovedColumns($tableName, TableDiff $diff) {}
        private function getRemovedIndexes($tableName, TableDiff $diff) {}
        private function getRenamedColumns($tableName, TableDiff $diff) {}
        private function getAddedForeignKeys($tableName, TableDiff $diff) {}
        private function getChangedForeignKeys($tableName, TableDiff $diff) {}
        private function addForeignKeysMessage($tableName, ForeignKeyConstraint $foreignKey, $format) {}
        private function getRemovedForeignKeys($tableName, TableDiff $diff) {}
    }

    class LazySchemaManager implements \bolt\storage\database\schema\schemamanagerinterface {
        /** @var callable */
        private $factory;
        /** @var Manager */
        private $manager;

        public function __construct(callable $factory) {}
        /**
         * @return Manager
         */
        public function getManager() {}
        /**
         * {@inheritdoc}
         */
        public function isCheckRequired() {}
        /**
         * {@inheritdoc}
         */
        public function isUpdateRequired() {}
    }

    /**
     * Table modification handler class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class TableModifier {
        /** @var \Doctrine\DBAL\Connection */
        protected $connection;
        /** @var \Psr\Log\LoggerInterface */
        protected $loggerSystem;
        /** @var \Bolt\Logger\FlashLoggerInterface */
        protected $loggerFlash;

        public function __construct(Connection $connection, LoggerInterface $loggerSystem, FlashLoggerInterface $loggerFlash) {}
        public function createTables(array $tableCreates, SchemaCheck $response) {}
        public function alterTables(array $tableAlters, SchemaCheck $response) {}
        protected function createTable($tableName, array $tableCreate, SchemaCheck $response) {}
        protected function alterTable($tableName, array $tableAlter, SchemaCheck $response) {}
        protected function runQuery($tableName, $query) {}
    }


    /**
     * Interface for schema manager.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface SchemaManagerInterface {
        /**
         * Check to see if we have past the time to re-check our schema.
         *
         * @return bool
         */
        function isCheckRequired() ;
        /**
         * Check to see if there is a mismatch in installed versus configured
         * schemas.
         *
         * @return bool
         */
        function isUpdateRequired() ;
    }

}

namespace Bolt\Storage\Database\Schema\Types {
    /**
     * Type generating JSON object values.
     *
     * DBAL 2.6 deprecated JsonArrayType in favour of JsonType, and bumped the
     * minimum PHP version to 7.1. As we need to maintain support for PHP 5.5+
     * this has caused problems with schema change detection.
     *
     * @see https://github.com/bolt/bolt/issues/6856
     *
     * @internal Provided to bridge DBAL 2.5 & 2.6 support.
     *
     * @author Baptiste Clavi <clavie.b@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class JsonType extends \doctrine\dbal\types\type {
        public function getSQLDeclaration(array $fieldDeclaration, AbstractPlatform $platform) {}
        public function convertToDatabaseValue($value, AbstractPlatform $platform) {}
        public function convertToPHPValue($value, AbstractPlatform $platform) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        public function requiresSQLCommentHint(AbstractPlatform $platform) {}
    }

    /**
     * @internal Provided to bridge DBAL 2.5 & 2.6 support.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class ConversionException extends \doctrine\dbal\types\conversionexception {
        public static function conversionFailedSerialization($value, $format, $error, Exception $e = null) {}
    }

    /**
     * Type generating JSON object values.
     *
     * DBAL 2.6 deprecated JsonArrayType in favour of JsonType, and bumped the
     * minimum PHP version to 7.1. As we need to maintain support for PHP 5.5+
     * this has caused problems with schema change detection.
     *
     * @see https://github.com/bolt/bolt/issues/6856
     *
     * @internal Provided to bridge DBAL 2.5 & 2.6 support.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class JsonArrayType extends \doctrine\dbal\types\jsonarraytype {
        public function requiresSQLCommentHint(AbstractPlatform $platform) {}
    }

    /**
     * Doctrine DateTimeType using Carbon.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class CarbonDateTimeType extends \doctrine\dbal\types\datetimetype {
        public function convertToPHPValue($value, AbstractPlatform $platform) {}
    }

    /**
     * Doctrine DateType using Carbon.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class CarbonDateType extends \doctrine\dbal\types\datetype {
        public function convertToPHPValue($value, AbstractPlatform $platform) {}
    }

}

namespace Bolt\Storage\Database\Schema\Table {
    /**
     * Table for taxonomy data.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Taxonomy extends \bolt\storage\database\schema\table\basetable {
        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

    /**
     * Table for content relationship data.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Relations extends \bolt\storage\database\schema\table\basetable {
        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

    /**
     * Table for field values with separate columns for each data type.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class FieldValue extends \bolt\storage\database\schema\table\basetable {
        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

    /**
     * Base database table class for Bolt.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class BaseTable {
        /** @var \Doctrine\DBAL\Platforms\AbstractPlatform $platform */
        protected $platform;
        /** @var \Doctrine\DBAL\Schema\Table */
        protected $table;
        /** @var string */
        protected $tablePrefix;
        /** @var string */
        protected $tableName;
        /** @var string */
        protected $aliasName;

        public function __construct(AbstractPlatform $platform, $tablePrefix) {}
        /**
         * Get the table object.
         *
         * @throws StorageException
         *
         * @return \Doctrine\DBAL\Schema\Table
         */
        public function getTable() {}
        public function buildTable(Schema $schema, $aliasName, $charset, $collate) {}
        /**
         * Get the table's name.
         *
         * @throws \RuntimeException
         *
         * @return string
         */
        public function getTableName() {}
        /**
         * Get the table's alias (short) name.
         *
         * @throws \RuntimeException
         *
         * @return string
         */
        public function getTableAlias() {}
        /**
         * Default value for TEXT fields, differs per platform.
         *
         * @return string|null
         */
        protected function getTextDefault() {}
        /**
         * Add columns to the table.
         */
        abstract protected function addColumns() ;
        /**
         * Define the columns that require indexing.
         */
        abstract protected function addIndexes() ;
        /**
         * Set the table's primary key.
         */
        abstract protected function setPrimaryKey() ;
        /**
         * Set the table's foreign key constraints.
         */
        protected function addForeignKeyConstraints() {}
    }

    /**
     * Table for user account data.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Users extends \bolt\storage\database\schema\table\basetable {
        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

    /**
     * Table for cron schedule data.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Cron extends \bolt\storage\database\schema\table\basetable {
        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

    class ContentType extends \bolt\storage\database\schema\table\basetable {
        /** @var array Mapping of field type to column type function */
        protected $typeMap;
        /** @var array */
        protected $ignoredChanges;

        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
        public function isKnownType($type) {}
        public function addCustomFields($fieldName, $type, $addIndex) {}
        private function columnBoolean($fieldName) {}
        private function columnDate($fieldName) {}
        private function columnDateTime($fieldName) {}
        private function columnDecimal($fieldName) {}
        private function columnFloat($fieldName) {}
        private function columnInteger($fieldName) {}
        private function columnJson($fieldName) {}
        private function columnStringNormal($fieldName) {}
        private function columnStringNotNull($fieldName) {}
        private function columnText($fieldName) {}
    }

    /**
     * Table for authentication token data.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class AuthToken extends \bolt\storage\database\schema\table\basetable {
        /** @deprecated Deprecated since 3.4, to be removed in v4.0.  */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

    /**
     * Table for change log data.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class LogChange extends \bolt\storage\database\schema\table\basetable {
        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

    /**
     * Table for system logging data.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class LogSystem extends \bolt\storage\database\schema\table\basetable {
        /**
         * {@inheritdoc}
         */
        protected function addColumns() {}
        /**
         * {@inheritdoc}
         */
        protected function addIndexes() {}
        /**
         * {@inheritdoc}
         */
        protected function setPrimaryKey() {}
    }

}

namespace Bolt\Storage\Database\Schema\Comparison {
    /**
     * Base class for handling table comparison.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class BaseComparator {
        /** @var \Doctrine\DBAL\Connection */
        protected $connection;
        /** @var string */
        protected $prefix;
        /** @var \Psr\Log\LoggerInterface */
        protected $systemLog;
        /** @var \Doctrine\DBAL\Schema\TableDiff[] */
        protected $diffs;
        /** @var \Doctrine\DBAL\Schema\Table[] */
        protected $tablesCreate;
        /** @var \Doctrine\DBAL\Schema\TableDiff[] */
        protected $tablesAlter;
        /** @var IgnoredChange[] */
        protected $ignoredChanges;
        /** @var bool */
        protected $pending;
        /** @var \Bolt\Storage\Database\Schema\SchemaCheck */
        protected $response;

        public function __construct(Connection $connection, $prefix, LoggerInterface $systemLog) {}
        public function hasPending($fromTables, $toTables, array $protectedTableNames) {}
        public function compare($fromTables, $toTables, array $protectedTableNames, $force = false) {}
        /**
         * Get the schema check response object.
         *
         * @return \Bolt\Storage\Database\Schema\SchemaCheck
         */
        public function getResponse() {}
        /**
         * Get the table creation SQL queries.
         *
         * @return string[]
         */
        public function getCreates() {}
        /** @var $tableDiff TableDiff */
        public function getAlters() {}
        /**
         * Get the unmodified table diffs.
         *
         * @return TableDiff[]
         */
        public function getDiffs() {}
        public function addIgnoredChange(IgnoredChange $ignoredChange) {}
        /**
         * Create a list of changes this platform will ignore.
         */
        abstract protected function setIgnoredChanges() ;
        abstract protected function removeIgnoredChanges(TableDiff $diff) ;
/** @var $fromTable Table */
        protected function checkTables(/** @var $fromTable Table */
$fromTables, /** @var $fromTable Table */
$toTables) {}
        protected function checkTable(Table $fromTable, Table $toTable) {}
/** @var TableDiff $tableDiff */
        protected function adjustDiffs(/** @var TableDiff $tableDiff */
array $protectedTableNames) {}
        protected function adjustContentTypeDiffs(TableDiff $tableDiff, array $protectedTableNames) {}
        /**
         * Add required changes to the response object.
         *
         * NOTE: This must be run after adjustDiffs() so that the user response
         * doesn't contain ignored changes.
         */
        protected function addAlterResponses() {}
    }

    /**
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class IgnoredChange {
        /** @var string */
        protected $alteration;
        /** @var string */
        protected $propertyName;
        /** @var string */
        protected $before;
        /** @var string */
        protected $after;

        public function __construct($alteration, $propertyName, $before, $after) {}
        public function matches($alteration, $propertyName, $before, $after) {}
        public function getAlteration() {}
        public function getPropertyName() {}
        public function getBefore() {}
        public function getAfter() {}
    }

    /**
     * Processor for \Doctrine\DBAL\Schema\TableDiff objects.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DiffUpdater {
        /** @var \Bolt\Storage\Database\Schema\Comparison\IgnoredChange[] */
        protected $ignoredChanges;
        /** @var array */
        protected $paramMap;

        public function __construct(array $ignoredChanges) {}
/** @var IgnoredChange $ignoredChange */
        public function adjustDiff(/** @var IgnoredChange $ignoredChange */
TableDiff $tableDiff) {}
        protected function checkChangedProperties(TableDiff $tableDiff, array $schemaUpdateType, $alterName, IgnoredChange $ignoredChange) {}
        protected function checkColumn(Column $column, IgnoredChange $ignoredChange) {}
        protected function checkColumnDiff(ColumnDiff $columnDiff, IgnoredChange $ignoredChange) {}
        protected function checkIndex(Index $index, IgnoredChange $ignoredChange) {}
        protected function checkForeignKeyConstraint(ForeignKeyConstraint $foreignKeyConstraint, IgnoredChange $ignoredChange) {}
        private function updateDiffTable(TableDiff $diff) {}
    }

    /**
     * Comparison handling for PostgreSQL platforms.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class PostgreSql extends \bolt\storage\database\schema\comparison\basecomparator {
        /** @var string */
        protected $platform;

        /**
         * {@inheritdoc}
         */
        protected function setIgnoredChanges() {}
        protected function removeIgnoredChanges(TableDiff $diff) {}
    }

    /**
     * Comparison handling for MySQL/MariaDB platforms.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class MySql extends \bolt\storage\database\schema\comparison\basecomparator {
        /** @var string */
        protected $platform;

        /**
         * {@inheritdoc}
         */
        protected function setIgnoredChanges() {}
        protected function removeIgnoredChanges(TableDiff $diff) {}
    }

    /**
     * Comparator class.
     *
     * @internal
     *
     * @deprecated Drop when minimum PHP version is 7.1 or greater.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class Comparator extends \doctrine\dbal\schema\comparator {
        public function diffColumn(Column $column1, Column $column2) {}
    }

    /**
     * Comparison handling for Sqlite platforms.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Sqlite extends \bolt\storage\database\schema\comparison\basecomparator {
        /** @var string */
        protected $platform;

        /**
         * {@inheritdoc}
         */
        protected function setIgnoredChanges() {}
/**
 * @see https://github.com/doctrine/dbal/pull/242
 *      \Doctrine\DBAL\Platforms\SqlitePlatform::supportsForeignKeyConstraints
 *      https://www.sqlite.org/foreignkeys.html
 */
        protected function removeIgnoredChanges(/**
 * @see https://github.com/doctrine/dbal/pull/242
 *      \Doctrine\DBAL\Platforms\SqlitePlatform::supportsForeignKeyConstraints
 *      https://www.sqlite.org/foreignkeys.html
 */
TableDiff $diff) {}
    }

}

namespace Bolt\Storage\Database\Schema\Builder {
    /**
     * Builder for Bolt extension tables.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExtensionTables extends \bolt\storage\database\schema\builder\basebuilder {
        /** @var callable[] */
        protected $tableGenerators;
        /** @var string @deprecated Deprecated since 3.0, to be removed in 4.0. */
        private $prefix;

/** @var Table $table */
        public function getSchemaTables(/** @var Table $table */
Schema $schema) {}
        public function addTable(callable $generator) {}
        public function addPrefix($prefix) {}
    }

    /**
     * Builder for Bolt core tables.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class BaseTables extends \bolt\storage\database\schema\builder\basebuilder {
/** @var BaseTable $table */
        public function getSchemaTables(/** @var BaseTable $table */
Schema $schema) {}
    }

    /**
     * Builder for Bolt content tables.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ContentTables extends \bolt\storage\database\schema\builder\basebuilder {
        /** @var array */
        protected $tableSchemas;

/** @var ContentType $table */
        public function getSchemaTables(/** @var ContentType $table */
Schema $schema, /** @var ContentType $table */
Config $config) {}
        private function getNormalisedContentTypes(Config $config) {}
/** @var \Doctrine\DBAL\Platforms\Keywords\KeywordList $reservedList */
        private function addContentTypeTableColumns(/** @var \Doctrine\DBAL\Platforms\Keywords\KeywordList $reservedList */
ContentType $tableObj, /** @var \Doctrine\DBAL\Platforms\Keywords\KeywordList $reservedList */
Table $table, /** @var \Doctrine\DBAL\Platforms\Keywords\KeywordList $reservedList */
array $fields, /** @var \Doctrine\DBAL\Platforms\Keywords\KeywordList $reservedList */
FieldManager $fieldManager) {}
/** @var $handler \Bolt\Storage\Field\FieldInterface */
        private function addContentTypeTableColumn(/** @var $handler \Bolt\Storage\Field\FieldInterface */
ContentType $tableObj, /** @var $handler \Bolt\Storage\Field\FieldInterface */
Table $table, /** @var $handler \Bolt\Storage\Field\FieldInterface */
$fieldName, /** @var $handler \Bolt\Storage\Field\FieldInterface */
array $values, /** @var $handler \Bolt\Storage\Field\FieldInterface */
FieldManager $fieldManager) {}
        private function getContentTypeTableColumnType(array $values) {}
    }

    /**
     * Base class for Bolt's table builders.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class BaseBuilder {
        /** @var \Doctrine\DBAL\Connection */
        protected $connection;
        /** @var \Bolt\Storage\Database\Schema\Manager */
        protected $manager;
        /** @var \Pimple */
        protected $tables;
        /** @var string */
        protected $charset;
        /** @var string */
        protected $collate;
        /** @var \Psr\Log\LoggerInterface */
        protected $systemLog;
        /** @var \Bolt\Logger\FlashLoggerInterface */
        protected $flashLogger;

        public function __construct(Connection $connection, Manager $manager, Pimple $tables, $charset, $collate, LoggerInterface $systemLog, FlashLoggerInterface $flashLogger) {}
    }

}

namespace Bolt\Storage\Repository {
    /**
     * A Repository class that handles storage operations for the system log table.
     */
    class LogSystemRepository extends \bolt\storage\repository\baselogrepository {}

    /**
     * A Repository class that handles storage operations for the Cron table.
     */
    class CronRepository extends \bolt\storage\repository {
        public function getNextRunTime($interimName) {}
/** @deprecated Deprecated since 3.0, to be removed in 4.0. */
        public function queryNextRunTime(/** @deprecated Deprecated since 3.0, to be removed in 4.0. */
$interimName) {}
    }

    /**
     * A Repository class that handles dynamically created content tables.
     */
    class ContentRepository extends \bolt\storage\repository {
    use \bolt\storage\mapping\contenttypetitletrait;

        /** @var ContentLegacyService */
        protected $legacy;

        public function getSelectList(array $contentType, $order, $neededFields = [ ]) {}
        public function querySelectList(array $contentType, $order = null, $neededFields = [ ]) {}
        public function setLegacyService(ContentLegacyService $service) {}
        public function createQueryBuilder($alias = 'content') {}
        public function hydrateLegacyHandler(HydrationEvent $event) {}
    }

    /**
     * A Repository class that handles storage operations for the change log table.
     */
    class LogChangeRepository extends \bolt\storage\repository\baselogrepository {
        public function getChangeLog(array $options) {}
        public function getChangeLogQuery(array $options) {}
        /**
         * Get a count of change log entries.
         *
         * @deprecated since 3.3, will be removed in 4.0
         *
         * @return int
         */
        public function countChangeLog() {}
        /**
         * Build the query to get a count of change log entries.
         *
         * @deprecated since 3.3, will be removed in 4.0
         *
         * @return QueryBuilder
         */
        public function countChangeLogQuery() {}
        public function getChangeLogByContentType($contentType, array $options = [ ]) {}
        public function getChangeLogByContentTypeQuery($contentType, array $options) {}
        public function countChangeLogByContentType($contentType, array $options) {}
        public function countChangeLogByContentTypeQuery($contentType, array $options) {}
/** @var Entity\LogChange $logChange */
        public function getChangeLogEntry(/** @var Entity\LogChange $logChange */
$contentType, /** @var Entity\LogChange $logChange */
$contentId, /** @var Entity\LogChange $logChange */
$id, /** @var Entity\LogChange $logChange */
$cmpOp) {}
        public function getChangeLogEntryQuery($contentType, $contentId, $id, $cmpOp) {}
        protected function setLimitOrder(QueryBuilder $query, array $options) {}
        protected function setWhere(QueryBuilder $query, $contentType, array $options) {}
    }

    class FieldValueRepository extends \bolt\storage\repository {
        public function queryExistingFields($id, $contentType, $field) {}
        public function getExistingFields($id, $contentType, $field) {}
    }

    /**
     * A Repository class that handles storage operations for the Authtoken table.
     */
    class AuthtokenRepository extends \bolt\storage\repository {
        public function getUserToken($userId, $ip, $userAgent = null) {}
        public function getUserTokenQuery($userId, $ip, $userAgent) {}
        public function getToken($token, $ip = null, $userAgent = null) {}
        public function getTokenQuery($token, $ip, $userAgent) {}
        public function deleteTokens($userId) {}
        public function deleteTokensQuery($userId) {}
        /**
         * Deletes all expired tokens.
         *
         * @return int
         */
        public function deleteExpiredTokens() {}
        public function deleteExpiredTokensQuery() {}
        /**
         * Fetches all active sessions.
         *
         * @return \Bolt\Storage\Entity\Authtoken[]
         */
        public function getActiveSessions() {}
        public function getActiveSessionsQuery() {}
    }

    /**
     * A Repository class that handles storage operations for the log tables.
     */
    abstract class BaseLogRepository extends \bolt\storage\repository {
        public function trimLog($period) {}
        public function queryTrimLog($period) {}
        /**
         * Clear the log table.
         *
         * @return bool
         */
        public function clearLog() {}
        public function getActivity($page = 1, $amount = 10, array $options = [ ]) {}
        public function getActivityQuery($page, $amount, array $options) {}
        public function getActivityCount(array $options = [ ]) {}
        public function getActivityCountQuery(array $options) {}
        protected function addWhereActivity(QueryBuilder $qb, $options) {}
        protected function buildWhereOr(QueryBuilder $qb, $parentColumnName, array $options) {}
        protected function getCount($result) {}
    }

    /**
     * A Repository class that handles storage operations for the users table.
     */
    class UsersRepository extends \bolt\storage\repository {
        private $userEntities;

        public function deleteUser($userId) {}
        public function deleteUserQuery($userId) {}
/** @var Entity\Users $userEntity */
        public function getUser(/** @var Entity\Users $userEntity */
$userId) {}
        public function getUserQuery($userId) {}
        public function getUserAuthData($userId) {}
        public function getUserAuthDataQuery($userId) {}
        /**
         * Get all the system users.
         *
         * @return Entity\Users[]|false
         */
        public function getUsers() {}
        /**
         * Check to see if there are users in the user table.
         *
         * @deprecated Deprecated since 3.3. To be removed in v4.0.
         *
         * @return int
         */
        public function hasUsers() {}
        /**
         * @deprecated Deprecated since 3.3. To be removed in v4.0.
         *
         * @return QueryBuilder
         */
        public function hasUsersQuery() {}
        public function getUserShadowAuth($shadowToken) {}
        public function getUserShadowAuthQuery($shadowToken) {}
        public function save($entity, $silent = null) {}
        public function update($entity, $exclusions = [ ]) {}
        protected function unsetSensitiveFields(Entity\Users $entity) {}
    }

}

namespace Bolt\Storage\Collection {
    /**
     * This class stores an array collection of Taxonomy Entities.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class Taxonomy extends \doctrine\common\collections\arraycollection {
        public $config;

        public function __construct(array $elements = [ ], MetadataDriver $metadata = null) {}
        public function setFromPost(array $formValues, Entity\Content $entity) {}
        public function setFromDatabaseValues($result) {}
        public function update(Taxonomy $collection) {}
        /**
         * Get the taxonomy types that are in the collection, grouped by taxonomy key.
         *
         * @internal
         *
         * @return array
         */
        public function getGrouped() {}
        /** @var Entity\Taxonomy $el */
        public function getNew() {}
        /**
         * Gets the elements that have already been persisted.
         *
         * @return Taxonomy
         */
        public function getExisting() {}
/** @var Entity\Taxonomy $existing */
        public function getOriginal(/** @var Entity\Taxonomy $existing */
$entity) {}
/** @var Entity\Taxonomy $el */
        public function getField(/** @var Entity\Taxonomy $el */
$fieldName) {}
        public function filter(Closure $p) {}
        public function offsetGet($offset) {}
        public function containsKeyValue($field, $value) {}
        public function getSortorder($field, $slug) {}
        public function serialize() {}
        /**
         * @return null|string
         */
        public function getGroupingTaxonomy() {}
        /**
         * @return array
         */
        public function getGroupingTaxonomies() {}
    }

    /**
     * This class stores an array collection of Relations Entities.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class Relations extends \doctrine\common\collections\arraycollection {
        protected $em;

        public function __construct(array $elements = [ ], EntityManager $em = null) {}
        public function setEntityManager(EntityManager $em) {}
        public function setFromPost(array $formValues, Entity\Content $entity) {}
        public function setFromDatabaseValues(array $result) {}
        public function update(Relations $collection) {}
        /**
         * Get the related types that are in the collection, grouped by ContentType key.
         *
         * @internal
         *
         * @return array
         */
        public function getGrouped() {}
        public function getOriginal(Entity\Relations $entity) {}
/** @var Entity\Relations $el */
        public function getField(/** @var Entity\Relations $el */
$fieldName, /** @var Entity\Relations $el */
$biDirectional = false, /** @var Entity\Relations $el */
$contentTypeName = null, /** @var Entity\Relations $el */
$contentTypeId = null) {}
/** @var Entity\Relations $el */
        public function incoming(/** @var Entity\Relations $el */
Entity\Content $entity) {}
        public function offsetGet($offset) {}
        public function serialize() {}
    }

    /**
     * Collection Manager class.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class CollectionManager {
        /** @var callable[] */
        public $collections;
        /** @var EntityManager */
        public $em;

        public function setHandler($entity, $handler) {}
        public function setEntityManager(EntityManager $em = null) {}
        public function create($class) {}
    }

    /**
     * LazyCollection Class - Allows a set of references to Entities to be loaded on demand.
     *
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class LazyCollection extends \doctrine\common\collections\arraycollection {
        public function add($element) {}
        /**
         *  Force loads the proxy objects and returns the real objects
         */
        public function serialize() {}
    }

}

namespace Bolt\Storage\Entity {
    /**
     * Entity for taxonomy.
     */
    class Taxonomy extends \bolt\storage\entity\entity {
        /** @var array */
        protected $_config;
        /** @var int */
        protected $id;
        /** @var int */
        protected $content_id;
        /** @var string */
        protected $contenttype;
        /** @var string */
        protected $taxonomytype;
        /** @var string */
        protected $slug;
        /** @var string */
        protected $name;
        /** @var int */
        protected $sortorder;

        public function setConfig(array $config) {}
        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        /**
         * @return int
         */
        public function getContentId() {}
        public function setContentId($content_id) {}
        /**
         * @return string
         */
        public function getContenttype() {}
        public function setContenttype($contenttype) {}
        /**
         * @return string
         */
        public function getTaxonomytype() {}
        public function setTaxonomytype($taxonomytype) {}
        /**
         * @return string
         */
        public function getSlug() {}
        public function setSlug($slug) {}
        /**
         * @return string
         */
        public function getName() {}
        public function setName($name) {}
        /**
         * @return int
         */
        public function getSortorder() {}
        public function setSortorder($sortorder) {}
    }

    /**
     * Entity for relations.
     */
    class Relations extends \bolt\storage\entity\entity {
        /** @var int */
        protected $id;
        /** @var string */
        protected $from_contenttype;
        /** @var int */
        protected $from_id;
        /** @var string */
        protected $to_contenttype;
        /** @var int */
        protected $to_id;
        private $invert;

        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        /**
         * @return string
         */
        public function getFromContenttype() {}
        public function setFromContenttype($from_contenttype) {}
        /**
         * @return int
         */
        public function getFromId() {}
        public function setFromId($from_id) {}
        /**
         * @return string
         */
        public function getToContenttype() {}
        /**
         * @return int
         */
        public function getToId() {}
        public function setToId($to_id) {}
        public function setToContenttype($to_contenttype) {}
        /**
         * @return bool
         */
        public function isInvert() {}
        public function setInvert($invert) {}
        public function actAsInverse() {}
        public function isInverted() {}
    }

    /**
     * Entity for TemplateFields.
     */
    class FieldValue extends \bolt\storage\entity\entity {
        /** @var int */
        protected $id;
        /** @var string */
        protected $contenttype;
        /** @var int */
        protected $content_id;
        /** @var string */
        protected $name;
        /** @var int */
        protected $grouping;
        /** @var string */
        protected $fieldname;
        /** @var string */
        protected $fieldtype;
        /** @var string */
        protected $block;
        /** @var mixed */
        protected $value;
        /** @var string @internal Use $value instead */
        protected $value_string;
        /** @var string @internal Use $value instead */
        protected $value_text;
        /** @var int @internal Use $value instead */
        protected $value_integer;
        /** @var float @internal Use $value instead */
        protected $value_float;
        /** @var int @internal Use $value instead */
        protected $value_decimal;
        /** @var \DateTime @internal Use $value instead */
        protected $value_date;
        /** @var \DateTime @internal Use $value instead */
        protected $value_datetime;
        /** @var array @internal Use $value instead */
        protected $value_json_array;

        /**
         * @return mixed
         */
        public function getValue() {}
        public function setValue($value) {}
        /**
         * {@inheritdoc}
         */
        public function __toString() {}
        /**
         * @return string
         */
        public function getName() {}
        public function setName($name) {}
        /**
         * @return string
         */
        public function getContentType() {}
        /**
         * @return int
         */
        public function getContentId() {}
        /**
         * @return int
         */
        public function getGrouping() {}
        /**
         * @return string
         */
        public function getFieldName() {}
        /**
         * @return string
         */
        public function getFieldType() {}
/** @deprecated since 3.3 to be renamed in v4. */
        public function handleStorage(/** @deprecated since 3.3 to be renamed in v4. */
$fieldObject) {}
    }

    /**
     * Entity for TemplateFields.
     */
    class TemplateFields extends \bolt\storage\entity\entity {
        public function get($key) {}
        public function serialize() {}
    }

    /**
     * Builder class to create entity objects and populate with data.
     */
    class Builder {
        /**
         * The class to use for new instances.
         *
         * @var string
         */
        protected $class;
        protected $classMetadata;
        protected $metadata;
        protected $fieldManager;
        protected $transformers;

        public function __construct(MetadataDriver $metadata, FieldManager $fieldManager) {}
        public function setClass($class) {}
        public function setClassMetadata(ClassMetadata $classMetadata) {}
        /**
         * Gets the metadata instance.
         *
         * @return ClassMetadata $classMetadata
         */
        public function getClassMetadata() {}
        public function setTransformer($fieldTypeClass, callable $handler) {}
        public function getEntity($entity = null) {}
        /**
         * Uses either the class default or the supplied ClassMetadata to return
         * a list of fields for this entity.
         *
         * @return array
         */
        public function getFields() {}
        public function create($data, $entity = null) {}
        public function createFromDatabaseValues($data, $entity = null) {}
        public function refresh($entity) {}
        public function getHydratedValue($value, $field, $subField = null, $block = null) {}
    }

    /**
     * Entity for Content.
     */
    class Content extends \bolt\storage\entity\entity {
    use \bolt\storage\entity\contentroutetrait, \bolt\storage\entity\contenttypetrait, \bolt\storage\mapping\contenttypetitletrait;

        /** @var string|Mapping\ContentType */
        protected $contenttype;
        /** @var ContentLegacyService */
        protected $_legacy;
        /** @var int */
        protected $id;
        /** @var string */
        protected $slug;
        /** @var \DateTime */
        protected $datecreated;
        /** @var \DateTime */
        protected $datechanged;
        /** @var \DateTime */
        protected $datepublish;
        /** @var \DateTime */
        protected $datedepublish;
        /** @var int */
        protected $ownerid;
        /** @var string */
        protected $status;
        /** @var Collection\Relations */
        protected $relation;
        /** @var Collection\Taxonomy */
        protected $taxonomy;
        /** @var TemplateFields */
        protected $templatefields;
        /** @var array @deprecated Deprecated since 3.0, to be removed in 4.0. */
        protected $group;
        /** @var int */
        protected $sortorder;

        public function set($key, $value) {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         *
         * @return int
         */
        public function getSortorder() {}
        public function setSortorder($sortorder) {}
        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        /**
         * @return string
         */
        public function getSlug() {}
        public function setSlug($slug) {}
        /**
         * Get creation date.
         *
         * @return \DateTime
         */
        public function getDatecreated() {}
        public function setDatecreated($date) {}
        /**
         * Get change date.
         *
         * @return \DateTime
         */
        public function getDatechanged() {}
        public function setDatechanged($date) {}
        /**
         * @return \DateTime
         */
        public function getDatepublish() {}
        public function setDatepublish($date) {}
        /**
         * @return \DateTime
         */
        public function getDatedepublish() {}
        public function setDatedepublish($date) {}
        /**
         * @return int
         */
        public function getOwnerid() {}
        public function setOwnerid($ownerid) {}
        /**
         * @return string
         */
        public function getStatus() {}
        public function setStatus($status) {}
        public function getRelation($contentType = null) {}
        public function setRelation(Collection\Relations $rel) {}
        /**
         * @return Collection\Taxonomy
         */
        public function getTaxonomy() {}
        public function setTaxonomy(Collection\Taxonomy $taxonomy) {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0.
         *
         * @return array
         */
        public function getGroup() {}
        public function setGroup($group) {}
        public function setValues(array $values) {}
        /**
         * Helper to return an array of user-defined values from the Entity.
         * This excludes meta fields set by Bolt.
         */
        public function getValues() {}
        /**
         * Getter for a record's 'title' field.
         *
         * If there is no field called 'title' then we just return the first text
         * type field.
         *
         * @return string
         */
        public function getTitle() {}
        /**
         * @return string|Mapping\ContentType
         */
        public function getContenttype() {}
        public function setContenttype($value) {}
        /**
         * @return TemplateFields|array|null
         */
        public function getTemplatefields() {}
        public function setTemplatefields($value) {}
        /**
         * @return ContentLegacyService
         */
        public function getLegacy() {}
        public function setLegacyService(ContentLegacyService $service) {}
        protected function getValidDateObject($date) {}
    }

    /**
     * Entity for User.
     */
    class Users extends \bolt\storage\entity\entity {
        /** @var int */
        protected $id;
        /** @var string */
        protected $username;
        /** @var string */
        protected $password;
        /** @var string */
        protected $email;
        /** @var \DateTime */
        protected $lastseen;
        /** @var string */
        protected $lastip;
        /** @var string */
        protected $displayname;
        /** @var array */
        protected $stack;
        /** @var bool */
        protected $enabled;
        /** @var string */
        protected $shadowpassword;
        /** @var string */
        protected $shadowtoken;
        /** @var string */
        protected $shadowvalidity;
        /** @var int */
        protected $failedlogins;
        /** @var \DateTime */
        protected $throttleduntil;
        /** @var array */
        protected $roles;

        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        /**
         * @return string
         */
        public function getUsername() {}
        public function setUsername($username) {}
        /**
         * @return string
         */
        public function getPassword() {}
        public function setPassword($password) {}
        /**
         * @return string
         */
        public function getEmail() {}
        public function setEmail($email) {}
        /**
         * @return \DateTime
         */
        public function getLastseen() {}
        public function setLastseen($lastseen) {}
        /**
         * @return string
         */
        public function getLastip() {}
        public function setLastip($lastip) {}
        /**
         * @return string
         */
        public function getDisplayname() {}
        public function setDisplayname($displayname) {}
        /**
         * @return array
         */
        public function getStack() {}
        public function setStack($stack) {}
        /**
         * @return bool
         */
        public function isEnabled() {}
        /**
         * Getter for enabled flag.
         *
         * @return bool
         */
        public function getEnabled() {}
        public function setEnabled($enabled) {}
        /**
         * @return string
         */
        public function getShadowpassword() {}
        public function setShadowpassword($shadowpassword) {}
        /**
         * @return string
         */
        public function getShadowtoken() {}
        public function setShadowtoken($shadowtoken) {}
        /**
         * @return string
         */
        public function getShadowvalidity() {}
        public function setShadowvalidity($shadowvalidity) {}
        /**
         * @return int
         */
        public function getFailedlogins() {}
        public function setFailedlogins($failedlogins) {}
        /**
         * @return \DateTime
         */
        public function getThrottleduntil() {}
        public function setThrottleduntil($throttleduntil) {}
        /**
         * @return array
         */
        public function getRoles() {}
        public function setRoles(array $roles) {}
    }

    /**
     * Entity for cron jobs.
     */
    class Cron extends \bolt\storage\entity\entity {
        /** @var int */
        protected $id;
        /** @var string */
        protected $interim;
        /** @var \DateTime */
        protected $lastrun;

        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        /**
         * @return string
         */
        public function getInterim() {}
        public function setInterim($interim) {}
        /**
         * @return \DateTime
         */
        public function getLastrun() {}
        public function setLastrun($lastrun) {}
    }

    /**
     * Entity for Auth Tokens.
     */
    class Authtoken extends \bolt\storage\entity\entity {
        /** @var int */
        protected $id;
        /** @var int */
        protected $user_id;
        /** @var string */
        protected $token;
        /** @var string */
        protected $salt;
        /** @var \DateTime */
        protected $lastseen;
        /** @var string */
        protected $ip;
        /** @var string */
        protected $useragent;
        /** @var \DateTime */
        protected $validity;

        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        /**
         * @return int
         */
        public function getUserId() {}
        public function setUserId($userId) {}
        /**
         * @return string
         */
        public function getToken() {}
        public function setToken($token) {}
        /**
         * @return string
         */
        public function getSalt() {}
        public function setSalt($salt) {}
        /**
         * @return \DateTime
         */
        public function getLastseen() {}
        public function setLastseen($lastseen) {}
        /**
         * @return string
         */
        public function getIp() {}
        public function setIp($ip) {}
        /**
         * @return string
         */
        public function getUseragent() {}
        public function setUseragent($useragent) {}
        /**
         * @return \DateTime
         */
        public function getValidity() {}
        public function setValidity($validity) {}
    }

    /**
     * Entity for Auth Tokens.
     */
    class Log extends \bolt\storage\entity\entity {
        protected $id;
        protected $level;
        protected $date;
        protected $message;
        protected $username;
        protected $requesturi;
        protected $route;
        protected $ip;
        protected $file;
        protected $line;
        protected $contenttype;
        protected $contentid;
        protected $code;
        protected $dump;

    }

    /**
     * Entity for change logs.
     */
    class LogChange extends \bolt\storage\entity\entity {
        /** @var \DateTime */
        protected $date;
        /** @var int */
        protected $ownerid;
        /** @var string */
        protected $title;
        /** @var string */
        protected $contenttype;
        /** @var int */
        protected $contentid;
        /** @var string */
        protected $mutation_type;
        /** @var array */
        protected $diff;
        /** @var string */
        protected $comment;
        /** @var ClassMetadata */
        protected $contentTypeMeta;

        /**
         * @return \DateTime
         */
        public function getDate() {}
        public function setDate($date) {}
        /**
         * @return int
         */
        public function getOwnerId() {}
        public function setOwnerId($ownerId) {}
        /**
         * @return string
         */
        public function getTitle() {}
        public function setTitle($title) {}
        /**
         * @return string
         */
        public function getContentType() {}
        public function setContentType($contentType) {}
        /**
         * @return int
         */
        public function getContentId() {}
        public function setContentId($contentId) {}
        /**
         * @return string
         */
        public function getMutationType() {}
        public function setMutationType($mutationType) {}
        /**
         * @return array
         */
        public function getDiff() {}
        public function setDiff($diff) {}
        /**
         * @return string
         */
        public function getComment() {}
        public function setComment($comment) {}
        public function setContentTypeMeta(ClassMetadata $config) {}
/** @var string $type */
        public function getChangedFields(/** @var string $type */
array $contentType) {}
        private function fieldText($key, $value, array $fields) {}
        private function fieldList($key, $value, array $fields) {}
        private function fieldGeolocation($key, $value, array $fields) {}
        private function fieldImage($key, $value, array $fields) {}
        private function fieldOembed($key, $value, array $fields) {}
        private function fieldSelect($key, $value, array $fields) {}
        private function fieldVideo($key, $value, array $fields) {}
    }

    /**
     * An abstract class that other entities can inherit. Provides automatic getters and setters along
     * with serialization.
     */
    abstract class Entity implements \jsonserializable, \arrayaccess {
    use \bolt\storage\entity\entityarrayaccesstrait, \bolt\storage\entity\entityserializetrait, \bolt\storage\entity\magicattributetrait;

        /** @var int */
        protected $id;

        public function __construct($data = [ ]) {}
        public function get($key) {}
        public function set($key, $value) {}
        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        public function __toString() {}
    }

    /**
     * Entity for system logs.
     */
    class LogSystem extends \bolt\storage\entity\entity {
        /** @var int */
        protected $id;
        /** @var int */
        protected $level;
        /** @var \DateTime */
        protected $date;
        /** @var string */
        protected $message;
        /** @var int */
        protected $ownerid;
        /** @var string */
        protected $route;
        /** @var string */
        protected $requesturi;
        /** @var string */
        protected $ip;
        /** @var string */
        protected $context;
        /** @var array */
        protected $source;

        /**
         * @return int
         */
        public function getId() {}
        public function setId($id) {}
        /**
         * @return int
         */
        public function getLevel() {}
        public function setLevel($level) {}
        /**
         * @return \DateTime
         */
        public function getDate() {}
        public function setDate($date) {}
        /**
         * @return string
         */
        public function getMessage() {}
        public function setMessage($message) {}
        /**
         * @return int
         */
        public function getOwnerid() {}
        public function setOwnerid($ownerid) {}
        /**
         * @return string
         */
        public function getRoute() {}
        public function setRoute($route) {}
        /**
         * @return string
         */
        public function getRequesturi() {}
        public function setRequesturi($requestUri) {}
        /**
         * @return string
         */
        public function getIp() {}
        public function setIp($ip) {}
        /**
         * @return string
         */
        public function getContext() {}
        public function setContext($context) {}
        /**
         * @return array
         */
        public function getSource() {}
        public function setSource($source) {}
    }


    /**
     * Provides ability for an entity to serialize itself.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    trait EntitySerializeTrait {
        protected $_internal;
        public function serialize() {}
        public function jsonSerialize() {}
        public function toArray() {}
    }

    /**
     * Trait class for ContentType search.
     *
     * This is a breakout of the old Bolt\Content class and serves two main purposes:
     *   * Maintain backward compatibility for Bolt\Content through the remainder of
     *     the 2.x development/release life-cycle
     *   * Attempt to break up former functionality into sections of code that more
     *     resembles Single Responsibility Principles
     *
     * These traits should be considered transitional, the functionality in the
     * process of refactor, and not representative of a valid approach.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait ContentSearchTrait {
        /** @var int The last time we weight a searchresult */
        protected $lastWeight;
        /**
         * Get the content's query weight and something to eat it looks hungry.
         *
         * @return int
         */
        public function getSearchResultWeight() {}
        public function weighSearchResult($query) {}
        /**
         * Calculate the default field weights.
         *
         * This gives more weight to the 'slug pointer fields'.
         *
         * @return array
         */
        private function getFieldWeights() {}
        /**
         * Calculate the default taxonomy weights.
         *
         * Adds weights to taxonomies that behave like tags.
         *
         * @return array
         */
        private function getTaxonomyWeights() {}
        private function weighQueryText($subject, $complete, array $words, $max) {}
    }

    /**
     * Trait class for ContentType relations.
     *
     * This is a breakout of the old Bolt\Content class and serves two main purposes:
     *   * Maintain backward compatibility for Bolt\Content through the remainder of
     *     the 2.x development/release life-cycle
     *   * Attempt to break up former functionality into sections of code that more
     *     resembles Single Responsibility Principles
     *
     * These traits should be considered transitional, the functionality in the
     * process of refactor, and not representative of a valid approach.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait ContentValuesTrait {
        /** @var bool Whether this is a "real" ContentType or an embedded ones */
        protected $isRootType;
        public function get($name) {}
        public function excerpt($length = 200, $includeTitle = false, $focus = null) {}
        public function getExcerpt($length = 200, $includeTitle = false, $focus = null) {}
        public function getValues($json = false, $stripped = false) {}
        public function setValue($key, $value) {}
        public function setValues(array $values) {}
        public function setFromPost($values, $contenttype) {}
        /**
         * Get the first image in the content.
         *
         * @return string
         */
        public function getImage() {}
        public function getTitle($allowBasicTags = false) {}
        /**
         * Get the columnname of the title, name, caption or subject.
         *
         * @return array
         */
        public function getTitleColumnName() {}
        /**
         * Check if a ContentType field has a template set.
         *
         * @return bool
         */
        public function hasTemplateFields() {}
        /**
         * Get the template associate with a ContentType field.
         *
         * @return string
         */
        protected function getTemplateFieldsContentType() {}
        /** @var Environment $twig */
        private function getTemplateFieldConfig() {}
    }

    /**
     * Provides access to entity attributes and the schema-less _fields
     * attribute via __get and __set magic methods.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    trait MagicAttributeTrait {
    use \bolt\storage\casetransformtrait{}

        public $_fields;
        public function __get($key) {}
        public function __set($key, $value) {}
        public function __isset($key) {}
        public function __unset($key) {}
        public function __call($method, $arguments) {}
        /**
         * An internal method that builds a list of available fields depending on context.
         *
         * @return array
         **/
        protected function getFields() {}
        protected function has($field) {}
    }

    /**
     * Trait class for ContentType definitions.
     *
     * These traits should be considered transitional, the functionality in the
     * process of refactor, and not representative of a valid approach.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    trait ContentTypeTrait {
        public function fieldInfo($key) {}
        public function fieldType($key) {}
    }

    /**
     * Trait class for ContentType relations.
     *
     * This is a breakout of the old Bolt\Content class and serves two main purposes:
     *   * Maintain backward compatibility for Bolt\Content through the remainder of
     *     the 2.x development/release life-cycle
     *   * Attempt to break up former functionality into sections of code that more
     *     resembles Single Responsibility Principles
     *
     * These traits should be considered transitional, the functionality in the
     * process of refactor, and not representative of a valid approach.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait ContentTaxonomyTrait {
        public function getTaxonomy($taxonomyType = null) {}
        public function setGroup($group, $name, $taxonomytype, $sortorder = 0) {}
        public function setTaxonomy($taxonomyType, $slug, $name = '', $sortorder = 0) {}
        /**
         * Sort the taxonomy of the current object, based on the order given in taxonomy.yml.
         */
        public function sortTaxonomy() {}
    }

    /**
     * Allows array access for an entity eg:
     *     $entity['value'] is equivalent to $entity->getValue().
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    trait EntityArrayAccessTrait {
        public function offsetSet($offset, $value) {}
        public function offsetExists($offset) {}
        public function offsetUnset($offset) {}
        public function offsetGet($offset) {}
    }

    /**
     * Trait class for ContentType relations.
     *
     * This is a breakout of the old Bolt\Content class and serves two main purposes:
     *   * Maintain backward compatibility for Bolt\Content through the remainder of
     *     the 2.x development/release life-cycle
     *   * Attempt to break up former functionality into sections of code that more
     *     resembles Single Responsibility Principles
     *
     * These traits should be considered transitional, the functionality in the
     * process of refactor, and not representative of a valid approach.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait ContentRelationTrait {
        public function related($filterContentType = null, $options = [ ]) {}
        public function getRelation($filterContentType = null, $options = [ ]) {}
        public function setRelation($contentType, $id) {}
        public function clearRelation($contenttype) {}
    }

    /**
     * Trait class for ContentType routing.
     *
     * This is a breakout of the old Bolt\Content class and serves two main purposes:
     *   * Maintain backward compatibility for Bolt\Content through the remainder of
     *     the 2.x development/release life-cycle
     *   * Attempt to break up former functionality into sections of code that more
     *     resembles Single Responsibility Principles
     *
     * These traits should be considered transitional, the functionality in the
     * process of refactor, and not representative of a valid approach.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait ContentRouteTrait {
        /**
         * Creates a link to EDIT this record, if the user is logged in.
         *
         * @return string
         */
        public function editlink() {}
/** @var UrlGeneratorInterface $urlGenerator */
        public function link(/** @var UrlGeneratorInterface $urlGenerator */
$referenceType = UrlGeneratorInterface::ABSOLUTE_PATH) {}
        /**
         * Checks if the current record is set as the homepage.
         *
         * @return bool
         */
        public function isHome() {}
        /**
         * Returns [route name, route params] for url generation, or null for various reasons.
         *
         * @return array|null
         */
        public function getRouteNameAndParams() {}
        /**
         * Retrieves the first route applicable to the content as a two-element array consisting of the binding and the
         * route array. Returns `null` if there is no applicable route.
         *
         * @return array|null
         */
        protected function getRouteConfig() {}
        protected function getRouteRequirementParams(array $route) {}
        protected function isApplicableRoute(array $route) {}
        /**
         * Get the reference to this record, to uniquely identify this specific record.
         *
         * @return string
         */
        protected function getReference() {}
        /**
         * Get a record's slug depending on the type of object used.
         *
         * @return string|int
         */
        private function getLinkSlug() {}
    }

}

namespace Bolt\Storage\Field {
    /**
     * Class to manage instances of fields and instantiate the defaults.
     *
     * @deprecated Deprecated since 3.0, to be removed in 4.0 see src/Storage/FieldManager
     *
     * @author Ross Riley <riley.ross@gmail.com>
     **/
    class Manager {
        protected $fields;
        protected $defaults;
        protected $dummyFields;

        public function __construct() {}
        public function addField(FieldInterface $field) {}
        public function addDummyField($field) {}
        public function fields() {}
        public function getField($name) {}
        public function getDatabaseField($field) {}
        public function has($field) {}
    }

    class Base implements \bolt\storage\field\fieldinterface {
        /** @var string */
        public $name;
        /** @var string */
        public $template;

        public function __construct($name, $template) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getTemplate() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageOptions() {}
    }


    /**
     * Interface implemented by content fields.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    interface FieldInterface {
        /**
         * Returns the name of the field.
         *
         * @return string The field name
         */
        function getName() ;
        /**
         * Returns the path to the template.
         *
         * @return string The template name
         */
        function getTemplate() ;
        /**
         * Returns the storage type.
         *
         * @throws DBALException
         *
         * @return Type A Valid Storage Type
         */
        function getStorageType() ;
        /**
         * Returns additional options to be passed to the storage field.
         *
         * @return array An array of options
         */
        function getStorageOptions() ;
    }

}

namespace Bolt\Storage\Field\Collection {
    /**
     * A mapping of FieldValues.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class FieldCollection extends \doctrine\common\collections\arraycollection implements \bolt\storage\field\collection\fieldcollectioninterface {
        /** @var int */
        protected $grouping;
        protected $block;
        protected $toRemove;

        public function __construct(array $elements = [ ]) {}
        /**
         * {@inheritdoc}
         */
        public function getNew() {}
        /**
         * {@inheritdoc}
         */
        public function getExisting() {}
        public function get($key) {}
        public function setGrouping($grouping) {}
        public function setBlock($block) {}
        /**
         * @return string
         */
        public function getBlock() {}
        public function add($value) {}
        public function set($key, $value) {}
        /**
         * @return \Iterator|FieldValue[]
         */
        public function getIterator() {}
        public function serialize() {}
        public function getFieldType($fieldName) {}
        public function getRenderedValue($fieldName) {}
    }

    /**
     * This class is used by lazily loaded field values. It stores a reference to an array of rows and
     * fetches from the database on demand.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class LazyFieldCollection extends \doctrine\common\collections\abstractlazycollection implements \bolt\storage\field\collection\fieldcollectioninterface {
        /** @var int[] */
        protected $references;
        /** @var EntityManager|null */
        protected $em;
        /** @var int */
        protected $grouping;
        /** @var FieldCollectionInterface */
        protected $collection;

        public function __construct(array $references = [ ], EntityManager $em = null) {}
        /**
         * {@inheritdoc}
         */
        public function getNew() {}
        /**
         * {@inheritdoc}
         */
        public function getExisting() {}
        public function setGrouping($grouping) {}
        /**
         * @return string
         */
        public function getBlock() {}
        public function getFieldType($fieldName) {}
        public function getRenderedValue($fieldName) {}
        /**
         * Handles the conversion of references to entities.
         */
        protected function doInitialize() {}
        public function serialize() {}
    }

    /**
     * This class stores an array collection of Fields.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class RepeatingFieldCollection extends \doctrine\common\collections\arraycollection {
        /** @var EntityManager */
        protected $em;
        /** @var array */
        protected $mapping;
        /** @var string */
        protected $name;

        public function __construct(EntityManager $em, array $mapping, $elements = [ ]) {}
        protected function createFrom(array $elements) {}
        public function add($collection) {}
        public function addFromArray(array $fields, $grouping = 0, $entity = null, $block = null) {}
        public function addFromReferences(array $ids, $grouping = 0) {}
        public function getOriginal($entity) {}
        public function update(RepeatingFieldCollection $collection) {}
        /**
         * @return array
         */
        public function getNew() {}
        /**
         * @return array
         */
        public function getExisting() {}
        /**
         * @return string
         */
        public function getName() {}
        public function setName($name) {}
        /**
         * @return array
         */
        public function flatten() {}
        protected function getFieldType($field, $block = null) {}
        protected function getFieldTypeName($field, $block = null) {}
        /**
         * @return FieldCollection
         */
        public function getEmptySet() {}
        public function serialize() {}
    }


    /**
     * A map of FieldValues.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface FieldCollectionInterface extends \doctrine\common\collections\collection {
        /**
         * @return int[]
         */
        function getNew() ;
        /**
         * @return int[]
         */
        function getExisting() ;
        function setGrouping($grouping) ;
        function add($value) ;
        function set($key, $value) ;
        /**
         * @return \Iterator|FieldValue[]
         */
        function getIterator() ;
        function getFieldType($fieldName) ;
        function getRenderedValue($fieldName) ;
    }

}

namespace Bolt\Storage\Field\Sanitiser {
    /**
     * Field sanitiser class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Sanitiser implements \bolt\storage\field\sanitiser\sanitiserinterface {
        /** @var array */
        protected $allowedTags;
        /** @var array */
        protected $allowedAttributes;
        /** @var array */
        protected $allowedWyswig;

        public function __construct(array $allowedTags, array $allowedAttributes, array $allowedWyswig) {}
        public function sanitise($value, $isWysiwyg = false) {}
        /**
         * {@inheritdoc}
         */
        public function getAllowedTags() {}
        public function setAllowedTags(array $allowedTags) {}
        /**
         * {@inheritdoc}
         */
        public function getAllowedAttributes() {}
        public function setAllowedAttributes(array $allowedAttributes) {}
        /**
         * Return a list of allowed tags needed for WYSIWYG field types.
         *
         * For HTML fields we want to override a few tags, e.g, it makes
         * no sense to disallow `<iframe>` if we have `embed: true` in
         * config.yml.
         *
         * @return array
         */
        protected function getWyswigAllowedTags() {}
        protected function isWysiwygEnabled($name) {}
    }


    /**
     * Sanitiser aware interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface SanitiserAwareInterface {
        /**
         * Return the sanitiser object.
         *
         * @return SanitiserInterface
         */
        function getSanitiser() ;
        function setSanitiser(SanitiserInterface $sanitiser) ;
    }

    /**
     * Field sanitiser interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface SanitiserInterface {
        function sanitise($value, $isWysiwyg = false) ;
        /**
         * Return the list of allowed HTML tags.
         *
         * @return array
         */
        function getAllowedTags() ;
        function setAllowedTags(array $allowedTags) ;
        /**
         * Return the list of allowed attributes.
         *
         * @return array
         */
        function getAllowedAttributes() ;
        function setAllowedAttributes(array $allowedAttributes) ;
    }

    /**
     * WYSIWYG aware interface.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    interface WysiwygAwareInterface {}


    /**
     * Sanitiser aware trait.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait SanitiserAwareTrait {
        /** @var SanitiserInterface */
        protected $sanitiser;
        /**
         * Return the sanitiser object.
         *
         * @return SanitiserInterface
         */
        public function getSanitiser() {}
        public function setSanitiser(SanitiserInterface $sanitiser) {}
    }

}

namespace Bolt\Storage\Field\Type {
    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class DateType extends \bolt\storage\field\type\fieldtypebase {
        public function __construct(array $mapping = [ ], EntityManager $em = null) {}
        public function query(QueryInterface $query, ClassMetadata $metadata) {}
        public function persist(QuerySet $queries, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class TextAreaType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class ImageListType extends \bolt\storage\field\type\listtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class ImageType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class TemplateSelectType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class IncomingRelationType extends \bolt\storage\field\type\relationtype {
        public function load(QueryBuilder $query, ClassMetadata $metadata) {}
        public function hydrate($data, $entity) {}
        public function persist(QuerySet $queries, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class EmbedType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class TaxonomyType extends \bolt\storage\field\type\jointypebase {
/** @var Query\SelectQuery $query */
        public function query(/** @var Query\SelectQuery $query */
QueryInterface $query, /** @var Query\SelectQuery $query */
ClassMetadata $metadata) {}
        public function load(QueryBuilder $query, ClassMetadata $metadata) {}
/** @var Collection\Taxonomy $fieldTaxonomy */
        public function hydrate(/** @var Collection\Taxonomy $fieldTaxonomy */
$data, /** @var Collection\Taxonomy $fieldTaxonomy */
$entity) {}
        public function persist(QuerySet $queries, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        protected function getPlatformGroupConcat($column, $order, $alias, QueryBuilder $query) {}
        protected function getGroup(Collection\Taxonomy $taxonomy) {}
        protected function getSortorder(Collection\Taxonomy $taxonomy) {}
        protected function getExistingTaxonomies($entity) {}
/** @var Collection\Taxonomy $collection */
        public function normalize(/** @var Collection\Taxonomy $collection */
$entity) {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class SelectMultipleType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class DateTimeType extends \bolt\storage\field\type\datetype {
        public function __construct(array $mapping = [ ], EntityManager $em = null) {}
        public function persist(QuerySet $queries, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
    }

    /**
     * This is an abstract class for a field type that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    abstract class FieldTypeBase implements \bolt\storage\field\type\fieldtypeinterface, \bolt\storage\field\fieldinterface {
    use \bolt\storage\casetransformtrait;

        /** @var string[] */
        public $mapping;
        /** @var EntityManager */
        protected $em;
        /** @var AbstractPlatform */
        protected $platform;

        public function __construct(array $mapping = [ ], EntityManager $em = null) {}
        /**
         * Returns the platform.
         *
         * @return AbstractPlatform
         */
        public function getPlatform() {}
        public function setPlatform(AbstractPlatform $platform) {}
        public function load(QueryBuilder $query, ClassMetadata $metadata) {}
        public function query(QueryInterface $query, ClassMetadata $metadata) {}
        public function persist(QuerySet $queries, $entity) {}
        public function hydrate($data, $entity) {}
        public function set($entity, $value) {}
        public function get($entity) {}
        public function present($entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * Returns the name of the Doctrine storage type to use for a field.
         *
         * @return Type
         */
        public function getStorageType() {}
        /**
         * Helper method to bridge compatibility between old and new Field interfaces. Previously a string storage
         * type was allowed whereas new behaviour is to expect a Type object.
         *
         * @return Type
         */
        protected function getStorageTypeObject() {}
        /**
         * @deprecated
         * Here to maintain compatibility with the old interface
         */
        public function getStorageOptions() {}
        /**
         * Gets the entity attribute name to be used for reading / persisting.
         *
         * @return string
         */
        public function getMappingAttribute() {}
        /**
         * Provides a template that is able to render the field.
         *
         * @deprecated
         */
        public function getTemplate() {}
        protected function isJson($value) {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class FileListType extends \bolt\storage\field\type\listtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class SelectType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class IntegerType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class GeolocationType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class VideoType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class FloatType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class TemplateFieldsType extends \bolt\storage\field\type\fieldtypebase {
        /** @var TemplateChooser */
        public $chooser;
        /** @var Environment */
        private $twig;

        public function __construct(array $mapping, EntityManager $em, TemplateChooser $chooser, Environment $twig) {}
/** @var string $key */
        public function hydrate(/** @var string $key */
$data, /** @var string $key */
$entity) {}
        public function set($entity, $value, $rawData = null) {}
        public function persist(QuerySet $queries, $entity) {}
        protected function serialize($input, ClassMetadata $metadata) {}
        protected function buildMetadata($entity, $rawData = null) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class RelationType extends \bolt\storage\field\type\jointypebase {
/** @var Query\SelectQuery $query */
        public function query(/** @var Query\SelectQuery $query */
QueryInterface $query, /** @var Query\SelectQuery $query */
ClassMetadata $metadata) {}
        public function load(QueryBuilder $query, ClassMetadata $metadata) {}
/** @var Entity\Content $entity */
        public function hydrate(/** @var Entity\Content $entity */
$data, /** @var Entity\Content $entity */
$entity) {}
        public function persist(QuerySet $queries, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        protected function getExistingRelations($entity) {}
        protected function getInverseRelations($entity) {}
        protected function getPlatformGroupConcat($column, $alias, QueryBuilder $query) {}
/** @var Collection\Relations $collection */
        public function normalize(/** @var Collection\Relations $collection */
$entity) {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ListTypeBase extends \bolt\storage\field\type\fieldtypebase {
        public function persist(QuerySet $queries, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class HiddenType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This class adds a block collection and handles additional functionality for adding
     * named blocks.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class BlockType extends \bolt\storage\field\type\repeatertype {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        public function normalize($entity) {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class CheckboxType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class MarkdownType extends \bolt\storage\field\type\fieldtypebase implements \bolt\storage\field\sanitiser\sanitiserawareinterface {
    use \bolt\storage\field\sanitiser\sanitiserawaretrait;

        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * Returns the name of the Doctrine storage type to use for a field.
         *
         * @return Type
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class RepeaterType extends \bolt\storage\field\type\fieldtypebase {
/** @var Filter $filter */
        public function query(/** @var Filter $filter */
QueryInterface $query, /** @var Filter $filter */
ClassMetadata $metadata) {}
        protected function rewriteQueryFilterParameters(Filter $filter, SelectQuery $query, $field) {}
        public function load(QueryBuilder $query, ClassMetadata $metadata) {}
        public function persist(QuerySet $queries, $entity) {}
/** @var string $key */
        public function hydrate(/** @var string $key */
$data, /** @var string $key */
$entity) {}
        public function set($entity, $val) {}
        public function normalize($entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        protected function getPlatformGroupConcat(QueryBuilder $query) {}
/** @var FieldValueRepository $repo */
        protected function getExistingFields(/** @var FieldValueRepository $repo */
$entity) {}
        protected function addToInsertQuery(QuerySet $queries, $changes, $entity) {}
        protected function addToDeleteQuery(QuerySet $queries, $changes) {}
        protected function addToUpdateQuery(QuerySet $queries, $changes) {}
        protected function getFieldType($field) {}
        protected function getFieldTypeName($field) {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class FileType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * Note: The persist() override was removed, because it was sanitising fields
     * when not desired. See https://github.com/bolt/bolt/issues/5789 for details.
     *
     * Note: After the removal of the persist() method, we can use the
     * SanitiserAwareTrait again, ensuring editors don't inadvertently insert
     * javascript in `type: text` fields. Hopefully this will also help a bit in
     * the never-ending "OMFG, an editor can self-XSS!!1!one!" discussions.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class TextType extends \bolt\storage\field\type\fieldtypebase implements \bolt\storage\field\sanitiser\sanitiserawareinterface {
    use \bolt\storage\field\sanitiser\sanitiserawaretrait;

        /**
         * {@inheritdoc}
         */
        public function getName() {}
    }

    /**
     * This is an abstract class that field types dealing with join/association functionality can extend.
     * It provides standard helpers to perform complex loads/queries/hydration across join tables.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    abstract class JoinTypeBase extends \bolt\storage\field\type\fieldtypebase {
        protected function normalizeData($data, $field, $separator = ',') {}
/** @var \Bolt\Storage\Query\SelectQuery $query */
        protected function rewriteQueryFilterParameters(/** @var \Bolt\Storage\Query\SelectQuery $query */
Filter $filter, /** @var \Bolt\Storage\Query\SelectQuery $query */
QueryInterface $query, /** @var \Bolt\Storage\Query\SelectQuery $query */
$field, /** @var \Bolt\Storage\Query\SelectQuery $query */
$column) {}
/** @var Collection\Taxonomy|Collection\Relations $collection */
        public function normalizeFromPost(/** @var Collection\Taxonomy|Collection\Relations $collection */
$entity, /** @var Collection\Taxonomy|Collection\Relations $collection */
$target) {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class HtmlType extends \bolt\storage\field\type\fieldtypebase implements \bolt\storage\field\sanitiser\wysiwygawareinterface, \bolt\storage\field\sanitiser\sanitiserawareinterface {
    use \bolt\storage\field\sanitiser\sanitiserawaretrait;

        public function hydrate($data, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * Returns the name of the Doctrine storage type to use for a field.
         *
         * @return Type
         */
        public function getStorageType() {}
    }

    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class SlugType extends \bolt\storage\field\type\fieldtypebase {
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        public function persist(QuerySet $queries, $entity) {}
        /**
         * {@inheritdoc}
         */
        public function getStorageType() {}
    }


    /**
     * This is one of a suite of basic Bolt field transformers that handles
     * the lifecycle of a field from pre-query to persist.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    interface FieldTypeInterface {
        function load(QueryBuilder $query, ClassMetadata $metadata) ;
        function query(QueryInterface $query, ClassMetadata $metadata) ;
        function persist(QuerySet $queries, $entity) ;
        function hydrate($data, $entity) ;
        function set($entity, $value) ;
        function present($entity) ;
        /**
         * Returns the name of the type.
         *
         * @return string The field name
         */
        function getName() ;
    }

}

namespace Bolt\Storage\ContentRequest {
    /**
     * Helper class for ContentType overview listings.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Listing {
        /** @var EntityManager */
        protected $em;
        /** @var Config */
        protected $config;
        /** @var Query */
        private $query;
        /** @var PagerManager */
        protected $pager;

        public function __construct(EntityManager $em, Query $query, Config $config, PagerManager $pager = null) {}
        public function action($contentTypeSlug, ListingOptions $options) {}
        protected function getContent($contentTypeSlug, array $contentParameters, ListingOptions $options) {}
        protected function runPagerQueries($results) {}
        protected function runGroupSort($results) {}
    }

    /**
     * Helper class for ContentType record (mass) field modifications and status
     * transitions.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Modify {
        /** @var EntityManager */
        protected $em;
        /** @var Users */
        protected $users;
        /** @var LoggerInterface */
        protected $loggerSystem;
        /** @var FlashLoggerInterface */
        protected $loggerFlash;

        public function __construct(EntityManager $em, Users $users, LoggerInterface $loggerSystem, FlashLoggerInterface $loggerFlash) {}
        public function action($contentTypeName, array $changeRequest) {}
        protected function modifyContentTypeRecord(Repository $repo, Content $entity, $action, $fieldData) {}
/** @var Mapping\ContentType $contentType */
        protected function deleteRecord(/** @var Mapping\ContentType $contentType */
Repository $repo, /** @var Mapping\ContentType $contentType */
Content $entity) {}
        protected function modifyRecord(Content $entity, array $fieldData) {}
        protected function modifyRecordValue(Content $entity, $field, $value) {}
        protected function transistionRecordStatus(Content $entity, $newStatus) {}
        protected function transistionRecordOwner(Content $entity, $ownerId) {}
    }

    /**
     * Class to manage record listing options.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ListingOptions {
        /** @var string */
        protected $order;
        /** @var int */
        protected $page;
        /** @var array */
        protected $taxonomies;
        /** @var string */
        protected $filter;
        /** @var bool */
        protected $groupSort;

        public function setOrder($order) {}
        /**
         * Get the order Would you like fries with that?
         *
         * @return string
         */
        public function getOrder() {}
        public function setPage($page) {}
        /**
         * Get the page.
         *
         * @return int
         */
        public function getPage() {}
        /**
         * Get the previous page number.
         *
         * @return int
         */
        public function getPreviousPage() {}
        public function setTaxonomies($taxonomies) {}
        /**
         * Get the taxonomies.
         *
         * @return array
         */
        public function getTaxonomies() {}
        public function setFilter($filter) {}
        /**
         * Get the filter.
         *
         * @return string
         */
        public function getFilter() {}
        /**
         * @return mixed
         */
        public function getGroupSort() {}
        public function setGroupSort($groupSort) {}
    }

    /**
     * Helper class for ContentType record editor edits.
     *
     * Prior to v3.0 this functionality existed in \Bolt\Controllers\Backend::editcontent().
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Edit {
        /** @var EntityManager */
        protected $em;
        /** @var Query */
        private $query;
        /** @var Config */
        protected $config;
        /** @var Users */
        protected $users;
        /** @var Manager */
        protected $filesystem;
        /** @var LoggerInterface */
        protected $loggerSystem;
        /** @var FlashLoggerInterface */
        protected $loggerFlash;

        public function __construct(EntityManager $em, Config $config, Users $users, Manager $filesystem, LoggerInterface $loggerSystem, FlashLoggerInterface $loggerFlash) {}
        public function setQueryHandler(Query $query) {}
/** @var ContentType $templateFieldsContentType */
        public function action(/** @var ContentType $templateFieldsContentType */
Content $content, /** @var ContentType $templateFieldsContentType */
ContentType $contentType, /** @var ContentType $templateFieldsContentType */
$duplicate) {}
/** @var Repository\ContentRepository $repo */
        private function getRelationsList(/** @var Repository\ContentRepository $repo */
ContentType $contentType) {}
        private function neededFields($relationValues, $relationConfig) {}
        private function getTemplateFieldTemplates(ContentType $contentType, Content $content) {}
        private function getPublishingDate($date, $setNowOnEmpty = false) {}
        private function createGroupTabs(ContentType $contentType, array $has) {}
        private function getUsedFieldtypes(ContentType $contentType, Content $content, array $has) {}
    }

    /**
     * Helper class for ContentType record editor saves.
     *
     * Prior to v3.0 this functionality existed in \Bolt\Controllers\Backend::editcontent().
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Save {
        /** @var EntityManager */
        protected $em;
        /** @var Config */
        protected $config;
        /** @var Users */
        protected $users;
        /** @var LoggerInterface */
        protected $loggerChange;
        /** @var LoggerInterface */
        protected $loggerSystem;
        /** @var FlashLoggerInterface */
        protected $loggerFlash;
        /** @var UrlGeneratorInterface */
        protected $urlGenerator;
        /** @var SlugifyInterface */
        private $slugify;

        public function __construct(EntityManager $em, Config $config, Users $users, LoggerInterface $loggerChange, LoggerInterface $loggerSystem, FlashLoggerInterface $loggerFlash, UrlGeneratorInterface $urlGenerator, SlugifyInterface $slugify = null) {}
        public function action(array $formValues, array $contentType, $id, $new, $returnTo, $editReferrer) {}
        private function setTransitionStatus(Entity\Content $content, $contentTypeSlug, $id, $oldStatus) {}
        private function setPostedValues(Entity\Content $content, $formValues, $contentType) {}
/** @var Collection\Relations $related */
        private function setPostedRelations(/** @var Collection\Relations $related */
Entity\Content $content, /** @var Collection\Relations $related */
$formValues) {}
/** @var Collection\Taxonomy $taxonomies */
        private function setPostedTaxonomies(/** @var Collection\Taxonomy $taxonomies */
Entity\Content $content, /** @var Collection\Taxonomy $taxonomies */
$formValues) {}
        private function saveContentRecord(Entity\Content $content, $oldContent, array $contentType, $new, $comment, $returnTo, $editReferrer) {}
        private function setSuccessfulControlValues(array $formValues, $fields) {}
        private function createJsonUpdate(Entity\Content $content, $flush) {}
        private function logChange($contentType, $contentId, $newContent = null, $oldContent = null, $comment = null) {}
/** @var UrlGeneratorInterface $generator */
        private function generateUrl(/** @var UrlGeneratorInterface $generator */
$name, /** @var UrlGeneratorInterface $generator */
$params = [ ], /** @var UrlGeneratorInterface $generator */
$referenceType = UrlGeneratorInterface::ABSOLUTE_PATH) {}
        private function isEmptyArray($input) {}
    }

}

namespace Bolt\Storage\EventProcessor {
    /**
     * Timed record (de)publishing handler.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class TimedRecord {
        const CACHE_KEY_PUBLISH = 'publish.timer.publish';
        const CACHE_KEY_HOLD = 'publish.timer.hold';

        /** @var array */
        protected $contentTypeNames;
        /** @var EntityManagerInterface */
        protected $em;
        /** @var CacheProvider */
        protected $cache;
        /** @var EventDispatcherInterface */
        protected $dispatcher;
        /** @var LoggerInterface */
        protected $systemLogger;
        /** @var int */
        protected $interval;

        public function __construct(array $contentTypeNames, EntityManagerInterface $em, CacheProvider $cache, EventDispatcherInterface $dispatcher, LoggerInterface $systemLogger, $interval) {}
        /**
         * Get the timer for publishing timed records.
         */
        public function isDuePublish() {}
        /**
         * Get the timer for publishing timed records.
         */
        public function isDueHold() {}
        /**
         * Check (and update) any records that need to be updated from "timed" to "published".
         */
        public function publishTimedRecords() {}
        /**
         * Check (and update) any records that need to be updated from "published" to "held".
         */
        public function holdExpiredRecords() {}
/** @var Content $content */
        private function timedHandleRecords(/** @var Content $content */
$contentTypeName, /** @var Content $content */
$type) {}
        private function save(ContentRepository $contentRepo, Content $content, $type, $legacyType) {}
/** @deprecated Deprecated since 3.1, to be removed in 4.0. */
        private function dispatch(/** @deprecated Deprecated since 3.1, to be removed in 4.0. */
Content $content, /** @deprecated Deprecated since 3.1, to be removed in 4.0. */
$type, /** @deprecated Deprecated since 3.1, to be removed in 4.0. */
$legacyType) {}
/** @var QueryBuilder $query */
        private function getTimedRecords(/** @var QueryBuilder $query */
ContentRepository $contentRepo, /** @var QueryBuilder $query */
$type) {}
        private function getTimedPublishQuery(QueryBuilder $query) {}
        private function getHoldQuery(QueryBuilder $query) {}
    }

}

namespace Bolt\Storage\Query {
    /**
     * This class builds on the default QueryResultset to add
     * the ability to merge sets based on weighted scores.
     */
    class SearchQueryResultset extends \bolt\storage\query\queryresultset {
        /** @var array */
        protected $results;
        /** @var array */
        protected $scores;

        public function add($results, $type = null, $scores = [ ]) {}
        public function sortSingle($label) {}
    }

    /**
     *  This query class coordinates a select query build from Bolt's
     *  custom query DSL as documented here:.
     *
     *  @see https://docs.bolt.cm/templates/content-fetching
     *
     *  The resulting QueryBuilder object is then passed through to the individual
     *  field handlers where they can perform value transformations.
     *
     *  @author Ross Riley <riley.ross@gmail.com>
     */
    class SelectQuery implements \bolt\storage\query\queryinterface {
        /** @var QueryBuilder */
        protected $qb;
        /** @var QueryParameterParser */
        protected $parser;
        /** @var string */
        protected $contentType;
        /** @var array */
        protected $params;
        /** @var Filter[] */
        protected $filters;
        protected $replacements;
        /** @var bool */
        protected $singleFetchMode;

        public function __construct(QueryBuilder $qb, QueryParameterParser $parser) {}
        public function setContentType($contentType) {}
        /**
         * Gets the ContentType that this query will run against.
         *
         * @return string
         */
        public function getContentType() {}
        public function setParameters(array $params) {}
        public function getParameter($name) {}
        public function setParameter($name, $value) {}
        /**
         * Creates a composite expression that adds all the attached
         * filters individual expressions into a combined one.
         *
         * @return CompositeExpression
         */
        public function getWhereExpression() {}
        /**
         * Returns all the parameters for the query.
         *
         * @return array
         */
        public function getWhereParameters() {}
        public function getWhereParametersFor($fieldName) {}
        public function setWhereParameter($key, $value) {}
        public function addFilter(Filter $filter) {}
        /**
         * Returns all the filters attached to the query.
         *
         * @return Filter[]
         */
        public function getFilters() {}
        /**
         * Part of the QueryInterface this turns all the input into a Doctrine
         * QueryBuilder object and is usually run just before query execution.
         * That allows modifications to be made to any of the parameters up until
         * query execution time.
         *
         * @return QueryBuilder
         */
        public function build() {}
        /**
         * Allows public access to the QueryBuilder object.
         *
         * @return QueryBuilder
         */
        public function getQueryBuilder() {}
        public function setQueryBuilder(QueryBuilder $qb) {}
        /**
         * Returns whether the query is in single fetch mode.
         *
         * @return bool
         */
        public function getSingleFetchMode() {}
        public function setSingleFetchMode($value) {}
        /**
         * @return string String representation of query
         */
        public function __toString() {}
        /**
         * Internal method that runs the individual key/value input through
         * the QueryParameterParser. This allows complicated expressions to
         * be turned into simple sql expressions.
         */
        protected function processFilters() {}
    }

    /**
     * This class takes an overall config array as input and parses into values
     * applicable for performing searches.
     *
     * This takes into account ContentTypes that aren't searchable along with
     * taxonomy and field weightings.
     */
    class SearchConfig {
        /** @var array|Config */
        protected $config;
        /** @var array */
        protected $searchableTypes;
        /** @var array */
        protected $invisibleTypes;
        /** @var array */
        protected $joins;
        protected $searchInvisible;

        public function __construct(Config $config) {}
        public function getConfig($contentType) {}
        public function getFieldConfig($contentType, $field) {}
        /**
         * Iterates over the main config and delegates weighting to both
         * searchable columns and searchable taxonomies.
         */
        protected function parseContenttypes() {}
        protected function parseTaxonomies($contentType, $taxonomies) {}
        public function getJoins($contentType) {}
        protected function getSearchableColumns($type) {}
        protected function isInvisible($contentType) {}
        /**
         * @return bool
         */
        public function canSearchInvisible() {}
        public function enableSearchInvisible($searchInvisible) {}
    }

    /**
     *  Handler class to convert the DSL for content query parameters
     *  into equivalent DBAL expressions.
     *
     *  @author Ross Riley <riley.ross@gmail.com>
     */
    class QueryParameterParser {
        /** @var string */
        public $alias;
        /** @var string */
        protected $key;
        /** @var mixed */
        protected $value;
        /** @var ExpressionBuilder */
        protected $expr;
        /** @var array */
        protected $valueMatchers;
        /** @var Filter[] */
        protected $filterHandlers;

        public function __construct(ExpressionBuilder $expr = null) {}
        public function setupDefaults() {}
        public function setAlias($alias) {}
/** @var callable $callback */
        public function getFilter(/** @var callable $callback */
$key, /** @var callable $callback */
$value = null) {}
        public function incorrectQueryHandler($key, $value, $expr) {}
        public function multipleKeyAndValueHandler($key, $value, $expr) {}
        public function multipleValueHandler($key, $value, $expr) {}
        public function defaultFilterHandler($key, $value, $expr) {}
        public function parseValue($value) {}
        public function addFilterHandler(callable $handler) {}
        public function addValueMatcher($token, $params = [ ], $priority = null) {}
    }

    /**
     * This class takes an overall config array as input and parses into values
     * applicable for performing select queries.
     *
     * This takes into account default ordering for ContentTypes.
     */
    class FrontendQueryScope implements \bolt\storage\query\queryscopeinterface {
        /** @var array|Config */
        protected $config;
        /** @var array */
        protected $orderBys;

        public function __construct(Config $config) {}
        public function getConfig($contentType) {}
        public function getOrder($contentType) {}
        /**
         * Iterates over the main config and delegates weighting to both
         * searchable columns and searchable taxonomies.
         */
        protected function parseContenttypes() {}
        public function onQueryExecute(QueryInterface $query) {}
    }

    /**
     *  Handler class to convert the DSL for content queries into an
     *  object representation.
     *
     *  @author Ross Riley <riley.ross@gmail.com>
     */
    class ContentQueryParser {
        /** @var EntityManager */
        protected $em;
        /** @var string */
        protected $query;
        /** @var array */
        protected $params;
        /** @var array */
        protected $contentTypes;
        /** @var string */
        protected $operation;
        /** @var string */
        protected $identifier;
        /** @var array */
        protected $operations;
        /** @var array */
        protected $directives;
        /** @var callable[] */
        protected $directiveHandlers;
        /** @var callable[] */
        protected $handlers;
        /** @var QueryInterface[] */
        protected $services;
        /** @var QueryScopeInterface */
        protected $scope;

        public function __construct(EntityManager $em, QueryInterface $queryHandler = null) {}
        /**
         * Internal method to initialise the default handlers.
         */
        protected function setupDefaults() {}
        public function setQuery($query) {}
        public function setParameters(array $params) {}
        public function setParameter($param, $value) {}
        /**
         * Parse a query.
         */
        public function parse() {}
        /**
         * Parses the content area of the querystring.
         */
        protected function parseContent() {}
        /**
         * Internal method that takes the 'query' part of the input and
         * parses it into one of the various operations supported.
         *
         * A simple select operation will just contain the ContentType eg 'pages'
         * but additional operations can be triggered using the '/' separator.
         *
         * @internal
         */
        protected function parseOperation() {}
        /**
         * Directives are all of the other parameters supported by Bolt that do not
         * relate to an actual filter query. Some examples include 'printquery', 'limit',
         * 'order' or 'returnsingle'.
         *
         * All these need to parsed and taken out of the params that are sent to the query.
         */
        protected function parseDirectives() {}
        public function runDirectives(QueryInterface $query, array $skipDirective = [ ]) {}
        public function setScope(QueryScopeInterface $scope) {}
        public function runScopes(QueryInterface $query) {}
        /**
         * Gets the object EntityManager.
         *
         * @return EntityManager
         */
        public function getEntityManager() {}
        /**
         * Returns the parsed content types.
         *
         * @return array
         */
        public function getContentTypes() {}
        /**
         * Returns the parsed operation.
         *
         * @return string
         */
        public function getOperation() {}
        /**
         * Returns the parsed identifier.
         *
         * @return string
         */
        public function getIdentifier() {}
        public function getDirective($key) {}
        public function setDirective($key, $value) {}
        public function getDirectiveHandler($check) {}
        public function hasDirectiveHandler($check) {}
        public function addDirectiveHandler($key, callable $callback = null) {}
        public function addHandler($operation, callable $callback) {}
        public function getHandler($operation) {}
        public function addService($operation, $service) {}
        public function getService($operation) {}
        /**
         * Returns the current parameters.
         *
         * @return array
         */
        public function getParameters() {}
        public function hasParameter($param) {}
        public function getParameter($param) {}
        /**
         * Runs the query and fetches the results.
         *
         * @return QueryResultset|Content|null
         */
        public function fetch() {}
        /**
         * Getter to return the currently registered operations.
         *
         * @return array
         */
        public function getOperations() {}
        public function addOperation($operation) {}
        public function removeOperation($operation) {}
    }

    /**
     * This class takes a fetched resultset and sorts them based on the weighting
     * settings in the SearchConfig class.
     */
    class SearchWeighter {
        /** @var SearchConfig */
        protected $config;
        /** @var QueryResultset|array */
        protected $results;
        /** @var array */
        protected $searchWords;
        /** @var string */
        protected $contentType;

        public function __construct(SearchConfig $config) {}
        public function setResults(array $results) {}
        public function setContentType($type) {}
        public function setSearchWords(array $words) {}
        /**
         * This is the public method that gets a score for a the set of results.
         *
         * @return array An array of scores for each of the corresponding results
         */
        public function weight() {}
        /**
         * Helper method to fetch the fields for an individual ContentType.
         *
         * @return array|false
         */
        protected function getContentFields() {}
        protected function buildResultIndex($result) {}
        protected function getResultScore($result) {}
    }

    /**
     *  This class represents a single filter that converts to an expression along
     *  with associated query values.
     *
     *
     *  @author Ross Riley <riley.ross@gmail.com>
     */
    class Filter {
        protected $key;
        /** @var CompositeExpression */
        protected $expression;
        /** @var array */
        protected $parameters;

        public function setKey($key) {}
        /**
         * Getter for key.
         *
         * @return string
         */
        public function getKey() {}
        /**
         * Gets the compiled expression as a string. This will look
         * something like `(alias.key = :placeholder)`.
         *
         * @return string
         */
        public function getExpression() {}
        public function setExpression(CompositeExpression $expression) {}
        /**
         * Returns the actual object of the expression. This is generally
         * only needed for on the fly modification, to get the compiled
         * expression use getExpression().
         *
         * @return CompositeExpression
         */
        public function getExpressionObject() {}
        /**
         * Returns the array of parameters attached to this filter. These are
         * normally used to replace placeholders at compile time.
         *
         * @return array
         */
        public function getParameters() {}
        public function setParameters(array $parameters) {}
        public function hasParameter($param) {}
        public function setParameter($param, $value) {}
    }

    /**
     * This class is a wrapper that handles single or multiple
     * sets or results fetched via a query. They can be iterated
     * normally, or split by label, eg just results from one
     * ContentType.
     */
    class QueryResultset extends \appenditerator implements \countable {
        /** @var array */
        protected $results;
        /** @var QueryBuilder[] */
        protected $originalQueries;

        public function add($results, $type = null) {}
        public function get($label = null) {}
        /**
         * Returns the total count.
         *
         * @return int
         */
        public function count() {}
        public function setOriginalQuery($type, $originalQuery) {}
        public function getOriginalQuery($type = null) {}
        /**
         * @return QueryBuilder[]
         */
        public function getOriginalQueries() {}
    }

    class Query {
        /** @var ContentQueryParser */
        protected $parser;
        /** @var array */
        protected $scopes;

        public function __construct(ContentQueryParser $parser) {}
        public function addScope($name, QueryScopeInterface $scope) {}
        public function getScope($name) {}
        public function getContent($textQuery, array $parameters = [ ]) {}
        public function getContentByScope($scopeName, $textquery, $parameters = [ ]) {}
    }

    /**
     * This query class coordinates a search query building mainly on the same
     * filtering system used in the SelectQuery class. The main difference is
     * the addition of weighting, which is driven by documented here:.
     *
     *  @see https://docs.bolt.cm/templates/content-search
     *
     *  The resulting QueryBuilder object is then passed through to the individual
     *  field handlers where they can perform value transformations.
     *
     *  @author Ross Riley <riley.ross@gmail.com>
     */
    class SearchQuery extends \bolt\storage\query\selectquery {
        /** @var string */
        protected $search;
        /** @var SearchConfig */
        protected $config;

        public function __construct(QueryBuilder $qb, QueryParameterParser $parser, SearchConfig $config) {}
        public function setSearch($search) {}
        public function setParameters(array $params) {}
        /**
         * Gets the individual elements of the search query as an array.
         *
         * @return array
         */
        public function getSearchWords() {}
        /**
         * This is an internal helper method to get the search words prepared to
         * be passed to the expression builder.
         *
         * @return string
         */
        protected function getSearchParameter() {}
        /**
         * This overrides the SelectQuery default to do some extra preparation for a search query.
         * Firstly it builds separate filters for the search query and then it removes the filter
         * from the params and the others will then get processed normally by the parent.
         */
        protected function processFilters() {}
        /** @var Filter $filter */
        public function getWhereExpression() {}
    }


    /**
     * Interface QueryScopeInterface
     * Interface defines a class that provides additional scoping for a Query.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    interface QueryScopeInterface {
        function onQueryExecute(QueryInterface $query) ;
    }

    /**
     * Interface that defines minimum functionality of a Bolt Query class.
     *
     * The goal of a query is to store select and filter parameters that can be
     * used to create a relevant SQL expression.
     */
    interface QueryInterface {
        /**
         * Builds the query and returns an instance of QueryBuilder.
         *
         * @return \Doctrine\DBAL\Query\QueryBuilder
         */
        function build() ;
        /**
         * Returns the current instance of QueryBuilder.
         *
         * @return \Doctrine\DBAL\Query\QueryBuilder
         */
        function getQueryBuilder() ;
    }

}

namespace Bolt\Storage\Query\Handler {
    /**
     *  Handler class to perform select query and return a resultset.
     */
    class SelectQueryHandler {
/** Continue and run the query add the results to the set */
        public function __invoke(/** Continue and run the query add the results to the set */
ContentQueryParser $contentQuery) {}
        public function whitelistParameters(array $queryParams, Repository $repo) {}
    }

    /**
     *  Handler to modify query based on activation of 'first' modifier.
     *
     *  eg: 'pages/first/3'
     */
    class FirstQueryHandler {
        public function __invoke(ContentQueryParser $contentQuery) {}
    }

    /**
     *  Handler class to perform search query and then weight the fetched result set.
     */
    class SearchQueryHandler {
/** @var SearchWeighter $weighter */
        public function __invoke(/** @var SearchWeighter $weighter */
ContentQueryParser $contentQuery) {}
    }

    /**
     *  Handler to modify query based on activation of 'latest' modifier.
     *
     *  eg: 'pages/latest/10'
     */
    class LatestQueryHandler {
        public function __invoke(ContentQueryParser $contentQuery) {}
    }

    /**
     *  Handler to fetch a single record if an identifier is set in the query.
     */
    class IdentifiedSelectHandler {
        public function __invoke(ContentQueryParser $contentQuery) {}
    }

    /**
     * Handler class to perform a native search where the db adapter supports full-text
     * language searching, thus avoiding the need to weight the results in PHP code.
     */
    class NativeSearchHandler {
        public function __invoke(ContentQueryParser $contentQuery) {}
        public function postgresSearch(ContentQueryParser $contentQuery) {}
    }

    /**
     *  Handler for queries requested with the random modifier.
     *
     *  eg: 'pages/random/10'
     */
    class RandomQueryHandler {
        public function __invoke(ContentQueryParser $contentQuery) {}
    }

}

namespace Bolt\Storage\Query\Adapter {
    /**
     *  Handler to build a fulltext search query for Postgres.
     */
    class PostgresSearch {
        protected $qb;
        protected $config;
        protected $searchWords;
        protected $contentType;

        public function __construct(QueryBuilder $qb, SearchConfig $config, array $searchWords) {}
        public function setContentType($type) {}
        public function getQuery() {}
        public function getWeight($score) {}
    }

}

namespace Bolt\Storage\Query\Directive {
    /**
     *  Directive that allows running of a callback on query.
     */
    class GetQueryDirective {
        public function __invoke(QueryInterface $query, callable $callback) {}
    }

    /**
     *  Directive to add a limit modifier to the query.
     */
    class PagingDirective {
        public function __invoke(QueryInterface $query, $limit) {}
    }

    /**
     *  Directive to add a limit modifier to the query.
     */
    class HydrateDirective {
        public function __invoke(QueryInterface $query, $limit) {}
    }

    /**
     *  Directive to specify that a single object, rather than an array should be returned.
     */
    class ReturnSingleDirective {
        public function __invoke(QueryInterface $query) {}
    }

    /**
     *  Directive a raw output of the generated query.
     */
    class PrintQueryDirective {
        public function __invoke(QueryInterface $query) {}
    }

    /**
     *  Directive to alter query based on 'order' parameter.
     *
     *  eg: 'pages', ['order'=>'-datepublish']
     */
    class OrderDirective {
        public function __invoke(QueryInterface $query, $order) {}
        protected function getOrderBys($order) {}
        protected function isMultiOrderQuery($order) {}
    }

    /**
     *  Directive to add a limit modifier to the query.
     */
    class LimitDirective {
        public function __invoke(QueryInterface $query, $limit) {}
    }

    /**
     *  Directive to add a limit modifier to the query.
     */
    class OffsetDirective {
        public function __invoke(SelectQuery $query, $page, $otherDirectives) {}
    }

}

namespace Bolt\Storage\Migration {
    /**
     * Database records import class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Bob den Otter <bob@twokings.nl>
     */
    final class Import {
        /** @var EntityManager */
        private $em;
        /** @var Query */
        private $query;
        /** @var Bag */
        private $contentTypes;

        public function __construct(EntityManager $em, Query $query, Bag $contentTypes) {}
        public function run(Bag $importData, MutableBag $responseBag, $overwrite = false, Bag $importUsers = null) {}
/** @var Repository\UsersRepository $repo */
        private function importUsers(/** @var Repository\UsersRepository $repo */
Bag $importUsers, /** @var Repository\UsersRepository $repo */
MutableBag $responseBag) {}
/** @var Content $entity */
        private function importContentType(/** @var Content $entity */
$contentTypeName, /** @var Content $entity */
Bag $importData, /** @var Content $entity */
MutableBag $relationQueue, /** @var Content $entity */
MutableBag $responseBag, /** @var Content $entity */
$overwrite) {}
/** @var Collection\Taxonomy $taxonomies */
        private function addTaxonomy(/** @var Collection\Taxonomy $taxonomies */
Content $entity, /** @var Collection\Taxonomy $taxonomies */
Bag $taxonomyFields, /** @var Collection\Taxonomy $taxonomies */
Bag $importDatum) {}
        private function addRelations(Repository $repo, MutableBag $relationQueue, Bag $importDatum, MutableBag $relationFields) {}
/** @var Collection\Relations $related */
        private function processRelationQueue(/** @var Collection\Relations $related */
Bag $relationQueue) {}
        private function validateContentTypes(Bag $importData) {}
    }

    /**
     * Database records export class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Bob den Otter <bob@twokings.nl>
     */
    final class Export {
        /** @var EntityManager */
        private $em;
        /** @var Query */
        private $query;

        public function __construct(EntityManager $em, Query $query) {}
        public function run(array $exportContentTypes, MutableBag $responseBag, $includeUsers = false) {}
        private function addExportMeta(MutableBag $exportData) {}
        private function addExportUsers(MutableBag $exportData) {}
/** @var MutableBag $success */
        private function getRecords(/** @var MutableBag $success */
$contentTypeName, /** @var MutableBag $success */
MutableBag $exportData, /** @var MutableBag $success */
MutableBag $responseBag) {}
/** @var Entity $val */
        private function addRecord(/** @var Entity $val */
MutableBag $contentTypeBag, /** @var Entity $val */
ClassMetadata $metadata, /** @var Entity $val */
Content $entity) {}
    }

}

namespace Bolt\Controller {
    /**
     * Add routes from the configuration file.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class ConfigurableBase extends \bolt\controller\base {
        /** @var CallbackResolver $callbackResolver */
        private $callbackResolver;

        public function connect(Application $app) {}
        public function before(Request $request) {}
        public function after(Request $request, Response $response) {}
        /**
         * Return routes (as arrays) that will be converted to route objects.
         *
         * @return array
         */
        abstract protected function getConfigurationRoutes() ;
        protected function addRoutes(ControllerCollection $c) {}
        protected function addRoute(ControllerCollection $ctr, $name, array $config) {}
        protected function resolveBefore($before) {}
        protected function resolveAfter($after) {}
        protected function resolveMiddleware($callback) {}
    }

    /**
     * @deprecated Deprecated since 3.0, to be removed in 4.0. Use {@see Bolt\Controller\Requirement} instead.
     */
    class Routing extends \bolt\controller\requirement {
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use {@see Bolt\Controller\Requirement::anyContentType} instead.
         */
        public function getAnyContentTypeRequirement() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use {@see Bolt\Controller\Requirement::pluralContentTypes} instead.
         */
        public function getPluralContentTypeRequirement() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use {@see Bolt\Controller\Requirement::anyTaxonomyType} instead.
         */
        public function getAnyTaxonomyTypeRequirement() {}
        /**
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use {@see Bolt\Controller\Requirement::pluralTaxonomyTypes} instead.
         */
        public function getPluralTaxonomyTypeRequirement() {}
        public function getTaxonomyRequirement($taxonomyName, $emptyValue = 'none') {}
        private function deprecationWarn($old, $new) {}
    }

    /**
     * Base class for all controllers which mainly provides shortcut methods for
     * application services.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class Base implements \silex\controllerproviderinterface {
        /** @var Application */
        protected $app;

        public function connect(Application $app) {}
        abstract protected function addRoutes(ControllerCollection $c) ;
        protected function abort($statusCode, $message = '', array $headers = [ ]) {}
        protected function render($template, array $context = [ ], array $globals = [ ]) {}
/** @deprecated since 3.4 to be removed in 4.0 */
        private function addResolvedRoute(/** @deprecated since 3.4 to be removed in 4.0 */
array $context, /** @deprecated since 3.4 to be removed in 4.0 */
$template) {}
        protected function json($data = [ ], $status = 200, array $headers = [ ]) {}
        protected function createForm($type = FormType::class, $data = null, array $options = [ ]) {}
        protected function createFormBuilder($type = FormType::class, $data = null, array $options = [ ]) {}
/** @var UrlGeneratorInterface $generator */
        protected function generateUrl(/** @var UrlGeneratorInterface $generator */
$name, /** @var UrlGeneratorInterface $generator */
$params = [ ], /** @var UrlGeneratorInterface $generator */
$referenceType = UrlGeneratorInterface::ABSOLUTE_PATH) {}
        protected function redirect($url, $status = 302) {}
        protected function redirectToRoute($route, array $parameters = [ ], $status = 302) {}
        /**
         * Returns the Entity Manager.
         *
         * @return \Bolt\Storage\EntityManager|\Bolt\Legacy\Storage
         */
        protected function storage() {}
        /**
         * Returns the session.
         *
         * @return \Symfony\Component\HttpFoundation\Session\Session
         */
        protected function session() {}
        /**
         * Gets the flash logger.
         *
         * @return \Bolt\Logger\FlashLoggerInterface
         */
        protected function flashes() {}
        /**
         * Returns the Authentication object.
         *
         * @return \Bolt\AccessControl\AccessChecker
         */
        protected function accessControl() {}
        protected function validateCsrfToken($value = null, $id = 'bolt') {}
        protected function isCsrfTokenValid($value = null, $id = 'bolt') {}
        /**
         * Gets the \Bolt\Extensions object.
         *
         * @return \Bolt\Extension\Manager
         */
        protected function extensions() {}
        /**
         * Gets the Bolt\Filesystem\Manager object.
         *
         * @return \Bolt\Filesystem\Manager
         */
        protected function filesystem() {}
        /**
         * Returns the Users object.
         *
         * @return \Bolt\Users
         */
        protected function users() {}
        /**
         * Check to see if the user table exists and has records.
         *
         * @return bool
         */
        protected function hasUsers() {}
/** @var Repository\UsersRepository $repo */
        protected function getUser(/** @var Repository\UsersRepository $repo */
$userId = null) {}
/** @var Token $sessionAuth */
        protected function isAllowed(/** @var Token $sessionAuth */
$what, /** @var Token $sessionAuth */
$user = null, /** @var Token $sessionAuth */
$contenttype = null, /** @var Token $sessionAuth */
$contentid = null) {}
        protected function getRepository($repository) {}
        protected function getContent($textQuery, $parameters = [ ], $pager = [ ], $whereParameters = [ ]) {}
        protected function getContentType($slug) {}
        protected function getContentTypeUserPermissions($contentTypeSlug, $user = null) {}
        protected function getOption($path, $default = null) {}
        protected function getRefererQueryParameters(Request $request) {}
        /**
         * Return the Bolt\TemplateChooser provider.
         *
         * @return \Bolt\TemplateChooser
         */
        protected function templateChooser() {}
        /**
         * Return a new Query Builder.
         *
         * @return \Doctrine\DBAL\Query\QueryBuilder
         */
        protected function createQueryBuilder() {}
        /**
         * @return \Bolt\Configuration\ResourceManager
         */
        protected function resources() {}
    }

    /**
     * Zone constants class to define which part of the Bolt site that a request is
     * relative to.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Zone {
        const BACKEND = 'backend';
        const ASYNC = 'async';
        const FRONTEND = 'frontend';
        const KEY = 'zone';

        public static function isFrontend(Request $request) {}
        public static function isBackend(Request $request) {}
        public static function isAsync(Request $request) {}
        public static function is(Request $request, $value) {}
        public static function get(Request $request) {}
        public static function set(Request $request, $value) {}
    }

    /**
     * Standard Frontend actions.
     *
     * This file acts as a grouping for the default front-end controllers.
     *
     * For overriding the default behavior here, please reference
     * https://docs.bolt.cm/templating/templates-routes#routing or the routing.yml
     * file in your configuration.
     */
    class Frontend extends \bolt\controller\configurablebase {
        protected function getConfigurationRoutes() {}
        protected function addRoutes(ControllerCollection $c) {}
        public function before(Request $request) {}
        public function after(Request $request, Response $response) {}
        public function homepage(Request $request) {}
        public function record(Request $request, $contenttypeslug, $slug = '') {}
        public function preview(Request $request, $contenttypeslug) {}
        public function listing(Request $request, $contenttypeslug) {}
        public function taxonomy(Request $request, $taxonomytype, $slug) {}
        protected function isTaxonomyValid($content, $slug, array $taxonomy) {}
/** @var \Bolt\Pager\PagerManager $manager */
        public function search(/** @var \Bolt\Pager\PagerManager $manager */
Request $request, /** @var \Bolt\Pager\PagerManager $manager */
array $contenttypes = null) {}
        public function template($template) {}
        private function getListingParameters($contentTypeSlug, $allowViewless = false) {}
        private function getListingOrder(array $contentType) {}
    }

    /**
     * Defines route requirements from content types / taxonomy configurations.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Requirement {
        /** @var Config $config */
        protected $config;

        public function __construct(Config $config) {}
        /**
         * Return plural and singular content type slugs.
         *
         * @return string
         */
        public function anyContentType() {}
        /**
         * Return only plural content type slugs.
         *
         * @return string
         */
        public function pluralContentTypes() {}
        /**
         * Return plural and singular taxonomy type slugs.
         *
         * @return string
         */
        public function anyTaxonomyType() {}
        /**
         * Return only plural taxonomy type slugs.
         *
         * @return string
         */
        public function pluralTaxonomyTypes() {}
        public function singleTaxonomy($taxonomyName, $emptyValue = 'none') {}
        protected function configAssert($key, $singular) {}
    }

}

namespace Bolt\Controller\Async {
    /**
     * Base class for all async controllers.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class AsyncBase extends \bolt\controller\base {
        public function connect(Application $app) {}
        public function before(Request $request) {}
    }

    /**
     * Async controller for record manipulation routes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Records extends \bolt\controller\async\asyncbase {
        protected function addRoutes(ControllerCollection $c) {}
        public function action(Request $request) {}
    }

    /**
     * Async controller for embed routes.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Embed extends \bolt\controller\async\asyncbase {
        protected function addRoutes(ControllerCollection $c) {}
/** @var \Bolt\Embed\Resolver $resolver */
        public function embed(/** @var \Bolt\Embed\Resolver $resolver */
Request $request) {}
    }

    /**
     * Async controller for Stack async routes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Stack extends \bolt\controller\async\asyncbase {
        protected function addRoutes(ControllerCollection $c) {}
/** @var FileInterface|null $removed */
        public function add(/** @var FileInterface|null $removed */
Request $request) {}
        public function show(Request $request) {}
    }

    /**
     * Async controller for filesystem management async routes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class FilesystemManager extends \bolt\controller\async\asyncbase {
        protected function addRoutes(ControllerCollection $ctr) {}
        public function browse(Request $request, $namespace, $path) {}
        public function createFolder(Request $request) {}
        public function createFile(Request $request) {}
        public function deleteFile(Request $request) {}
        public function duplicateFile(Request $request) {}
/** @var \Bolt\Filesystem\Handler\File $file */
        public function filesAutoComplete(/** @var \Bolt\Filesystem\Handler\File $file */
Request $request) {}
        /**
         * List records to easily insert links through the WYSIWYG editor.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function recordBrowser() {}
        public function removeFolder(Request $request) {}
        public function renameFile(Request $request) {}
        public function renameFolder(Request $request) {}
        private function isMatchingExtension($oldName, $newName) {}
        private function logException($message, $exception) {}
    }

    /**
     * Async controller for general async routes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class General extends \bolt\controller\async\asyncbase {
        protected function addRoutes(ControllerCollection $c) {}
        /**
         * Default route binder for asynchronous requests.
         *
         * @return \Symfony\Component\HttpFoundation\JsonResponse
         */
        public function async() {}
/** @var Repository\LogChangeRepository $repo */
        public function changeLogRecord(/** @var Repository\LogChangeRepository $repo */
$contenttype, /** @var Repository\LogChangeRepository $repo */
$contentid) {}
        public function dashboardNews(Request $request) {}
        public function lastModified($contenttypeslug, $contentid = null) {}
        /**
         * Get the 'latest activity' for the dashboard.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function latestActivity() {}
        public function makeUri(Request $request) {}
        public function omnisearch(Request $request) {}
        public function popularTags(Request $request, $taxonomytype) {}
        public function readme(ExtensionInterface $extension) {}
        public function tags($taxonomytype) {}
        private function getNews($hostname) {}
        private function fetchNews($hostname) {}
        private function fetchNewsOptions($hostname) {}
/** @var Repository\LogChangeRepository $repo */
        private function getLastmodifiedByContentLog(/** @var Repository\LogChangeRepository $repo */
$contenttypeslug, /** @var Repository\LogChangeRepository $repo */
$contentid) {}
        private function getLastmodifiedSimple($contenttypeslug) {}
    }

    /**
     * Async controller for widget async routes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Widget extends \bolt\controller\async\asyncbase {
        protected function addRoutes(ControllerCollection $c) {}
        public function before(Request $request) {}
        public function widget(Request $request, $key) {}
    }

    /**
     * Async controller for system testing async routes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SystemChecks extends \bolt\controller\async\asyncbase {
        protected function addRoutes(ControllerCollection $c) {}
        public function directoriesCheck(Request $request) {}
        public function emailCheck(Request $request) {}
        public function extensionsCheck(Request $request) {}
        protected function getCheck($check) {}
    }

}

namespace Bolt\Controller\Backend {
    /**
     * Backend controller for authentication routes.
     *
     * @author Carson Full <carsonfull@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Authentication extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
/** @var Form $form */
        public function getLogin(/** @var Form $form */
Request $request) {}
        public function postLogin(Request $request) {}
/** @var Token $sessionAuth */
        public function logout(/** @var Token $sessionAuth */
Request $request) {}
        public function resetPassword(Request $request) {}
        private function handlePostLogin(Request $request, FormInterface $form) {}
        private function handlePostReset(Request $request, FormInterface $form) {}
    }

    /**
     * Backend controller for record manipulation routes.
     *
     * Prior to v3.0 this functionality primarily existed in the monolithic
     * Bolt\Controllers\Backend class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Records extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
/** @var Form $form */
        public function edit(/** @var Form $form */
Request $request, /** @var Form $form */
$contenttypeslug, /** @var Form $form */
$id) {}
        private function getReturnTo(Request $request, Button $button) {}
        public function overview(Request $request, $contenttypeslug) {}
        private function checkEditAccess($contenttypeslug, $id) {}
        private function getEditReferrer(Request $request) {}
        /**
         * @return \Bolt\Storage\ContentRequest\Edit
         */
        protected function recordEdit() {}
        /**
         * @return \Bolt\Storage\ContentRequest\Listing
         */
        protected function recordListing() {}
        /**
         * @return \Bolt\Storage\ContentRequest\Save
         */
        protected function recordSave() {}
    }

    /**
     * Backend controller for database manipulation routes.
     *
     * Prior to v3.0 this functionality primarily existed in the monolithic
     * Bolt\Controllers\Backend class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Database extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
/** @var $response \Bolt\Storage\Database\Schema\SchemaCheck */
        public function check(/** @var $response \Bolt\Storage\Database\Schema\SchemaCheck */
Request $request) {}
        public function update(Request $request) {}
        /**
         * Show the result of database updates.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function updateResult() {}
        /**
         * @return \Bolt\Storage\Database\Schema\Manager
         */
        protected function schemaManager() {}
    }

    class Extend extends \bolt\controller\backend\backendbase {
        public $readWriteMode;

        protected function addRoutes(ControllerCollection $c) {}
        public function before(Request $request, Application $app, $roleRoute = null) {}
        public function boot(Application $app) {}
        /**
         * Check a package.
         *
         * @return \Symfony\Component\HttpFoundation\JsonResponse
         */
        public function check() {}
        public function dependsPackage(Request $request) {}
        /**
         * Dumps the autoloader.
         *
         * @throws PackageManagerException
         *
         * @return Response
         */
        public function dumpAutoload() {}
        public function generateTheme(Request $request) {}
        public function install(Request $request) {}
        /**
         * Install all packages that are in the composer.json but not in vendor.
         *
         * Equivalent to `composer install`
         *
         * @throws PackageManagerException
         *
         * @return \Symfony\Component\HttpFoundation\Response
         */
        public function installAll() {}
        /**
         * Get a list of all installed packages.
         *
         * Partially equivalent to `composer show -i`
         *
         * @return \Symfony\Component\HttpFoundation\JsonResponse
         */
        public function installed() {}
        public function installInfo(Request $request) {}
        /**
         * Package install chooser modal.
         *
         * @return \Bolt\Response\TemplateResponse|\Symfony\Component\HttpFoundation\JsonResponse
         */
        public function installPackage() {}
        /**
         * The main 'Extensions' page.
         *
         * @return \Bolt\Response\TemplateResponse|\Symfony\Component\HttpFoundation\JsonResponse
         */
        public function overview() {}
/** @var PackageInterface $package */
        public function packageInfo(/** @var PackageInterface $package */
Request $request) {}
        public function prohibitsPackage(Request $request) {}
        public function update(Request $request) {}
        public function uninstall(Request $request) {}
        /**
         * Get render parameters for Twig.
         *
         * @return array
         */
        private function getRenderContext() {}
        /**
         * @return \Bolt\Composer\PackageManager
         */
        protected function manager() {}
        private function getJsonException(\Exception $e) {}
    }

    /**
     * Base class for all backend controllers.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class BackendBase extends \bolt\controller\base {
        public function connect(Application $app) {}
        protected function render($template, array $context = [ ], array $globals = [ ]) {}
        public function before(Request $request, Application $app, $roleRoute = null) {}
        protected function getContent($textQuery, $parameters = [ ], $pager = [ ], $whereParameters = [ ]) {}
        private function getRoutePermission($route) {}
        protected function setAuthenticationCookie(Request $request, Response $response, $token) {}
        /**
         * Returns the Login object.
         *
         * @return \Bolt\AccessControl\Login
         */
        protected function login() {}
        /**
         * Returns the Password object.
         *
         * @return \Bolt\AccessControl\Password
         */
        protected function password() {}
/** @var UsersRepository $repo */
        private function checkFirstUser(/** @var UsersRepository $repo */
Application $app, /** @var UsersRepository $repo */
$route) {}
    }

    /**
     * Backend controller for user maintenance routes.
     *
     * Prior to v3.0 this functionality primarily existed in the monolithic
     * Bolt\Controllers\Backend class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Users extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
        /**
         * All users admin page.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function admin() {}
/** @var \Bolt\Form\FormType\UserData $data */
        public function edit(/** @var \Bolt\Form\FormType\UserData $data */
Request $request, /** @var \Bolt\Form\FormType\UserData $data */
$id) {}
/** @var RequirementCollection $requirements */
        public function first(/** @var RequirementCollection $requirements */
Request $request) {}
        public function modify($action, $id) {}
/** @var \Bolt\Form\FormType\UserData $data */
        public function profile(/** @var \Bolt\Form\FormType\UserData $data */
Request $request) {}
        /**
         * Route to view the configured user roles.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function viewRoles() {}
        private function getUserEntity($id = null) {}
/** @var Message $message */
        private function notifyUserSetupEmail(/** @var Message $message */
Request $request, /** @var Message $message */
$displayName, /** @var Message $message */
$email) {}
    }

    /**
     * Class to handle file uploads.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     **/
    class Upload extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
        public function before(Request $request, Application $app, $roleRoute = null) {}
        public function uploadNamespace(Request $request, $namespace) {}
        private function parser($handler) {}
/** @var \Sirius\Upload\Result\Collection $result */
        private function handleUploadFiles(/** @var \Sirius\Upload\Result\Collection $result */
Request $request, /** @var \Sirius\Upload\Result\Collection $result */
$namespace, /** @var \Sirius\Upload\Result\Collection $result */
$files = null) {}
        private function getFilesToProcess(Request $request, $namespace, $files = null) {}
        private function processCustomUploadHandler(Request $request, array $handler) {}
    }

    /**
     * Backend controller for file/directory management routes.
     *
     * Prior to v3.0 this functionality primarily existed in the monolithic
     * Bolt\Controllers\Backend class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FileManager extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
/** @var Form $form */
        public function edit(/** @var Form $form */
Request $request, /** @var Form $form */
$namespace, /** @var Form $form */
$file) {}
        public function manage(Request $request, $namespace, $path) {}
        private function handleEdit(FormInterface $form, FileInterface $file) {}
/** @var UploadedFile[] $files */
        private function handleUpload(/** @var UploadedFile[] $files */
FormInterface $form, /** @var UploadedFile[] $files */
DirectoryInterface $directory) {}
        private function processUpload(DirectoryInterface $directory, $filename, array $fileToProcess) {}
        private function getRelatedFiles(FileInterface $file) {}
        private function getCodeMirrorPlugins(FileInterface $file) {}
    }

    /**
     * Backend controller for logging routes.
     *
     * Prior to v3.0 this functionality primarily existed in the monolithic
     * Bolt\Controllers\Backend class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Log extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
        public function changeOverview(Request $request) {}
        public function changeRecord(Request $request, $contenttype, $contentid, $id) {}
        public function changeRecordListing(Request $request, $contenttype, $contentid) {}
        public function systemOverview(Request $request) {}
        /**
         * @return \Bolt\Logger\Manager
         */
        protected function manager() {}
        /**
         * @return Repository\LogChangeRepository|Repository
         */
        protected function changeLogRepository() {}
        /**
         * @return Repository\LogSystemRepository|Repository
         */
        protected function systemLogRepository() {}
        private function getPagination($page) {}
        private function getQueryOptions($pagination) {}
    }

    /**
     * General controller for basic backend routes.
     *
     * Prior to v3.0 this functionality primarily existed in the monolithic
     * Bolt\Controllers\Backend class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class General extends \bolt\controller\backend\backendbase {
        protected function addRoutes(ControllerCollection $c) {}
        /**
         * About page route.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function about() {}
/** @var RequirementCollection $baseReqs */
        public function checks(/** @var RequirementCollection $baseReqs */
Request $request) {}
        /**
         * Clear the cache.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function clearCache() {}
        /**
         * Dashboard or 'root' route.
         *
         * @return \Bolt\Response\TemplateResponse
         */
        public function dashboard() {}
        public function omnisearch(Request $request) {}
        public function prefill(Request $request) {}
        public function translation(Request $request, $domain, $tr_locale) {}
        private function getLatest($limit = null) {}
        private function getTranslationData(MutableBag $tr) {}
        private function saveTranslationFile($contents, MutableBag $tr) {}
    }

}

namespace Bolt\Menu {
    /**
     * Menu class.
     */
    class Menu {
        /** @var string */
        private $name;
        /** @var array */
        private $menu;
        /** @var bool */
        private $resolved;

        public function __construct($name, array $menu, $resolved = false) {}
        /**
         * The name of the menu.
         *
         * @return string
         */
        public function getName() {}
        /**
         * The item that the menu contains.
         *
         * @return array
         */
        public function getItems() {}
        /**
         * Has this menu had it's paths resolved to links.
         *
         * @return bool
         */
        public function isResolved() {}
    }

    class MenuBuilder {
        /** @var Application */
        private $app;

        public function __construct(Application $app) {}
        public function menu($identifier = null, $resolved = true) {}
        public function resolve(array $menu) {}
        private function menuBuilder(array $menu) {}
        private function menuHelper($item) {}
        private function resolveRouteToLink(array $item) {}
        private function resolvePathToContent(array $item) {}
/** @var \Bolt\Legacy\Content $content */
        private function populateItemFromRecord(/** @var \Bolt\Legacy\Content $content */
array $item, /** @var \Bolt\Legacy\Content $content */
$path) {}
    }

    /**
     * A menu entry item.
     *
     * @internal Do not extend. Backwards compatibility not guaranteed on this class presently.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class MenuEntry implements \serializable {
        /** @var MenuEntry|null */
        protected $parent;
        /** @var MenuEntry[] */
        protected $children;
        /** @var string */
        protected $name;
        /** @var string */
        protected $label;
        /** @var string */
        protected $icon;
        /** @var string */
        protected $permission;
        /** @var bool */
        protected $group;
        /** @var string */
        protected $uri;
        /** @var string */
        protected $routeName;
        /** @var array */
        protected $routeParams;
        /** @var string */
        protected $routeGenerated;
        /** @var UrlGeneratorInterface */
        protected $urlGenerator;

        public static function createRoot(UrlGeneratorInterface $urlGenerator, $basePath) {}
        public function __construct($name, $uri = null) {}
        public static function create($name, $uri = null) {}
        public function setRoute($routeName, $routeParams = [ ]) {}
        /**
         * Return the menu entry's internal name.
         *
         * @return string
         */
        public function getName() {}
        /**
         * Return the menu entry's URI relative to Bolt admin's.
         *
         * @return string
         */
        public function getUri() {}
        /**
         * Return the menu entry's label.
         *
         * @return string
         */
        public function getLabel() {}
        public function setLabel($label) {}
        /**
         * Return the menu entry's icon.
         *
         * @return string
         */
        public function getIcon() {}
        public function setIcon($icon) {}
        /**
         * Return the menu entry's required view permission.
         *
         * @return string
         */
        public function getPermission() {}
        public function setPermission($permission) {}
        /**
         * Check if menu entry is a group.
         *
         * @return bool
         */
        public function isGroup() {}
        public function setGroup($group) {}
        public function add(MenuEntry $menu) {}
        public function get($name) {}
        public function has($name) {}
        public function remove($name) {}
        /**
         * Return the menu entry's parent.
         *
         * @return MenuEntry
         */
        public function parent() {}
        /**
         * Return the menu entry's children.
         *
         * @return MenuEntry[]
         */
        public function children() {}
        /**
         * {@inheritdoc}
         */
        public function serialize() {}
        public function unserialize($serialized) {}
    }

}

namespace Bolt\Menu\Builder {
    /**
     * Bolt admin (back-end) area menu builder.
     *
     * @internal backwards compatibility not guaranteed on this class presently
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class AdminMenu {
        public function build(MenuEntry $root) {}
        private function addConfiguration(MenuEntry $root) {}
        private function addFileManagement(MenuEntry $root) {}
        private function addExtend(MenuEntry $root) {}
    }

    /**
     * Bolt admin (back-end) content menu builder.
     *
     * @internal backwards compatibility not guaranteed on this class presently
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class AdminContent {
        /** @var Bag */
        private $contentTypes;

        public function __construct(Bag $contentTypes) {}
        public function build(MenuEntry $root) {}
        private function addContentType(MenuEntry $contentRoot, $contentTypeKey, Bag $contentType) {}
        private function addGroupedMenu(MenuEntry $contentRoot, Bag $contentType) {}
        private function fillGroupedMenus(MenuEntry $contentRoot) {}
/** @var Bag $contentType */
        private function addGroupedContentTypes(/** @var Bag $contentType */
MenuEntry $groupEntry, /** @var Bag $contentType */
array $contentTypes) {}
    }

}

namespace Bolt\Menu\Resolver {
    /**
     * Menu access permission resolver.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class Access {
        /** @var Permissions */
        private $permissions;

        public function __construct(Permissions $permissions) {}
        public function resolve(MenuEntry $menu, Entity\Users $user) {}
        private function doResolve(MenuEntry $parent, MenuEntry $child, Entity\Users $user) {}
    }

    /**
     * Recently edited record resolver.
     *
     * @internal backwards compatibility not guaranteed on this class presently
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class RecentlyEdited {
        /** @var EntityManager */
        private $em;
        /** @var Parsedown */
        private $markdown;

        public function __construct(EntityManager $em, Parsedown $markdown) {}
        public function resolve(MenuEntry $menu, Bag $contentTypes) {}
        private function resolveGroupMenu(MenuEntry $groupMenu, Bag $contentTypes) {}
        private function addRecentlyEdited(MenuEntry $contentMenu, $contentTypeKey, Bag $contentTypes) {}
        private function addSingleton(MenuEntry $contentMenu, $contentTypeKey) {}
        private function getRecords($contentTypeKey, $limit) {}
    }

}

namespace Bolt\Request {
    /**
     * Profiler request aware trait.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    trait ProfilerAwareTrait {
        protected function isProfilerRequest(Request $request) {}
    }

}

namespace Bolt\Profiler {
    /**
     * BoltDataCollector.
     */
    class BoltDataCollector extends \symfony\component\httpkernel\datacollector\datacollector {
        protected $app;

        public function __construct(Application $app) {}
        public function getName() {}
        public function collect(Request $request, Response $response, \Exception $exception = null) {}
        /**
         * Getter for version.
         *
         * @return string
         */
        public function getVersion() {}
        /**
         * Getter for branding.
         *
         * @return string
         */
        public function getBranding() {}
        /**
         * Getter for payoff.
         *
         * @return string
         */
        public function getPayoff() {}
        /**
         * Getter for dashboardlink.
         *
         * @return string
         */
        public function getDashboardlink() {}
        /**
         * Getter for editlink.
         *
         * @return string
         */
        public function getEditlink() {}
        /**
         * Getter for edittitle.
         *
         * @return string
         */
        public function getEdittitle() {}
    }

    /**
     * Enables debug toolbar if applicable.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class DebugToolbarEnabler implements \symfony\component\eventdispatcher\eventsubscriberinterface, \silex\serviceproviderinterface {
        /** @var WebDebugToolbarListener */
        protected $listener;
        /** @var EventDispatcherInterface */
        protected $dispatcher;
        /** @var bool */
        protected $debugLoggedOff;

        public function onRequest(GetResponseEvent $event) {}
        public function register(Application $app) {}
        public function boot(Application $app) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * DatabaseDataCollector.
     *
     * @author Christophe Coevoet <stof@notk.org>
     */
    class DatabaseDataCollector extends \symfony\component\httpkernel\datacollector\datacollector {
        private $logger;

        public function __construct(DebugStack $logger) {}
        public function getName() {}
        public function collect(Request $request, Response $response, \Exception $exception = null) {}
        public function getQueryCount() {}
        public function getQueries() {}
        public function getTime() {}
        private function trim(array $queries) {}
    }

}

namespace Bolt\Routing {
    /**
     * This is the root controller collection.
     *
     * When $app->flush() is called, the controller mount event is dispatched.
     *
     * This allows the controllers to be built up right before they are needed.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class RootControllerCollection extends \bolt\routing\controllercollection {
        /** @var Application */
        protected $app;
        /** @var EventDispatcherInterface */
        protected $dispatcher;

        public function __construct(Application $app, EventDispatcherInterface $dispatcher, Route $defaultRoute) {}
        public function flush($prefix = '') {}
    }

    /**
     * Wraps a UrlGenerator to allow urls to be generated with a fragment.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class UrlGeneratorFragmentWrapper implements \symfony\component\routing\generator\configurablerequirementsinterface, \symfony\component\routing\generator\urlgeneratorinterface {
        /** @var UrlGeneratorInterface */
        protected $wrapped;

        public function __construct(UrlGeneratorInterface $wrapped) {}
        public function generate($name, $parameters = [ ], $referenceType = UrlGeneratorInterface::ABSOLUTE_PATH) {}
        public function setContext(RequestContext $context) {}
        /**
         * {@inheritdoc}
         */
        public function getContext() {}
        public function setStrictRequirements($enabled) {}
        /**
         * {@inheritdoc}
         */
        public function isStrictRequirements() {}
    }

    /**
     * If Silex\RedirectableUrlMatcher does not match a route,
     * it checks for a route with a trailing slash and redirects to it.
     *
     * This additionally checks for a route without a trailing slash and redirects
     * to it.
     */
    class UrlMatcher extends \silex\redirectableurlmatcher {
        public function match($pathinfo) {}
    }

    /**
     * This class has two purposes.
     * - Provide a getter (and override setter) to get the canonical url for the current request.
     * - Update the RequestContext with the scheme/host override from the config.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Canonical implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var UrlGeneratorInterface */
        private $urlGenerator;
        /** @var UriInterface|null An optional scheme/host override. */
        private $globalOverride;
        /** @var bool */
        private $forceSsl;
        /** @var UriInterface|null An optional override for current request to use instead of the UrlGenerator */
        private $override;
        /** @var Request|null The current request. */
        private $request;

        public function __construct(UrlGeneratorInterface $urlGenerator, $forceSsl = false, $globalOverride = null) {}
        public function setUrlGenerator(UrlGeneratorInterface $urlGenerator) {}
        public function setGlobalOverride($uri) {}
        public function setOverride($uri) {}
        /**
         * Returns the canonical url for the current request,
         * or null if called outside of the request cycle.
         *
         * @return string|null
         */
        public function getUrl() {}
        public function onRequest(GetResponseEvent $event) {}
        public function onFinishRequest(FinishRequestEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
        private function setRequest(Request $request = null) {}
        /**
         * Sets the scheme and host overrides (if any) on the UrlGenerator's RequestContext.
         *
         * This needs to happen after RouterListener as that sets the scheme
         * and host from the request. To override we need to be after that.
         */
        private function applyGlobalOverride() {}
        /**
         * If there is a current override, resolve it to an absolute url based on current request.
         */
        private function resolveCurrentOverride() {}
    }

    /**
     * Implements a lazy UrlGenerator.
     * Similar concept with {@see \Silex\LazyUrlMatcher LazyUrlMatcher} and
     * {@see \Symfony\Component\HttpKernel\EventListener\RouterListener RouterListener}.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class LazyUrlGenerator implements \symfony\component\routing\generator\urlgeneratorinterface {
        /** @var callable $factory */
        private $factory;
        /** @var UrlGeneratorInterface $urlGenerator */
        private $urlGenerator;

        public function __construct(callable $factory) {}
        public function setContext(RequestContext $context) {}
        /**
         * @return UrlGeneratorInterface
         */
        public function getUrlGenerator() {}
        /**
         * {@inheritdoc}
         */
        public function getContext() {}
        public function generate($name, $parameters = [ ], $referenceType = self::ABSOLUTE_PATH) {}
    }

    /**
     * Resolves extensions being used as a controller.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ControllerResolver extends \silex\controllerresolver {
/** @var \Bolt\Extension\ResolvedExtension[] $extensions */
        protected function instantiateController(/** @var \Bolt\Extension\ResolvedExtension[] $extensions */
$class) {}
    }

    /**
     * When mounting a controller class with a prefix most times you have a route
     * with a blank path (ex: Backend::dashboard). That is the only route that
     * flushes to include an (unwanted) trailing slash.
     *
     * This fixes that trailing slash.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ControllerCollection extends \silex\controllercollection implements \bolt\routing\defaultcontrollerclassawareinterface {
        /** @var string|object $defaultControllerClass */
        protected $defaultControllerClass;

        public function setDefaultControllerClass($class) {}
        public function match($pattern, $to = null) {}
        public function flush($prefix = '') {}
    }

    /**
     * Handles resolving callbacks from routing.yml that specify a class name.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class CallbackResolver extends \silex\callbackresolver {
        /** @var \Pimple $app */
        protected $app;
        /**
         * @deprecated Deprecated since 3.3, to be removed in 4.0.
         *
         * @var array
         */
        protected $classmap;

        public function __construct(\Pimple $app, array $classmap) {}
/** @deprecated Deprecated since 3.3, to be removed in 4.0. */
        public function isValid(/** @deprecated Deprecated since 3.3, to be removed in 4.0. */
$name) {}
/** @deprecated Deprecated since 3.3, to be removed in 4.0. */
        public function convertCallback(/** @deprecated Deprecated since 3.3, to be removed in 4.0. */
$name) {}
        protected function instantiateClass($class) {}
    }


    /**
     * Interface for Bolt controller collection classes.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface DefaultControllerClassAwareInterface {
        function setDefaultControllerClass($class) ;
    }

}

namespace Bolt\Twig {
    /**
     * Twig setcontent node.
     *
     * @author Bob den Otter <bob@twokings.nl>
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class SetcontentNode extends \twig\node\node {
        /** @var bool */
        private $legacy;

        public function __construct($name, Node $contentType, ArrayExpression $arguments, array $whereArguments, $lineNo, $tag = null, $legacy = false) {}
        public function compile(Compiler $compiler) {}
        private function compileLegacy(Compiler $compiler, Node $arguments) {}
    }

    /**
     * Twig {{ setcontent }} token parser.
     *
     * @author Bob den Otter <bob@twokings.nl>
     */
    class SetcontentTokenParser extends \twig\tokenparser\abstracttokenparser {
        /**
         * @var bool
         *
         * @deprecated Deprecated since 3.4, to be remove in v4.
         */
        private $legacy;

        public function __construct($legacy = false) {}
        public function parse(Token $token) {}
        /**
         * {@inheritdoc}
         */
        public function getTag() {}
    }

    /**
     * Loads templates from a Bolt\Filesystem interface.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class FilesystemLoader extends \twig\loader\filesystemloader {
        /** @var FilesystemInterface */
        protected $filesystem;

        public function __construct(FilesystemInterface $filesystem, $paths = [ ]) {}
        public function addPath($path, $namespace = self::MAIN_NAMESPACE) {}
        public function prependPath($path, $namespace = self::MAIN_NAMESPACE) {}
        public function getSourceContext($name) {}
        public function addDir(DirectoryInterface $dir, $namespace = self::MAIN_NAMESPACE) {}
        public function prependDir(DirectoryInterface $dir, $namespace = self::MAIN_NAMESPACE) {}
        public function getSource($name) {}
        public function getCacheKey($name) {}
        public function isFresh($name, $time) {}
        protected function findTemplate($name, $throw = true) {}
    }

    /**
     * Represents a switch node.
     *
     * @author Dsls
     * @author maxgalbu
     *
     * @see https://gist.github.com/maxgalbu/9409182
     */
    class SwitchNode extends \twig\node\node {
        public function __construct(Node $value, Node $cases, Node $default = null, $lineNo = 0, $tag = null) {}
        public function compile(Compiler $compiler) {}
    }

    /**
     * This is a proxy for arrays and ArrayAccess objects that verifies access with a Twig Sandbox.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ArrayAccessSecurityProxy implements \arrayaccess, \countable, \iteratoraggregate, \bolt\twig\securityproxyinterface {
    use \bolt\debug\caster\transparentproxytrait;

        /** @var array|ArrayAccess */
        protected $object;
        /** @var SandboxExtension */
        protected $sandbox;
        /** @var string */
        protected $class;

        public function __construct($array, SandboxExtension $sandbox, $fakeClass = null, $transparent = true) {}
        /**
         * {@inheritdoc}
         */
        public function getProxiedClass() {}
        public function offsetExists($offset) {}
        public function offsetGet($offset) {}
        public function offsetSet($offset, $value) {}
        public function offsetUnset($offset) {}
        /**
         * {@inheritdoc}
         */
        public function getIterator() {}
        /**
         * {@inheritdoc}
         */
        public function count() {}
        /**
         * @return array|ArrayAccess
         */
        protected function getProxiedObject() {}
    }

    /**
     * Security policy enforced in sandbox mode.
     *
     * @author Carson Full <carsonfull@gmail.com>
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class SecurityPolicy implements \twig\sandbox\securitypolicyinterface {
        /** @var array */
        private $allowedTags;
        /** @var array */
        private $allowedFilters;
        /** @var array */
        private $allowedMethods;
        /** @var array */
        private $allowedProperties;
        /** @var array */
        private $allowedFunctions;

        public function __construct(array $allowedTags = [ ], array $allowedFilters = [ ], array $allowedMethods = [ ], array $allowedProperties = [ ], array $allowedFunctions = [ ]) {}
        public function addAllowedTag($tag) {}
        public function setAllowedTags(array $tags) {}
        public function addAllowedFilter($filter) {}
        public function setAllowedFilters(array $filters) {}
        public function addAllowedFunction($function) {}
        public function setAllowedFunctions(array $functions) {}
        public function addAllowedMethod($class, $method) {}
        public function setAllowedMethods(array $methods) {}
        public function addAllowedProperty($class, $property) {}
        public function setAllowedProperties(array $properties) {}
        public function checkSecurity($tags, $filters, $functions) {}
        public function checkMethodAllowed($obj, $method) {}
        public function checkPropertyAllowed($obj, $property) {}
        protected function matchAnyClassInTree($class, $objClass) {}
        protected function getAllClasses($class) {}
        protected function globMatchAll($patterns, $string, $ignoreCase = true) {}
        protected function globMatch($pattern, $string, $ignoreCase = true) {}
    }

    /**
     * Wraps real Twig environment:
     * - render() and display() are called with sandbox enabled.
     * - Adding an extension here adds the tags/functions/filters in extension to the security policy whitelist.
     *
     * @deprecated since 3.3, will be removed in 4.0.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class SafeEnvironment extends \bolt\twig\twigenvironmentwrapper {
        protected $sandbox;

        public function __construct(Environment $env, SandboxExtension $sandbox) {}
        public function render($name, array $context = [ ]) {}
        public function display($name, array $context = [ ]) {}
        public function addExtension(ExtensionInterface $extension) {}
    }

    /**
     * Base class for wrapping twig environment.
     *
     * @deprecated since 3.3, will be removed in 4.0.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class TwigEnvironmentWrapper extends \twig\environment {
        protected $env;

        public function __construct(Environment $env) {}
        /**
         * {@inheritdoc}
         */
        public function getBaseTemplateClass() {}
        public function setBaseTemplateClass($class) {}
        /**
         * {@inheritdoc}
         */
        public function enableDebug() {}
        /**
         * {@inheritdoc}
         */
        public function disableDebug() {}
        /**
         * {@inheritdoc}
         */
        public function isDebug() {}
        /**
         * {@inheritdoc}
         */
        public function enableAutoReload() {}
        /**
         * {@inheritdoc}
         */
        public function disableAutoReload() {}
        /**
         * {@inheritdoc}
         */
        public function isAutoReload() {}
        /**
         * {@inheritdoc}
         */
        public function enableStrictVariables() {}
        /**
         * {@inheritdoc}
         */
        public function disableStrictVariables() {}
        /**
         * {@inheritdoc}
         */
        public function isStrictVariables() {}
        public function getCache($original = true) {}
        public function setCache($cache) {}
        public function getCacheFilename($name) {}
        public function getTemplateClass($name, $index = null) {}
        /**
         * {@inheritdoc}
         */
        public function getTemplateClassPrefix() {}
        public function render($name, array $context = [ ]) {}
        public function display($name, array $context = [ ]) {}
        public function load($name) {}
        public function loadTemplate($name, $index = null) {}
        public function createTemplate($template) {}
        public function isTemplateFresh($name, $time) {}
        public function resolveTemplate($names) {}
        /**
         * {@inheritdoc}
         */
        public function clearTemplateCache() {}
        /**
         * {@inheritdoc}
         */
        public function clearCacheFiles() {}
        /**
         * {@inheritdoc}
         */
        public function getLexer() {}
        public function setLexer(LexerInterface $lexer) {}
        public function tokenize($source, $name = null) {}
        /**
         * {@inheritdoc}
         */
        public function getParser() {}
        public function setParser(ParserInterface $parser) {}
        public function parse(TokenStream $stream) {}
        /**
         * {@inheritdoc}
         */
        public function getCompiler() {}
        public function setCompiler(CompilerInterface $compiler) {}
        public function compile(NodeInterface $node) {}
        public function compileSource($source, $name = null) {}
        public function setLoader(LoaderInterface $loader) {}
        /**
         * {@inheritdoc}
         */
        public function getLoader() {}
        public function setCharset($charset) {}
        /**
         * {@inheritdoc}
         */
        public function getCharset() {}
        /**
         * {@inheritdoc}
         */
        public function initRuntime() {}
        public function hasExtension($class) {}
        public function addRuntimeLoader(RuntimeLoaderInterface $loader) {}
        public function getExtension($class) {}
        public function getRuntime($class) {}
        public function addExtension(ExtensionInterface $extension) {}
        public function removeExtension($name) {}
        public function setExtensions(array $extensions) {}
        /**
         * {@inheritdoc}
         */
        public function getExtensions() {}
        public function addTokenParser(TokenParserInterface $parser) {}
        /**
         * {@inheritdoc}
         */
        public function getTokenParsers() {}
        /**
         * {@inheritdoc}
         */
        public function getTags() {}
        public function addNodeVisitor(NodeVisitorInterface $visitor) {}
        /**
         * {@inheritdoc}
         */
        public function getNodeVisitors() {}
        public function addFilter($name, $filter = null) {}
        public function getFilter($name) {}
        public function registerUndefinedFilterCallback($callable) {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
        public function addTest($name, $test = null) {}
        /**
         * {@inheritdoc}
         */
        public function getTests() {}
        public function getTest($name) {}
        public function addFunction($name, $function = null) {}
        public function getFunction($name) {}
        public function registerUndefinedFunctionCallback($callable) {}
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        public function addGlobal($name, $value) {}
        /**
         * {@inheritdoc}
         */
        public function getGlobals() {}
        public function mergeGlobals(array $context) {}
        /**
         * {@inheritdoc}
         */
        public function getUnaryOperators() {}
        /**
         * {@inheritdoc}
         */
        public function getBinaryOperators() {}
        public function computeAlternatives($name, $items) {}
    }

    /**
     * Adapted from code originally in Twig/extensions.
     *
     * Usage:
     *
     * {% set foo = 1 %}
     * {% switch foo %}
     *     {% case 1 %}
     *         Foo was equal to the number one.
     *     {% case 2 %}
     *         Foo was two.
     *     {% default %}
     *         This is the default fallback.
     * {% endswitch %}
     *
     *
     * @see: https://gist.github.com/maxgalbu/9409182
     */
    class SwitchTokenParser extends \twig\tokenparser\abstracttokenparser {
/** @var Token $v */
        public function parse(/** @var Token $v */
Token $token) {}
        public function decideIfFork(Token $token) {}
        public function decideIfEnd(Token $token) {}
        /**
         * Gets the tag name associated with this token parser.
         *
         * @return string The tag name
         */
        public function getTag() {}
    }

    /**
     * Twig RuntimeLoader implementation.
     *
     * @internal based on the similar class from Silex 2 and will probably be
     * replaced when Bolt v4 switches to Silex 2
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class RuntimeLoader implements \twig\runtimeloader\runtimeloaderinterface {
        /** @var Container */
        private $container;
        /** @var array */
        private $mapping;

        public function __construct(Container $container, array $mapping) {}
        public function load($class) {}
    }


    /**
     * {@see SecurityPolicy} will check for this interface to get the class name
     * of the object to verify (instead of {@see get_class} by default).
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface SecurityProxyInterface {
        /**
         * Gets the proxied class name.
         *
         * @return string
         */
        function getProxiedClass() ;
    }

}

namespace Bolt\Twig\Extension {
    /**
     * Admin (back-end) functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class AdminExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
        /**
         * {@inheritdoc}
         */
        public function getTests() {}
    }

    /**
     * Modified version of Twig Bridge's DumpExtension to use runtime loading.
     * Also, backtrace function.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class DumpExtension extends \twig\extension\abstractextension {
        public function getFunctions() {}
        public function getTokenParsers() {}
        public function getName() {}
    }

    /**
     * Bolt specific Twig functions and filters that provide array manipulation.
     *
     * @internal
     */
    class ArrayExtension extends \twig\extension\abstractextension {
        private $orderOn;
        private $orderAscending;
        private $orderOnSecondary;
        private $orderAscendingSecondary;

        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
        public function order(array $array, $on, $onSecondary = null) {}
        private function getSortOrder($name = '-datepublish') {}
        private function orderHelper($a, $b) {}
        public function shuffle($array) {}
        public function unique(array $arr1, array $arr2) {}
    }

    /**
     * Content record functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class RecordExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
    }

    /**
     * HTML functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class HtmlExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
    }

    /**
     * Bolt base Twig functionality and definitions.
     */
    class BoltExtension extends \twig\extension\abstractextension implements \twig\extension\globalsinterface {
        /** @var EntityManagerInterface */
        private $em;
        /** @var Config */
        private $config;
        /** @var PathsProxy */
        private $paths;

        public function __construct(EntityManagerInterface $em, Config $config, PathsProxy $paths) {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
        /**
         * Used by setcontent tag.
         *
         * @return EntityManagerInterface
         */
        public function getStorage() {}
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
        /**
         * {@inheritdoc}
         *
         * As of Twig 2.x, the ability to register a global variable after runtime
         * or the extensions have been initialized will not be possible any longer,
         * but changing the value of an already registered global is possible.
         */
        public function getGlobals() {}
        /**
         * {@inheritdoc}
         */
        public function getTokenParsers() {}
    }

    /**
     * General-purpose utility functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UtilsExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
    }

    /**
     * Text functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class TextExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
        /**
         * {@inheritdoc}
         */
        public function getTests() {}
    }

    /**
     * Routing functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class RoutingExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
    }

    /**
     * Widget functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class WidgetExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
    }

    /**
     * User functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class UserExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
        /**
         * {@inheritdoc}
         */
        public function getTests() {}
    }

    /**
     * Image functionality Twig extension.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ImageExtension extends \twig\extension\abstractextension {
        /**
         * {@inheritdoc}
         */
        public function getFunctions() {}
        /**
         * {@inheritdoc}
         */
        public function getFilters() {}
    }

}

namespace Bolt\Twig\Runtime {
    /**
     * Bolt specific Twig functions and filters that provide routing functionality.
     *
     * @internal
     */
    class RoutingRuntime {
        /** @var Canonical */
        private $canonical;
        /** @var RequestStack */
        private $requestStack;
        /** @var string */
        private $locale;

        public function __construct(Canonical $canonical, RequestStack $requestStack, $locale) {}
        /**
         * Get canonical url for current request.
         *
         * @return string|null
         */
        public function canonical() {}
        /**
         * Returns the language value for in tags where the language attribute is
         * required. The underscore '_' in the locale will be replaced with a
         * hyphen '-'.
         *
         * @return string
         */
        public function htmlLang() {}
        /**
         * Check if the page is viewed on a mobile device.
         *
         * @return bool
         */
        public function isMobileClient() {}
        public function redirect($path) {}
        public function request($parameter, $from = '', $stripSlashes = false) {}
    }

    /**
     * Twig Bridge's DumpExtension's runtime logic with custom enabled check.
     * Also, backtrace function.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class DumpRuntime {
        /** @var ClonerInterface */
        private $cloner;
        /** @var HtmlDumper */
        private $dumper;
        /** @var Users */
        private $users;
        /** @var bool */
        private $debugShowLoggedoff;

        public function __construct(ClonerInterface $cloner, HtmlDumper $dumper, Users $users, $debugShowLoggedoff) {}
        public function dump(Environment $env, $context) {}
        public function dumpBacktrace(Environment $env, $context, $depth) {}
        protected function isEnabled(Environment $env) {}
    }

    /**
     * Bolt extension runtime for Twig.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class BoltRuntime {
        /** @var Query */
        private $queryEngine;

        public function __construct(Query $queryEngine) {}
        /**
         * @return Query
         */
        public function getQueryEngine() {}
    }

    /**
     * Bolt specific Twig functions and filters that provide generic utility.
     *
     * @internal
     */
    class UtilsRuntime {
        /** @var LoggerInterface */
        private $firebugLogger;
        /** @var bool */
        private $debug;
        /** @var bool */
        private $isUser;
        /** @var bool */
        private $showAlways;

        public function __construct(LoggerInterface $firebugLogger, $debug, $isUser, $showAlways) {}
        public function fileExists($filename) {}
        public function printFirebug($var, $msg) {}
        /**
         * Helper function to determine if we're supposed to allow `backtrace`
         * and `firebug`. If `$this->app['debug']` is false, we don't allow it.
         * Otherwise we show only to _logged on_ users, _or_ non-authenticated
         * users, but then `debug_show_loggedoff` needs to be set.
         *
         * @return bool
         */
        private function allowDebug() {}
    }

    /**
     * Bolt specific Twig functions and filters for backend.
     *
     * @internal
     */
    class AdminRuntime {
        /** @var Config */
        private $config;
        /** @var Stack */
        private $stack;
        /** @var UrlGeneratorInterface */
        private $urlGenerator;
        /** @var \Silex\Application */
        private $app;
        /** @var int Holds the last used Bolt unique ID. */
        private $buid;

        public function __construct(Config $config, Stack $stack, UrlGeneratorInterface $urlGenerator, Silex\Application $app) {}
        public function addData($path, $value) {}
        public function isChangelogEnabled() {}
        public function testStackable($filename) {}
        public function stack($types = [ ]) {}
        public function logLevel($level) {}
        /**
         * Translate using our __().
         *
         * @internal
         * @internal param array $args
         * @internal param int   $numArgs
         *
         * @return string Translated content
         */
        public function trans() {}
        /**
         * Returns a random quote. Just for fun.
         *
         * @return string
         */
        public function randomQuote() {}
        public function ymllink($str) {}
        public function hattr($attributes) {}
        public function hclass($classes, $raw = false) {}
        /**
         * Returns a unique ID.
         *
         * @return string UID
         */
        public function buid() {}
    }

    /**
     * Bolt specific Twig functions and filters for HTML.
     *
     * @internal
     */
    class HtmlRuntime {
        /** @var Config */
        private $config;
        /** @var \Parsedown */
        private $markdown;
        /** @var MenuBuilder */
        private $menu;
        /** @var EntityManager */
        private $em;

        public function __construct(Config $config, \Parsedown $markdown, MenuBuilder $menu, EntityManager $em) {}
        public function decorateTT($str) {}
        public function editable($html, Content $content, $field) {}
        public function markdown($content) {}
        public function link($location, $label = '[link]') {}
        public function menu(Environment $env, $identifier = '', $template = '_sub_menu.twig', $params = [ ]) {}
        public function shy($str) {}
        public function twig(Environment $env, $snippet, $context = [ ]) {}
    }

    /**
     * Bolt specific Twig functions and filters that provide image support.
     *
     * @internal
     */
    class ImageRuntime {
        /** @var Config */
        private $config;
        /** @var UrlGeneratorInterface */
        private $urlGenerator;
        /** @var Manager */
        private $filesystem;
        /** @var Matcher */
        private $filesystemMatcher;

        public function __construct(Config $config, UrlGeneratorInterface $urlGenerator, Manager $filesystem, Matcher $filesystemMatcher) {}
        public function image(Environment $env, $fileName = null, $width = null, $height = null, $crop = null) {}
        public function imageInfo($fileName) {}
        public function popup($fileName = null, $width = null, $height = null, $crop = null, $title = null) {}
        public function showImage($fileName = null, $width = null, $height = null, $crop = null) {}
        public function thumbnail($fileName = null, $width = null, $height = null, $crop = null) {}
        private function getThumbnail($fileName = null, $width = null, $height = null, $scale = null) {}
        private function getThumbnailUri(Thumbnail $thumb) {}
        private function getAliasedUri($fileName, $alias) {}
        private function isAlias($alias) {}
        private function normalizeFileName($fileName) {}
    }

    /**
     * Bolt specific Twig functions and filters that provide \Bolt\Legacy\Content manipulation.
     *
     * @internal
     */
    class RecordRuntime {
        /** @var RequestStack */
        private $requestStack;
        /** @var PagerManager */
        private $pagerManager;
        /** @var DirectoryInterface */
        private $templatesDir;
        /** @var array */
        private $themeTemplateSelect;
        /** @var bool */
        private $useTwigGlobals;

        public function __construct(RequestStack $requestStack, PagerManager $pagerManager, DirectoryInterface $templatesDir, array $themeTemplateSelect, $useTwigGlobals) {}
/** @var Request $request */
        public function current(/** @var Request $request */
$content) {}
        public function excerpt($content, $length = 200, $focus = null) {}
        public function getFirstImage($content) {}
        public function fields(Environment $env, $record = null, $common = true, $extended = false, $repeaters = true, $templateFields = true, $template = '_sub_fields.twig', $exclude = null, $skip_uses = true) {}
/** @var Finder|FileInterface[] $finder */
        public function listTemplates(/** @var Finder|FileInterface[] $finder */
$filter = null) {}
        public function pager(Environment $env, $pagerName = '', $surr = 4, $template = '_sub_pager.twig', $class = '') {}
        public function selectField($content, $fieldName, $startempty = false, $keyName = 'id', $contentType = null) {}
        public function taxonomy($candidate) {}
    }

    /**
     * Bolt specific Twig functions and filters that provide user functionality.
     *
     * @internal
     */
    class UserRuntime {
        /** @var Users */
        private $users;
        /** @var CsrfTokenManagerInterface */
        private $csrfTokenManager;

        public function __construct(Users $users, CsrfTokenManagerInterface $csrfTokenManager) {}
        public function getUser($who) {}
        public function getUserId($who) {}
        public function isAllowed($what, $content = null) {}
        /**
         * Get a simple Anti-CSRF-like token.
         *
         * @deprecated Deprecated since 3.0, to be removed in 4.0. Use Symfony forms instead.
         *
         * @return CsrfToken
         */
        public function token() {}
    }

    /**
     * Bolt specific Twig functions and filters that provide text manipulation.
     *
     * @internal
     */
    class TextRuntime {
        /** @var LoggerInterface */
        private $systemLogger;
        /** @var SlugifyInterface */
        private $slugify;

        public function __construct(LoggerInterface $systemLogger, SlugifyInterface $slugify) {}
        public function jsonDecode($string) {}
        public function localeDateTime($dateTime, $format = '%B %e, %Y %H:%M') {}
        public function pregReplace($str, $pattern, $replacement = '', $limit = -1) {}
        public function safeString($str, $strict = false, $extrachars = '') {}
        public function slug($str) {}
        public function testJson($string) {}
    }

    /**
     * Bolt specific Twig functions and filters for HTML.
     *
     * @internal
     */
    class WidgetRuntime {
        /** @var Queue */
        private $widgetQueue;

        public function __construct(Queue $widgetQueue) {}
        public function countWidgets(Environment $env, $location = null, $zone = Zone::FRONTEND) {}
        /**
         * Gets a list of the registered widgets.
         *
         * @return array
         */
        public function getWidgets() {}
        public function hasWidgets(Environment $env, $location = null, $zone = Zone::FRONTEND) {}
        public function widgets(Environment $env, $location = null, $zone = Zone::FRONTEND, $wrapper = 'widgetwrapper.twig') {}
    }

}

namespace Bolt\Events {
    /**
     * Event instance for Storage events.
     *
     * PRE_SAVE (preSave)
     * - Available:
     *   - Content object
     * - Notes:
     *   - Do not call saveContent()
     *
     * POST_SAVE (postSave)
     * - Available:
     *   - Content object
     *   - ID
     * - Notes:
     *   - Safe to call saveContent()
     *
     * PRE_DELETE (preDelete)
     * - Available:
     *   - Content object
     *   - ID
     * - Notes:
     *   - Do not call saveContent()
     *
     * POST_DELETE (postDelete)
     * - Available:
     *   - Content object
     *   - ID
     * - Notes:
     *   - Do not call saveContent()
     *   - Database record will no longer exist
     */
    class StorageEvent extends \symfony\component\eventdispatcher\genericevent {
        /** @var Legacy\Content|Entity\Content|array */
        protected $subject;

        public function __construct($subject = null, array $arguments = [ ]) {}
        /**
         * Return the record id.
         *
         * @return int
         */
        public function getId() {}
        /**
         * Return the record's ContentType name.
         *
         * @return string
         */
        public function getContentType() {}
        /**
         * Return the content object.
         *
         * @return \Bolt\Legacy\Content
         */
        public function getContent() {}
        /**
         * Is the record being created, updated or deleted.
         *
         * @return bool|null True  - Create
         *                   False - Update
         *                   Null  - Delete
         */
        public function isCreate() {}
    }

    /**
     * Event dispatched on Doctrine ConnectionException occurrence.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class FailedConnectionEvent extends \doctrine\dbal\event\connectioneventargs {
        /** @var \Doctrine\DBAL\DBALException */
        private $exception;

        public function __construct(Connection $connection, DBALException $exception) {}
        /**
         * Getter for the exception.
         *
         * @return \Doctrine\DBAL\DBALException
         */
        public function getException() {}
    }

    /**
     * AccessControl event class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class AccessControlEvent extends \symfony\component\eventdispatcher\event {
        /** @var string */
        private $clientIp;
        /** @var int */
        private $dateTime;
        /** @var string */
        private $uri;
        /** @var string */
        private $userName;
        /** @var int */
        private $reason;
        /** @var bool */
        private $dispatched;

        public function __construct(Request $request) {}
        /**
         * @internal
         *
         * @return AccessControlEvent
         */
        public function setDispatched() {}
        public function setReason($reason) {}
        /**
         * Return the failure reason code.
         *
         * @return int
         */
        public function getReason() {}
        /**
         * Return the IP address requesting the access.
         *
         * @return string
         */
        public function getClientIp() {}
        /**
         * Return the timestamp the request occurred.
         *
         * @return int
         */
        public function getDateTime() {}
        /**
         * Return the requested URI of the access event.
         *
         * @return string
         */
        public function getUri() {}
        /**
         * Return the given user name of the access event.
         *
         * @return string
         */
        public function getUserName() {}
        public function setUserName($userName) {}
    }

    /**
     * Event class for system compulsory cron jobs.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class CronEvent extends \symfony\component\eventdispatcher\event {
        /** @var \Silex\Application */
        private $app;
        /** @var \Symfony\Component\Console\Output\OutputInterface */
        public $output;

        public function __construct(Application $app, OutputInterface $output = null) {}
        public function doRunScheduledJobs(Event $event, $eventName) {}
        /**
         * Hourly jobs.
         */
        private function cronHourly() {}
        /**
         * Daily jobs.
         */
        private function cronDaily() {}
        /**
         * Weekly jobs.
         */
        private function cronWeekly() {}
        /**
         * Monthly jobs.
         */
        private function cronMonthly() {}
        /**
         * Yearly jobs.
         */
        private function cronYearly() {}
        private function notify($msg) {}
    }

    /**
     * Hydration event allow access to
     * pre and post hydration of entities.
     *
     * Before hydration, the subject will be an array of fetched data
     * After hydration, the subject will be the hydrated object
     *
     * @author Ross Riley <riley.ross@gmail.com>
     */
    class HydrationEvent extends \symfony\component\eventdispatcher\genericevent {}

    /**
     * Schema event.
     *
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SchemaEvent extends \symfony\component\eventdispatcher\event {
        /** @var array */
        protected $creates;
        /** @var array */
        protected $alters;

        public function __construct(array $creates, array $alters) {}
        /**
         * @return array
         */
        public function getCreates() {}
        /**
         * @return array
         */
        public function getAlters() {}
    }

    /**
     * Schema event constants.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SchemaEvents {
        const UPDATE = 'schema.update';

        private function __construct() {}
    }

    /**
     * Controllers should be mounted to this event,
     * which will then mount them to the application.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class MountEvent extends \symfony\component\eventdispatcher\event {
        /** @var Application */
        protected $app;
        /** @var ControllerCollection */
        protected $collection;

        public function __construct(Application $app, ControllerCollection $collection) {}
        /**
         * @return Application
         */
        public function getApp() {}
        public function mount($prefix, $controllers) {}
        protected function verifyCollection($collection) {}
    }

    /**
     * Definitions for all possible Cron Events.
     *
     * @codeCoverageIgnore
     */
    final class CronEvents {
        const CRON_HOURLY = 'cron.Hourly';
        const CRON_YEARLY = 'cron.Yearly';
        const CRON_MONTHLY = 'cron.Monthly';
        const CRON_WEEKLY = 'cron.Weekly';
        const CRON_DAILY = 'cron.Daily';

        private function __construct() {}
    }

    /**
     * AccessControl event constants.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class AccessControlEvents {
        const LOGOUT_SUCCESS = 'logout.success';
        const RESET_REQUEST = 'reset.request';
        const RESET_SUCCESS = 'reset.success';
        const RESET_FAILURE = 'reset.failure';
        const ACCESS_CHECK_REQUEST = 'access.check.request';
        const ACCESS_CHECK_SUCCESS = 'access.check.success';
        const ACCESS_CHECK_FAILURE = 'access.check.failure';
        const FAILURE_INVALID = 1;
        const LOGIN_SUCCESS = 'login.success';
        const LOGIN_FAILURE = 'login.failure';
        const FAILURE_PASSWORD = 2;
        const FAILURE_DISABLED = 4;
        const FAILURE_LOCKED = 8;
        const FAILURE_DENIED = 16;

        /**
         * Singleton constructor.
         */
        private function __construct() {}
    }

    /**
     * Definitions for all possible StorageEvents.
     *
     *  * @codeCoverageIgnore
     */
    final class StorageEvents {
        const PRE_HYDRATE = 'preHydrate';
        const POST_HYDRATE = 'postHydrate';
        const POST_DELETE = 'postDelete';
        const PRE_DELETE = 'preDelete';
        const POST_INSERT = 'postInsert';
        const PRE_INSERT = 'preInsert';
        const POST_SAVE = 'postSave';
        const PRE_SAVE = 'preSave';

        private function __construct() {}
    }

    final class ControllerEvents {
        const MOUNT = 'controller.mount';

        private function __construct() {}
    }

}

namespace Bolt\Exception {
    /**
     * Exceptions in Bolt\Storage.
     */
    class FieldConfigurationException extends \exception {}

    /**
     * Filesystem exceptions.
     *
     * @deprecated since 3.3, to be removed in 4.0.
     */
    class FilesystemException extends \exception {
        const FILE_NOT_REMOVEABLE = 4;
        const FILE_NOT_READABLE = 1;
        const FILE_NOT_WRITEABLE = 2;

        protected $code;

        public function __construct($message = null, $code = 0, \Exception $previous = null) {}
    }

    /**
     * Exceptions in Bolt\Storage\Query.
     */
    class QueryParseException extends \exception {}

    /**
     * Throws when an initialized pager object gonna be overwritten from html query parameters.
     *
     * @author Rix Beck <rix@neologik.hu>
     */
    class PagerOverrideException extends \exception {}

    /**
     * Exceptions thrown from embed resolvers.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class EmbedResolverException extends \runtimeexception {}

    class PathResolutionException extends \runtimeexception {}

    /**
     * Signals an error in the parser.
     */
    class PermissionParserException extends \exception {}

    class FileNotStackableException extends \exception implements \symfony\component\httpkernel\exception\httpexceptioninterface {
        /** @var FileInterface */
        private $unstackableFile;

        public function __construct(FileInterface $file, $message = '') {}
        /**
         * @return FileInterface
         */
        public function getUnstackableFile() {}
        /**
         * {@inheritdoc}
         */
        public function getStatusCode() {}
        /**
         * {@inheritdoc}
         */
        public function getHeaders() {}
    }

    /**
     * Access exceptions.
     */
    class AccessControlException extends \exception {}

    /**
     * Boot initialisation exception.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class BootException extends \runtimeexception {
        /** @var Response */
        protected $response;

        public function __construct($message, $code = 0, \Exception $previous = null, Response $response = null) {}
        /**
         * @return bool
         */
        public function hasResponse() {}
        /**
         * @return Response
         */
        public function getResponse() {}
        public function setResponse(Response $response) {}
        public static function earlyException($message) {}
        /**
         * Exception due to a missing vendor/autoload.php file.
         *
         * @return static
         */
        public static function earlyExceptionComposer() {}
        /**
         * Exception due to a PHP version being unsupported.
         */
        public static function earlyExceptionVersion() {}
        /**
         * Template for early exception HTML to be parsed by sprintf() prior to output.
         *
         * @return string
         */
        protected static function getEarlyExceptionHtml() {}
        /**
         * Footer hints for missing autoload.php exceptions.
         *
         * @return string
         */
        protected static function getHintsComposer() {}
    }

    /**
     * Signals an error in the lexer.
     */
    class PermissionLexerException extends \exception {}

    /**
     * @deprecated Deprecated since 3.2, to be removed in 4.0. @see \Bolt\Exception\BootException
     */
    class LowLevelDatabaseException extends \bolt\exception\lowlevelexception {
        public static function failedConnect($platform, \Exception $previous) {}
        public static function missingParameter($parameter) {}
        public static function missingDriver($name, $driver) {}
        public static function unsupportedDriver($driver) {}
        public static function unsecure() {}
        public static function unwritableFile($path) {}
        public static function unwritableFolder($path) {}
        public static function nonexistantFile($path) {}
        public static function nonexistantFolder($path) {}
        protected static function invalidPath($type, $path, $error) {}
    }

    /**
     * @deprecated Deprecated since 3.2, to be removed in 4.0. @see \Bolt\Exception\BootException
     */
    class LowlevelException extends \exception {
        static public $html;
        static public $info;
        static public $screen;

        public function __construct($message, $code = null, $previous = null) {}
        /**
         * Catch and display errors that occur before the Application object has
         * been instantiated.
         *
         * If the error occurs later in the application life cycle, we flush this
         * output in catchFatalErrors() which has access to the Application object.
         */
        public static function catchFatalErrorsEarly() {}
        public static function catchFatalErrors(Application $app, $flush = true) {}
        public static function nullHandler(\Exception $e) {}
        private static function cleanHTML($output) {}
    }

    class SatisQueryException extends \exception {}

    /**
     * Exceptions in Bolt\Storage.
     */
    class StorageException extends \exception {}

    class PackageManagerException extends \exception {
        protected $file;
        protected $line;

        public function __construct($message = null, $code = 0, \Exception $previous = null) {}
    }

    /**
     * Exceptions in Bolt\Storage.
     */
    class InvalidRepositoryException extends \exception {}

}

namespace Bolt\Exception\Database {
    class DatabaseException extends \exception implements \bolt\exception\database\databaseexceptioninterface {
    use \bolt\exception\database\databaseexceptiontrait;

        public function __construct($driver, $message = '', Exception $previous = null, $code = 0) {}
    }

    class DatabaseConnectionException extends \bolt\exception\database\databaseexception {}


    interface DatabaseExceptionInterface {
        /**
         * @return string
         */
        function getDriver() ;
        /**
         * Returns the driver's platform (human name).
         *
         * @return string
         */
        function getPlatform() ;
    }


    trait DatabaseExceptionTrait {
        /** @var string */
        protected $driver;
        static protected $driverNames;
        /**
         * @return string
         */
        public function getDriver() {}
        /**
         * Returns the driver's platform (human name).
         *
         * @return string
         */
        public function getPlatform() {}
    }

}

namespace Bolt\Exception\Configuration\Validation {
    class MissingExtensionException extends \bolt\exception\configuration\validation\validationexception {
        /** @var string */
        protected $extension;

        public function __construct($extension) {}
        /**
         * @return string
         */
        public function getExtension() {}
    }

    class ValidationException extends \exception {
        public function __construct($message = '', Exception $previous = null) {}
    }

}

namespace Bolt\Exception\Configuration\Validation\Database {
    class InsecureDatabaseException extends \bolt\exception\configuration\validation\database\abstractdatabasevalidationexception {
        public function __construct($driver) {}
    }

    class SqlitePathException extends \bolt\exception\configuration\validation\database\abstractdatabasevalidationexception {
        /** @var string */
        private $type;
        /** @var string */
        private $path;
        /** @var string */
        private $error;

        public static function folderMissing($path) {}
        public static function fileMissing($path) {}
        public static function fileNotWritable($path) {}
        public static function folderNotWritable($path) {}
        public function __construct($path, $type, $error) {}
        /**
         * @return string
         */
        public function getPath() {}
        /**
         * @return string
         */
        public function getType() {}
        /**
         * @return string
         */
        public function getError() {}
    }

    class UnsupportedDatabaseException extends \bolt\exception\configuration\validation\database\abstractdatabasevalidationexception {
        public function __construct($driver) {}
    }

    class MissingDatabaseExtensionException extends \bolt\exception\configuration\validation\missingextensionexception implements \bolt\exception\database\databaseexceptioninterface {
    use \bolt\exception\database\databaseexceptiontrait;

        /** @var string */
        protected $extension;

        public function __construct($driver) {}
    }

    class DatabaseParameterException extends \bolt\exception\configuration\validation\database\abstractdatabasevalidationexception {
        /** @var string */
        protected $parameter;

        public function __construct($parameter, $driver) {}
        /**
         * @return string
         */
        public function getParameter() {}
    }

    abstract class AbstractDatabaseValidationException extends \bolt\exception\configuration\validation\validationexception implements \bolt\exception\database\databaseexceptioninterface {
    use \bolt\exception\database\databaseexceptiontrait;

        protected $subType;

        public function __construct($subType, $driver, $message = '') {}
        /**
         * @return string
         */
        public function getSubType() {}
    }

}

namespace Bolt\Exception\Configuration\Validation\System {
    abstract class AbstractSystemValidationException extends \bolt\exception\configuration\validation\validationexception {
        /** @var string */
        protected $type;

        public function __construct($type, $message = '') {}
        /**
         * @return string
         */
        public function getType() {}
    }

    class ApacheValidationException extends \bolt\exception\configuration\validation\system\abstractsystemvalidationexception {
        /**
         * Constructor.
         */
        public function __construct() {}
    }

    class CacheValidationException extends \bolt\exception\configuration\validation\system\abstractsystemvalidationexception {
        /** @var string */
        protected $path;

        public function __construct($path) {}
        /**
         * @return string
         */
        public function getPath() {}
    }

}

namespace Bolt\Helpers {
    /**
     * Exception request sanitiser.
     *
     * @internal only to be used to sanitise Request objects for Twig exception renders
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class RequestSanitiser {
        public static function filter(Request $request) {}
        private static function getValues(array $values) {}
    }

    class Str extends \bolt\common\str {
        public static function makeSafe($str, $strict = false, $extrachars = '') {}
        public static function replaceFirst($search, $replace, $subject, $caseSensitive = true) {}
        public static function replaceLast($search, $replace, $subject, $caseSensitive = true) {}
        public static function shyphenate($str) {}
        public static function endsWith($subject, $search, $caseSensitive = true) {}
    }

    class Excerpt {
        /** @var Content|LegacyContent|array|string */
        protected $body;
        /** @var string */
        protected $title;

        public function __construct($body, $title = null) {}
        public function getExcerpt($length = 200, $includeTitle = false, $focus = null) {}
        public static function createFromEntity(Content $entity, Bag $contentType, $length, Parsedown $markdown) {}
        private function extractLocations(array $words, $fulltext) {}
        private function determineSnipLocation(array $locations, $prevCount) {}
        private function extractRelevant($words, $fulltext, $relLength = 300) {}
    }

    /**
     * @internal
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    final class ListMutator {
        /** @var MutableBag */
        private $available;
        /** @var MutableBag */
        private $mutable;

        public function __construct(array $available, array $mutable) {}
        public function __invoke(array $original, array $proposed) {}
    }

    class Html {
        public static function trimText($str, $desiredLength, $hellip = true, $cutOffCap = 10) {}
        public static function decorateTT($str) {}
        public static function isURL($str) {}
        public static function addScheme($url, $scheme = 'http://') {}
        public static function providerLink($providedby) {}
    }

    class Input {
        public static function cleanPostedData($var, $stripslashes = true, $stripControlChars = false) {}
    }

    /**
     * @deprecated since 3.3, to be removed in 4.0. Use {@see Bolt\Collection\Arr} instead.
     */
    class Arr extends \bolt\collection\arr {
        public static function makeValuePairs($array, $key, $value) {}
        public static function mergeRecursiveDistinct(array $array1, array $array2) {}
        public static function isIndexedArray(array $arr) {}
    }

    /**
     * This class provides shortcuts for trigger deprecation warnings for various things.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Deprecated extends \bolt\common\deprecated {
        public static function service($name, $since = null, $suggest = '') {}
    }

}

namespace Bolt\Helpers\Image {
    /**
     * Thumbnail helper class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class Thumbnail {
        /** @var string */
        protected $fileName;
        /** @var string */
        protected $title;
        /** @var string */
        protected $altTitle;
        /** @var int */
        protected $height;
        /** @var int */
        protected $width;
        /** @var string */
        protected $scale;
        /** @var array */
        protected $thumbConf;

        public function __construct(array $thumbConf) {}
        /**
         * Get the file name.
         *
         * @return string
         */
        public function getFileName() {}
        public function setFileName($fileName) {}
        /**
         * Get the title.
         *
         * @return string
         */
        public function getTitle() {}
        public function setTitle($title) {}
        /**
         * Get the alternative title.
         *
         * @return string
         */
        public function getAltTitle() {}
        public function setAltTitle($altTitle) {}
        public function getWidth($round = true) {}
        public function setWidth($width, $default = 100) {}
        public function getHeight($round = true) {}
        public function setHeight($height, $default = 100) {}
        /**
         * Get the thumbnail scaling method.
         *
         * @return string
         */
        public function getScale() {}
        public function setScale($scale) {}
    }

}

namespace Bolt\Pager {
    /**
     * Class PagerManager
     * -------------------
     *  is a centralized service that would be instantiated lazily by PagerServiceProvider.
     *  It's changes Pager:: based, global smelling static calls that would be served by the manager to
     *  fit TDD principle.
     *  The service will be accessible via ``$app['pager']`` then.
     *
     * Role of the manager
     * -------------------
     * - manages Pager elements which are atomic objects of a paging reference and roughly corresponding current Bolt\Pager
     *   objects
     * - responsible for decoding/encoding pager objects from/to query parameters
     * - centralizing all pager related operations like
     *      ``$page = ($request->query) ? $request->query->get($param, $request->query->get('page', 1)) : 1;``
     *      that occurs redundantly in code atm
     * - a pager element would be reached as ``$app['pager']['search']``
     * - ``(string) $app['pager']`` for encoding html query rather than ``Pager::makeLink()``
     * - no more ``Bolt\Legacy\Storage::GetContent()`` (and others) has to receive &$pager as argument, which is not so clear
     *   enough
     *
     * Conventions:
     * ------------
     *  - *Context Id* : Textual id of a pager element. It is hints the context or content type where the pager is refers to
     *  - *Pager Id* / *Parameter Id* : Full text id of a pager object in placeholder array. It is a key with
     * ``<PAGE>_<context_id>``. Query parameters can contain current page state under this parameter id.
     *
     * Practical:
     * ----------
     *  - Variable ``pager`` injected into templates contains a member ``manager`` furthermore, so PagerManager API can be
     *  accessed via
     *  - Instantiating PagerManager - like reaching ``$app['pager']`` - decodes http page parameters and can be addressed
     *  by their context id. So ``$app['pager']['entities']`` returns a Pager object decoded from query parameters was
     *  ``page_entities=N`` originally
     *
     * @author Rix Beck <rix@neologik.hu>
     */
    class PagerManager implements \arrayaccess {
        const PAGE = 'page';

        protected $link;
        protected $pagers;
        protected $request;

        public static function isPagingRequest(Request $request) {}
        public function initialize(Request $request) {}
        public function makeLink($linkFor = null) {}
        public function makeParameterId($contextId = null) {}
        /**
         * Decodes HTTP query url and stores in addressable format.
         */
        public function decodeHttpQuery() {}
        public function encodeHttpQuery($qparams = null) {}
        /**
         * Object string encoder.
         *
         * @return string Encoded query string
         */
        public function __toString() {}
        public function offsetExists($contextId) {}
        public function offsetSet($contextId, $pager) {}
        public function offsetUnset($contextId) {}
        public function offsetGet($contextId) {}
        /**
         * Returns context ids array.
         *
         * @return array
         */
        public function keys() {}
        /**
         * Returns empty status of Pager object array.
         *
         * @return bool
         */
        public function isEmptyPager() {}
        public function setLink($link) {}
        public function createPager($contextId = null) {}
        public function getPager($contextId = null) {}
        public function getCurrentPage($contextId = null) {}
        /**
         * @return array
         */
        public function getPagers() {}
        /**
         * Strict getter for request property.
         *
         * @throws \RuntimeException
         *
         * @return Request
         */
        public function getRequest() {}
        protected function findPagerId($contextId = null) {}
        /**
         * Builds an array of Pagers with current page values.
         *
         * @return array
         */
        protected function remapPagers() {}
        /**
         * Finds any initialized pager and gets its pager id.
         *
         * @return int|string
         */
        protected function findInitializedPagerId() {}
    }

    /**
     * Class Pager
     *  Elementary pager object.
     *
     * @author Rix Beck <rix@neologik.hu>
     */
    class Pager extends \bolt\legacy\abstractpager {
        public $for;
        public $count;
        public $totalpages;
        public $current;
        public $showingFrom;
        public $showingTo;
        /**
         * @var PagerManager
         */
        public $manager;

        public function __construct(PagerManager $manager = null) {}
        public function setFor($for) {}
        public function setCount($count) {}
        public function setTotalpages($totalpages) {}
        public function setCurrent($current) {}
        public function setShowingFrom($showingFrom) {}
        public function setShowingTo($showingTo) {}
        public function setManager($manager) {}
        public function makeLink($linkFor = '') {}
        /**
         * For v2 and v3 BC reasons.
         *
         * @return array
         */
        public function asArray() {}
    }

}

namespace Bolt\Debug\Caster {
    /**
     * Casters for Filesystem objects.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class FilesystemCasters extends \bolt\debug\caster\abstractcasterprovider {
        /**
         * @return array
         */
        protected static function defineCasters() {}
        public static function castHandler(HandlerInterface $handler, array $a, Stub $stub, $isNested, $filter = 0) {}
        public static function castFile(FileInterface $file, array $a, Stub $stub, $isNested, $filter = 0) {}
        public static function castDirectory(DirectoryInterface $directory, array $a, Stub $stub, $isNested, $filter = 0) {}
        public static function castImage(Image $image, array $a, Stub $stub, $isNested, $filter = 0) {}
        public static function castImageInfo(Image\Info $info, array $a, Stub $stub, $isNested, $filter = 0) {}
        public static function castImageType(Image\Type $type, array $a, Stub $stub, $isNested, $filter = 0) {}
        public static function castDimensions(Image\Dimensions $dimensions, array $a, Stub $stub, $isNested, $filter = 0) {}
        public static function castImageExif(Image\Exif $exif, array $a, Stub $stub, $isNested, $filter = 0) {}
    }

    /**
     * Abstract class providing casters.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    abstract class AbstractCasterProvider {
        /**
         * @return callable[]
         */
        protected static function defineCasters() {}
        /**
         * @return callable[]
         */
        public static function getCasters() {}
    }


    /**
     * Helper to make proxy classes transparent to VarDumper.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait TransparentProxyTrait {
        /** @var bool */
        protected $transparent;
        /**
         * @return string
         */
        abstract protected function getProxiedClass() ;
        /**
         * @return object|array
         */
        abstract protected function getProxiedObject() ;
        public function setTransparent($bool = true) {}
        public static function registerCaster(AbstractCloner $cloner) {}
    }

}

namespace Bolt\Nut {
    /**
     * Nut command to output phpinfo().
     */
    class Info extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to perform initial setup tasks.
     */
    class Init extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        /**
         * Archive distributions have the site bundle files installed as .dist
         * files to prevent the real files being overridden. If the .dist file
         * exists, but the original doesn't then we should rename them.
         */
        private function updateDistBundles() {}
    }

    /**
     * Nut command to repair/update database schema.
     */
    class DatabaseRepair extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        /**
         * Dump the output.
         */
        private function dumpSql() {}
    }

    /**
     * Nut command to clear the cache.
     */
    class CacheClear extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to dump system listened events, and target callable.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DebugEvents extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        protected function getTable(OutputInterface $output) {}
    }

    /**
     * Nut building block.
     */
    abstract class BaseCommand extends \symfony\component\console\command\command {
        /** @var Container */
        protected $app;
        /** @var NutStyle */
        protected $io;

        public function __construct(Container $app = null) {}
/** @var ContainerHelper $helper */
        protected function initialize(/** @var ContainerHelper $helper */
InputInterface $input, /** @var ContainerHelper $helper */
OutputInterface $output) {}
        protected function auditLog($source, $message) {}
    }

    /**
     * Nut command to update extensions.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExtensionsUpdate extends \bolt\nut\basecommand {
        /** @var PingService */
        private $pinger;

        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function initialize(InputInterface $input, OutputInterface $output) {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to set parameter value in a YAML configuration file.
     */
    class ConfigSet extends \bolt\nut\abstractconfig {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function doExecute(YamlUpdater $updater, InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Runs Bolt application using PHP built-in web server.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ServerRun extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        public function configure() {}
/** @var ProcessHelper $helper */
        protected function execute(/** @var ProcessHelper $helper */
InputInterface $input, /** @var ProcessHelper $helper */
OutputInterface $output) {}
        protected function createServerProcess($address, $webDir, $router) {}
        protected function isOtherServerProcessRunning($address) {}
        protected function getLockFile($address) {}
    }

    /**
     * Nut command to perform Bolt set-up (first time, or post-update) tasks.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SetupRun extends \bolt\nut\basecommand {
        /** @var int */
        protected $step;
        /** @var array */
        protected $firstUser;
        /** @var bool */
        protected $isDbSetup;

        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        /**
         * @return bool
         */
        protected function reconcileSystemRequirements() {}
        protected function reconcileDatabaseConfiguration($isInteractive) {}
        protected function reconcileDatabaseSchema(InputInterface $input, OutputInterface $output) {}
/** @var UsersRepository $repo */
        protected function reconcileRootUser(/** @var UsersRepository $repo */
OutputInterface $output) {}
        protected function reconcileExtensionEnvironment(OutputInterface $output) {}
        protected function reconcileInitialConfig(OutputInterface $output) {}
        /**
         * @return array
         */
        private function displayConfigTable() {}
        /**
         * Finishing step.
         *
         * Let new sites know set up is complete and login name.
         *
         * @return int
         */
        protected function finish() {}
        protected function getBufferedOutput(OutputInterface $output, $verbosity = null) {}
        protected function writeBufferedOutput(BufferedOutput $buffer, $result) {}
        private function step($step, $message) {}
        /**
         * Write the welcome message.
         */
        private function writeWelcome() {}
    }

    /**
     * Nut command to add a user to the system.
     */
    class UserAdd extends \bolt\nut\abstractuser {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function interact(InputInterface $input, OutputInterface $output) {}
/** @var \Bolt\Storage\Repository\UsersRepository $repo */
        protected function execute(/** @var \Bolt\Storage\Repository\UsersRepository $repo */
InputInterface $input, /** @var \Bolt\Storage\Repository\UsersRepository $repo */
OutputInterface $output) {}
/** @var FormInterface $form */
        private function validate(/** @var FormInterface $form */
Entity\Users $userEntity) {}
    }

    /**
     * Nut command to run cron tasks.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class CronRunner extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Database pre-fill command.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DatabasePrefill extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        private function reportWarn(Bag $results) {}
        private function reportError(Bag $results) {}
        private function reportCreate(Bag $results) {}
        /**
         * @return array
         */
        private function getContentTypeNames() {}
    }

    /**
     * Nut command to install an extension.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExtensionsInstall extends \bolt\nut\basecommand {
        /** @var PingService */
        private $pinger;

        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function initialize(InputInterface $input, OutputInterface $output) {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to update extension autoloaders.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExtensionsDumpAutoload extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to perform a database consistency check command.
     */
    class DatabaseCheck extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
/** @var \Bolt\Storage\Database\Schema\SchemaCheck $response */
        protected function execute(/** @var \Bolt\Storage\Database\Schema\SchemaCheck $response */
InputInterface $input, /** @var \Bolt\Storage\Database\Schema\SchemaCheck $response */
OutputInterface $output) {}
        /**
         * Render diffs.
         */
        protected function showDiffs() {}
        /**
         * Display a section of tables to be created.
         */
        protected function showCreates() {}
        /**
         * Display a section of tables to be altered.
         */
        protected function showAlterations() {}
    }

    /**
     * Nut command to run all available PHPUnit tests.
     */
    class TestRunner extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to remove a role from a Bolt user account.
     */
    class UserRoleRemove extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Config command base class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class AbstractConfig extends \bolt\nut\basecommand {
        /** @var FileInterface */
        protected $file;

        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        abstract protected function doExecute(YamlUpdater $updater, InputInterface $input, OutputInterface $output) ;
    }

    /**
     * Nut command to clear the system & change logs.
     */
    class LogTrim extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to add a role to a Bolt user account.
     */
    class UserRoleAdd extends \bolt\nut\abstractuser {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function interact(InputInterface $input, OutputInterface $output) {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut database exporter command.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DatabaseExport extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
/** @var JsonFile|YamlFile $file */
        protected function execute(/** @var JsonFile|YamlFile $file */
InputInterface $input, /** @var JsonFile|YamlFile $file */
OutputInterface $output) {}
        private function getResolvedPaths(InputInterface $input) {}
    }

    /**
     * User command base class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    abstract class AbstractUser extends \bolt\nut\basecommand {
        protected function askUserName(InputInterface $input) {}
        protected function askDisplayName(InputInterface $input) {}
        protected function askEmail(InputInterface $input) {}
        protected function askPassword(InputInterface $input) {}
        protected function askRole(InputInterface $input) {}
    }

    /**
     * Pimple container dumper command for PhpStorm & IntelliJ IDEA.
     *
     * @author Carson Full <carsonfull@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class PimpleDump extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        public function isEnabled() {}
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to reset a user password.
     */
    class UserResetPassword extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut database importer command.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DatabaseImport extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
/** @var JsonFile|YamlFile $file */
        protected function execute(/** @var JsonFile|YamlFile $file */
InputInterface $input, /** @var JsonFile|YamlFile $file */
OutputInterface $output) {}
        private function getResolvedPaths(InputInterface $input) {}
    }

    /**
     * Nut command to uninstall an extension.
     *
     * @author Ross Riley <riley.ross@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExtensionsUninstall extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to manage a user.
     */
    class UserManage extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        protected function getUser(UsersRepository $repo, $userLogin) {}
    }

    /**
     * Nut command to list all users.
     */
    class UsersList extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to dump system provider registration order.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DebugServiceProviders extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to optimize the running database.
     */
    class DatabaseOptimize extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
/** @var Connection $db */
        protected function execute(/** @var Connection $db */
InputInterface $input, /** @var Connection $db */
OutputInterface $output) {}
        /**
         * @throws RuntimeException
         *
         * @return MutableBag
         */
        private function getPlatformUpdates() {}
        /** @var \Bolt\Config $config */
        private function assertMaintenanceMode() {}
    }

    /**
     * Nut command to perform Bolt web asset sync.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class SetupSync extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
/** @var \Bolt\Configuration\Environment $environment */
        protected function execute(/** @var \Bolt\Configuration\Environment $environment */
InputInterface $input, /** @var \Bolt\Configuration\Environment $environment */
OutputInterface $output) {}
        /**
         * Mirror the bolt/themes themes with the public theme directory.
         */
        private function mirrorThemes() {}
    }

    /**
     * Nut command to dump system routes.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DebugRouter extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        protected function formatArrayAsYaml($array) {}
        protected function executeAll(InputInterface $input, OutputInterface $output) {}
        private function sortRoutes(array $routes) {}
        private function sortPattern(array $routes) {}
        private function getMethods(Route $route) {}
        private function sortMethods(array $routes) {}
    }

    /**
     * Nut command to set up extension directories.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ExtensionsSetup extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
        /**
         * Create or update the extensions/composer.json file.
         */
        private function setupJson() {}
        /**
         * Set up the Composer autoloader.
         *
         * @throws \Bolt\Exception\PackageManagerException
         */
        private function setupAutoloader() {}
        private function outputResult($result) {}
    }

    /**
     * A console command to test route matching.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class RouterMatch extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
/** @var RouteCollection $router */
        protected function execute(/** @var RouteCollection $router */
InputInterface $input, /** @var RouteCollection $router */
OutputInterface $output) {}
    }

    /**
     * Nut command to clear the system & change logs.
     */
    class LogClear extends \bolt\nut\basecommand {
        /** @deprecated Deprecated since 3.4, to be removed in 4.0. Use --no-interaction */
        protected function configure() {}
        protected function execute(InputInterface $input, OutputInterface $output) {}
    }

    /**
     * Nut command to list all installed extensions.
     */
    class Extensions extends \bolt\nut\basecommand {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
/** @var \Composer\Package\CompletePackageInterface $package */
        protected function execute(/** @var \Composer\Package\CompletePackageInterface $package */
InputInterface $input, /** @var \Composer\Package\CompletePackageInterface $package */
OutputInterface $output) {}
    }

    /**
     * Nut command to get a parameter value from a YAML configuration file.
     */
    class ConfigGet extends \bolt\nut\abstractconfig {
        /**
         * {@inheritdoc}
         */
        protected function configure() {}
        protected function doExecute(YamlUpdater $updater, InputInterface $input, OutputInterface $output) {}
    }

}

namespace Bolt\Nut\Output {
    /**
     * An Output wrapper that can capture groups of output and remove/overwrite them later.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class OverwritableOutput implements \bolt\nut\output\overwritableoutputinterface {
    use \bolt\nut\output\outputwrappertrait;

        /** @var BufferedOutput */
        private $buffer;
        /** @var Capture[] */
        private $captures;

        public function __construct(OutputInterface $output) {}
        /**
         * {@inheritdoc}
         */
        public function capture() {}
        public function captureUserInput($input) {}
        /**
         * {@inheritdoc}
         */
        public function remove() {}
        public function write($messages, $newline = false, $options = 0) {}
        public function writeln($messages, $options = 0) {}
    }

    /**
     * Holds text that could be overwritten in console.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class Capture {
        private $text;

        public function append($text) {}
        public function overwrite(OutputFormatterInterface $formatter, $width) {}
        private function cleanAutocomplete($newText) {}
        private function getLines($text, $width, OutputFormatterInterface $formatter) {}
        private function chunk($text, $width) {}
    }


    /**
     * Combines OverwritableOutputInterface & OverwritableStyleInterface.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface NutStyleInterface extends \bolt\nut\output\overwritableoutputinterface {}

    /**
     * An Output that can capture groups of output text and remove/overwrite them later.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface OverwritableOutputInterface extends \symfony\component\console\output\outputinterface {
        /**
         * Start capturing output to remove.
         *
         * This should start a new capture each time it is called.
         */
        function capture() ;
        /**
         * Remove output from latest capture.
         */
        function remove() ;
        function captureUserInput($input) ;
    }


    /**
     * Trait to help create OutputInterface wrappers.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    trait OutputWrapperTrait {
        /** @var OutputInterface */
        protected $output;
        public function write($messages, $newline = false, $options = 0) {}
        public function writeln($messages, $options = 0) {}
        public function isQuiet() {}
        public function isVerbose() {}
        public function isVeryVerbose() {}
        public function isDebug() {}
        public function setVerbosity($level) {}
        public function getVerbosity() {}
        public function setDecorated($decorated) {}
        public function isDecorated() {}
        public function setFormatter(OutputFormatterInterface $formatter) {}
        public function getFormatter() {}
    }

}

namespace Bolt\Nut\Style {
    /**
     * Nut custom style.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class NutStyle extends \symfony\component\console\style\symfonystyle implements \bolt\nut\output\nutstyleinterface {
        /** @var InputInterface */
        protected $input;
        /** @var OverwritableOutputInterface */
        protected $output;
        /** @var QuestionHelper */
        protected $questionHelper;

        public function __construct(InputInterface $input, OutputInterface $output) {}
        public static function fromComposer(IOInterface $io) {}
        /**
         * {@inheritdoc}
         */
        public function isInteractive() {}
        public function askThenRemove($question, $default = null, $validator = null) {}
        public function askHiddenThenRemove($question, $validator = null) {}
        public function confirmThenRemove($question, $default = true) {}
        public function choiceThenRemove($question, array $choices, $default = null) {}
        public function askQuestionThenRemove(Question $question) {}
        /**
         * {@inheritdoc}
         */
        public function capture() {}
        /**
         * {@inheritdoc}
         */
        public function remove() {}
        public function captureUserInput($input) {}
        /**
         * {@inheritdoc}
         */
        public function isQuiet() {}
        /**
         * {@inheritdoc}
         */
        public function isVerbose() {}
        /**
         * {@inheritdoc}
         */
        public function isVeryVerbose() {}
        /**
         * {@inheritdoc}
         */
        public function isDebug() {}
    }


    /**
     * An extension of StyleInterface that adds user input methods that remove their output afterwards.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    interface OverwritableStyleInterface extends \symfony\component\console\style\styleinterface {
        /**
         * Returns whether the input is interactive.
         *
         * @return bool
         */
        function isInteractive() ;
        function askThenRemove($question, $default = null, $validator = null) ;
        function askHiddenThenRemove($question, $validator = null) ;
        function confirmThenRemove($question, $default = true) ;
        function choiceThenRemove($question, array $choices, $default = null) ;
        function askQuestionThenRemove(Question $question) ;
    }

}

namespace Bolt\Nut\Helper {
    /**
     * An easy way to get the terminal's width/height.
     *
     * Values are not cached here for accuracy, so limited calls to this class is recommended.
     *
     * This started from Symfony's code, and modified to be its own class and to use a signal handler if available.
     *
     * Symfony 3.x does have their own Terminal class, but values are cached there. If the user resizes their terminal
     * window the code will never know about it.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class Terminal {
        static private $width;
        static private $height;
        static private $pcntlEnabled;
        static private $pcntlAsync;
        static private $pcntlNeedsUpdate;

        /**
         * Returns the Terminal's width.
         *
         * @return int
         */
        public static function getWidth() {}
        /**
         * Returns the Terminal's height.
         *
         * @return int
         */
        public static function getHeight() {}
        /**
         * Update our dimension properties.
         */
        private static function updateDimensions() {}
        /**
         * Initializes and checks if we have received a SIGWINCH signal.
         *
         * @return bool whether dimensions should be fetched
         */
        private static function checkPcntl() {}
        /**
         * Fetch dimensions based on platform.
         */
        private static function fetchDimensions() {}
        /**
         * Parse width & height from ANSICON env var.
         *
         * @return int[]
         */
        private static function getAnsiCon() {}
        /**
         * Run console mode command and parse output to width & height.
         *
         * @return int[]
         */
        private static function getConsoleMode() {}
        /**
         * Run stty command and parse output to width & height.
         *
         * @return int[]
         */
        private static function getSttyColumns() {}
        private static function runCommand($command) {}
    }

    /**
     * Bridges Container to commands.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ContainerHelper extends \symfony\component\console\helper\helper {
        /** @var Container */
        private $container;

        public function __construct(Container $container) {}
        /**
         * @return Container
         */
        public function getContainer() {}
        /**
         * {@inheritdoc}
         */
        public function getName() {}
    }

    /**
     * A QuestionHelper that can remove all output when done.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    final class QuestionHelper extends \symfony\component\console\helper\symfonyquestionhelper {
        /** @var bool */
        private $remove;
        /** @var Question */
        private $question;
        /** @var OverwritableOutputInterface */
        private $output;
        /** @var bool */
        private $autocomplete;
        /** @var bool */
        static private $stty;

        /**
         * Constructor.
         */
        public function __construct() {}
        public function askThenRemove(InputInterface $input, OverwritableOutputInterface $output, Question $question) {}
        public function setInputStream($stream) {}
        protected function onRead($data) {}
        /**
         * Returns whether Stty is available or not.
         *
         * @return bool
         */
        private function hasSttyAvailable() {}
    }

    /**
     * Extends Symfony's Table to provide an overwrite method.
     *
     * Table values can be updated then, instead of calling render(),
     * call overwrite() and the previous table will be removed and
     * the new one will be rendered.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class Table extends \symfony\component\console\helper\table {
        /** @var OverwritableOutputInterface */
        private $output;
        /** @var bool */
        private $previouslyRendered;

        public function __construct(OverwritableOutputInterface $output) {}
        /**
         * Remove previously rendered table, then render again with new data.
         *
         * This assumes the table is the last output on the terminal.
         */
        public function overwrite() {}
    }

}

namespace Bolt\EventListener {
    /**
     * AccessControl listener class.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class AccessControlListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var FilesystemInterface */
        protected $filesystem;
        /** @var SessionStorage */
        protected $sessionStorage;
        /** @var EntityManagerInterface */
        protected $em;

        public function __construct(FilesystemInterface $filesystem, SessionStorage $sessionStorage, EntityManagerInterface $em) {}
/** @var Entity\Users $userEntity */
        public function onStorageEventPostSave(/** @var Entity\Users $userEntity */
StorageEvent $event) {}
/** @var Entity\Users $userEntity */
        public function onStorageEventPreDelete(/** @var Entity\Users $userEntity */
StorageEvent $event) {}
/** @var Repository\AuthtokenRepository $repo */
        private function deleteAuthtokens(/** @var Repository\AuthtokenRepository $repo */
Entity\Users $user) {}
/** @var \Bolt\AccessControl\Token\Token $token */
        private function deleteSessions(/** @var \Bolt\AccessControl\Token\Token $token */
Entity\Users $user) {}
        public static function getSubscribedEvents() {}
    }

    /**
     * Log kernel events to system logger.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class SystemLoggerListener implements \symfony\component\eventdispatcher\eventsubscriberinterface, \psr\log\loggerawareinterface {
    use \psr\log\loggerawaretrait;

        public function __construct(LoggerInterface $logger) {}
        public function onException(GetResponseForExceptionEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * Listener for redirects.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class RedirectListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var \Symfony\Component\HttpFoundation\Session\Session */
        protected $session;
        /** @var \Symfony\Component\Routing\Generator\UrlGeneratorInterface */
        protected $urlGenerator;
        /** @var \Bolt\Users */
        protected $users;
        /** @var \Bolt\AccessControl\AccessChecker $authentication */
        protected $authentication;

        public function __construct(Session $session, UrlGeneratorInterface $urlGenerator, Users $users, AccessChecker $authentication) {}
        public function onResponse(FilterResponseEvent $event) {}
        protected function handleNoBackendAccess(RedirectResponse $response) {}
        protected function handleLoginRetreat(Request $request, RedirectResponse $response) {}
        /**
         * Return the events to subscribe to.
         *
         * @return array
         */
        public static function getSubscribedEvents() {}
    }

    class SnippetListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var QueueInterface[] */
        protected $queues;
        /** @var Canonical */
        protected $canonical;
        /** @var Packages */
        protected $packages;
        /** @var Config */
        protected $config;

        public function __construct(array $queues, Canonical $canonical, Packages $packages, Config $config) {}
        public function onResponse(FilterResponseEvent $event) {}
        /**
         * Add base snippets to the response.
         */
        protected function addSnippets() {}
        protected function encode($str) {}
        public static function getSubscribedEvents() {}
    }

    /**
     * Disable browser's XSS detection for given routes.
     *
     * These routes should still verify the request data with a CSRF token.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class DisableXssProtectionListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var string[] */
        protected $routes;

        public function __construct(array $routes) {}
/** @deprecated since 3.4 to be removed in 4.0 */
        public function onResponse(/** @deprecated since 3.4 to be removed in 4.0 */
FilterResponseEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    class StorageEventListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
    use \bolt\request\profilerawaretrait;

        /** @var EntityManagerInterface */
        protected $em;
        /** @var EventProcessor\TimedRecord */
        protected $timedRecord;
        /** @var Schema\SchemaManagerInterface */
        protected $schemaManager;
        /** @var UrlGeneratorInterface */
        protected $urlGenerator;
        /** @var \Bolt\Logger\FlashLoggerInterface */
        protected $loggerFlash;
        /** @var PasswordFactory */
        protected $passwordFactory;
        /** @var int */
        protected $hashStrength;
        /** @var bool */
        protected $timedRecordsEnabled;

        public function __construct(EntityManagerInterface $em, EventProcessor\TimedRecord $timedRecord, Schema\SchemaManagerInterface $schemaManager, UrlGeneratorInterface $urlGenerator, FlashLoggerInterface $loggerFlash, PasswordFactory $passwordFactory, $hashStrength, $timedRecordsEnabled) {}
/** @var Entity\Users $entityRecord */
        public function onUserEntityPreSave(/** @var Entity\Users $entityRecord */
StorageEvent $event) {}
        public function onPostHydrate(HydrationEvent $event) {}
        public function onPreDelete(StorageEvent $event) {}
        public function onKernelRequest(GetResponseEvent $event) {}
        protected function schemaCheck(GetResponseEvent $event) {}
        protected function passwordHash(Entity\Users $usersEntity) {}
        private function getValidHash($password) {}
        public static function getSubscribedEvents() {}
    }

    /**
     * Class PagerListener.
     *
     * @author Rix Beck <rix@neologik.hu>
     */
    class PagerListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        protected $manager;

        public function __construct(PagerManager $manager) {}
        public function onRequest(GetResponseEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * Converts controller results that are TemplateView's to TemplateResponse's.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class TemplateViewListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var Environment */
        protected $twig;

        public function __construct(Environment $twig) {}
        public function onView(GetResponseForControllerResultEvent $event) {}
        public function render(TemplateView $view) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * HTTP kernel exception routing listener.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ExceptionListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
    use \bolt\request\profilerawaretrait;

        /** @var Environment */
        protected $twig;
        /** @var string */
        protected $rootPath;
        /** @var DirectoryInterface */
        protected $saveDir;
        /** @var SlugifyInterface */
        protected $slugifer;
        /** @var bool */
        protected $debug;
        /** @var Config */
        protected $config;
        /** @var Users */
        protected $users;
        /** @var SessionInterface */
        protected $session;
        /** @var RequestStack */
        protected $requestStack;

        public function __construct(Environment $twig, $rootPath, DirectoryInterface $saveDir, SlugifyInterface $slugifer, $debug, Config $config, Users $users, SessionInterface $session, RequestStack $requestStack) {}
        public function onBootException(GetResponseForExceptionEvent $event) {}
        public function onKernelException(GetResponseForExceptionEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
        protected function renderException(\Exception $exception) {}
        protected function renderDatabaseException(DatabaseExceptionInterface $exception) {}
        protected function renderSystemValidationException(AbstractSystemValidationException $exception) {}
        protected function getContext(\Exception $exception = null) {}
        protected function getSafeTrace(\Exception $exception) {}
        protected function getSafeArguments(array $args) {}
        protected function saveException(\Exception $exception) {}
    }

    /**
     * Configuration checks at the start of the request cycle.
     *
     * This is a temporary solution to remove the configuration checks from
     * pre-request, until such time as configuration can be refactored.
     *
     * @internal do not extend/call
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ConfigListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var Application */
        private $app;

        public function __construct(Application $app) {}
        public function onRequestEarly(GetResponseEvent $event) {}
        public function onRequest(GetResponseEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
        /**
         * If required set a notification of version change, for admin users.
         */
        private function setVersionChangeNotice() {}
        /**
         * Get the parameters that will be used to update Bolt's registered Twig
         * globals.
         *
         * This is here as a transitory measure.
         */
        private function setGlobals() {}
    }

    /**
     * Renders the not found page in the event of an HTTP exception.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class NotFoundListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var string */
        protected $notFoundPage;
        /** @var Storage */
        protected $storage;
        /** @var TemplateChooser */
        protected $templateChooser;
        /** @var Environment */
        private $twig;

        public function __construct($notFoundPage, Storage $storage, TemplateChooser $templateChooser, Environment $twig) {}
        public function onKernelException(GetResponseForExceptionEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
        private function renderNotFound(GetResponseForExceptionEvent $event, $template, array $context = [ ]) {}
    }

    /**
     * Symfony Profiler listener.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class ProfilerListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
    use \bolt\request\profilerawaretrait;

        /** @var SessionInterface */
        private $session;
        /** @var bool */
        private $debug;
        /** @var bool */
        private $debugLoggedOff;

        public function __construct(SessionInterface $session, $debug, $debugLoggedOff) {}
        public function onKernelRequest(GetResponseEvent $event) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * Determine what zone a request is relative to.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ZoneGuesser implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var \Silex\Application $app */
        protected $app;

        public function __construct(Application $app) {}
        public function onKernelRequest(GetResponseEvent $event) {}
        public function setZone(Request $request) {}
        protected function determineZone(Request $request) {}
        protected function isPathApplicable(Request $request, $zone) {}
        protected function startsWith($path, $prefix) {}
        /**
         * Return the events to subscribe to.
         *
         * @return array
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * Listener for Doctrine events.
     *
     * @author Carson Full <carsonfull@gmail.com>
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class DoctrineListener implements \doctrine\common\eventsubscriber {
    use \psr\log\loggerawaretrait;

        /** @var Config */
        private $config;

        public function __construct(Config $config, LoggerInterface $logger) {}
        public function failConnect(FailedConnectionEvent $args) {}
/** @see https://github.com/doctrine/dbal/pull/828 */
        public function postConnect(/** @see https://github.com/doctrine/dbal/pull/828 */
ConnectionEventArgs $args) {}
        public function getSubscribedEvents() {}
    }

    /**
     * Converts HTTP exceptions to JSON responses.
     *
     * @author Carson Full <carsonfull@gmail.com>
     */
    class ExceptionToJsonListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var PathResolver */
        private $pathResolver;

        public function __construct(PathResolver $pathResolver) {}
        public function onException(GetResponseForExceptionEvent $event) {}
        protected function isApplicable(Request $request) {}
        protected function convert(\Exception $exception) {}
        protected function getErrorType(\Exception $exception) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     * @author Carson Full <carsonfull@gmail.com>
     */
    class FlashLoggerListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var FlashBagAttachableInterface */
        protected $flashLogger;
        /** @var bool */
        protected $debug;
        /** @var string */
        protected $profilerMountPrefix;

        public function __construct(FlashBagAttachableInterface $flashLogger, $debug, $profilerMountPrefix) {}
        public function onRequest(GetResponseEvent $event) {}
        public function onEvent($event) {}
        protected function attachFlashBag(SessionInterface $session) {}
        /**
         * {@inheritdoc}
         */
        public static function getSubscribedEvents() {}
    }

    /**
     * General routing listeners.
     *
     * @author Gawain Lynch <gawain.lynch@gmail.com>
     */
    class GeneralListener implements \symfony\component\eventdispatcher\eventsubscriberinterface {
        /** @var \Silex\Application $app */
        protected $app;

        public function __construct(Application $app) {}
        public function onResponse(FilterResponseEvent $event) {}
        protected function setFrameOptions(Request $request, Response $response) {}
        /**
         * Return the events to subscribe to.
         *
         * @return array
         */
        public static function getSubscribedEvents() {}
    }

}

?>
